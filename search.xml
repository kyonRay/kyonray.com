<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hyperledger Indy分析报告</title>
      <link href="/2019/07/16/Hyperledger-Indy-Research/"/>
      <url>/2019/07/16/Hyperledger-Indy-Research/</url>
      
        <content type="html"><![CDATA[<p>Hyperledger Indy提供了一种基于区块链或其他分布式账本的分布式数字身份（DID）方案，这种方案中包含了各种工具、库和可重用工具，以便于这些数字身份可在多个管理域、应用程序以及其他任何数据孤岛上互通。</p><a id="more"></a><h2 id="一indy架构综述">一、Indy架构综述</h2><p>从横向看，Indy主要分为项目分布、生态系统架构、数据模型(DID、DID Document、Verified Credentials)；从纵向看，Indy主要分为业务层(Business Layer)、应用层(Applications Layer)和技术层(Technology Layer)。</p><p>总体架构如下图所示：</p><figure><img src="./HBB-Indy-Sovrin_ARM_v0.27.png" alt="HBB-Indy-Sovrin ARM v0.27"><figcaption>HBB-Indy-Sovrin ARM v0.27</figcaption></figure><h3 id="业务层">1. 业务层</h3><figure><img src="./image-20190704181446731.png" alt="image-20190704181446731"><figcaption>image-20190704181446731</figcaption></figure><p>业务层主要使用以下几个应用层提供的功能服务：凭证发行（Issue）、凭证存储（Local Store）、数据请求（Request）、凭证披露（Present）、凭证验证（Verify）、凭证撤销（Revocate）用户注册登录等。</p><h3 id="应用层">2. 应用层</h3><p>应用层主要功能：提供DID服务、提供凭证服务、提供特定业务服务。</p><figure><img src="./image-20190704181354240.png" alt="image-20190704181354240"><figcaption>image-20190704181354240</figcaption></figure><p>应用层由Indy底下 <a href="https://github.com/hyperledger/indy-agent" target="_blank" rel="noopener">Indy-Agent</a> 和 <a href="https://github.com/hyperledger/indy-sdk" target="_blank" rel="noopener">Indy-SDK</a> 两个项目支撑。Indy-SDK项目提供钱包功能组件（Wallet Component）支撑数据存储与开发，使用技术层Agent API提供的服务；Indy-Agent项目提供代理功能组件（Agent Component）支撑业务开发。</p><h3 id="技术层">3. 技术层</h3><figure><img src="./image-20190704181540967.png" alt="image-20190704181540967"><figcaption>image-20190704181540967</figcaption></figure><p>技术层也可再分为<strong>Cloud Agent</strong>层和<strong>Ledger</strong>层。</p><p><strong>Cloud Agent</strong>层由Indy-Agent项目、Indy-SDK项目和 <a href="https://github.com/decentralized-identity/universal-resolver" target="_blank" rel="noopener">DIF Universal-Resolver</a> 项目作支撑，主要功能是提供对Edge Agent的服务，直接与Ledger层进行交互，将请求结果返回到应用层。Indy-SDK项目调用Ledger层的API，实现直接与区块链进行交互；Indy-Agent项目调用Indy-SDK的钱包API，提供代理功能组件，并提供凭证注册组件（Credential Registry Node Component）实现凭证的注册；DIF Universal-Resolver项目提供DID的解析器组件，直接与Ledger层交互，解析出DID。</p><p><strong>Ledger</strong>层由 <a href="https://github.com/hyperledger/indy-node" target="_blank" rel="noopener">Indy-Node</a> 和 <a href="https://github.com/hyperledger/indy-plenum" target="_blank" rel="noopener">Indy-Plenum</a> 两个项目实现，主要功能是实现Indy区块链的功能。Indy-Plenum</p><p>项目主要实现的是Plenum BFT共识协议，是Fabric for Identity的定制版，是整个Indy项目的核心部分；Indy-Node是在Indy-Plenum区块链之上的服务器，直接与区块链层进行交互，实现节点功能。</p><h3 id="数据模型">4. 数据模型</h3><p>DID、DID Document都是按照W3C所定的<a href="https://w3c-ccg.github.io/did-spec/" target="_blank" rel="noopener">数据标准</a>建立的，主要关系如下图所示：</p><figure><img src="./image-20190704171205582.png" alt="image-20190704171205582"><figcaption>image-20190704171205582</figcaption></figure><h2 id="二hyperledger-indy工作流">二、Hyperledger Indy工作流</h2><p>以一个Alice从Faber大学毕业找工作的场景简单介绍Hyperledger Indy的工作流。（<a href="https://medium.com/@kctheservant/exploring-hyperledger-indy-through-indy-dev-example-10075d2547ae" target="_blank" rel="noopener">链接</a>）</p><p><strong>Step 1:</strong> 政府生成凭证模板(Schema)</p><figure><img src="./Step1.png" alt="img"><figcaption>img</figcaption></figure><p>政府颁发Transcript Schema和Job-Certificate Schema，并将其记录到分布式账本中。每个人都可以访问这些模板。</p><p><strong>Step 2：</strong> Faber大学和Acme公司生成他们自己的凭证定义(Credential definition)</p><p>Faber大学和Acme公司根据政府发布的模板创建自己的凭证的定义，并将定义上传到链上。</p><figure><img src="./step2_1.png" alt="img"><figcaption>img</figcaption></figure><figure><img src="./step2_2.png" alt="img"><figcaption>img</figcaption></figure><p>Alice从Faber大学获得成绩单(凭证)，然后再申请工作时想Acme公司提供证书作为教育资格证明。</p><p><strong>Step 3：</strong> Alice从Faber大学获得成绩单凭证</p><figure><img src="./step3.png" alt="img"><figcaption>img</figcaption></figure><p>具体子步骤如下：</p><ul><li>Alice与Faber大学建立连接；</li><li>Faber 大学生成Credential offer给Alice；</li><li>Alice从分布式账本中查询Faber大学对成绩单的定义，生成Credential request发送给Faber大学；</li><li>Faber大学生成一个Credential给Alice，这个Credential内含了足够的proof证明凭证的有效性；</li><li>Alice收到Credential，保存到自己的钱包（wallet）。</li></ul><p><strong>Step 4：</strong> Acme公司请求Alice的教育证明</p><figure><img src="./step4.png" alt="img"><figcaption>img</figcaption></figure><p>具体子步骤如下：</p><ul><li>Acme公司与Alice建立连接；</li><li>Acme生成proof request发送给Alice，这个请求中包含了应该符合的条件；</li><li>Alice收到了proof request，基于Credential生成对应的proof，发送给Acme公司；</li><li>Acme公司收到了proof，并验证其有效性；</li><li>Acme公司确认了proof。</li></ul><p>之后Alice获得了Acme的工作凭证（job-certificate），并将该凭证发送给Thrift银行以证明聘期，便可申请贷款。（Alice使用Faber大学给的教育凭证完成了KYC过程）</p><p><strong>Step5：</strong> Alice获得了Acme公司给的工作证明</p><figure><img src="./step5.png" alt="img"><figcaption>img</figcaption></figure><p>具体子步骤如下：</p><ul><li>Acme公司发送Credential Offer给Alice；</li><li>Alice从分布式账本获取Acme Credential的定义，生成Credential request发送给Acme公司；</li><li>Acme公司生成Credential发送给Alice，该凭证中包含了足够多的证明以证明Alice的聘期；</li><li>Alice收到Credential并保存到钱包（wallet）里。</li></ul><p><strong>Step 6 ：</strong> Thrift银行请求Alice的聘期证明，以及Alice 的KYC</p><figure><img src="./step6.png" alt="img"><figcaption>img</figcaption></figure><p>具体子步骤如下：</p><ul><li>Thrift银行与Alice建立连接；</li><li>Thrift银行生成两个proof request，发送给Alice；在这里的例子中，银行要求工资大于2000，工作经验大于1年，以及KYC流程；</li><li>Alice收到两个proof request，基于Faber大学的凭证以及Acme公司的凭证收成两个proof，发送给Thrift银行；</li><li>Thrift银行收到了证明，并确认其有效性；</li><li>Thrift银行确认了Alice的proof。</li></ul><h2 id="三关键技术点">三、关键技术点</h2><p>Indy整个项目的文件分布如下：</p><ul><li><p>分布式账本</p><ul><li><a href="https://github.com/hyperledger/indy-node" target="_blank" rel="noopener"><strong>Indy-Node</strong></a>：实现在基于Plenum BFT的分布式账本功能与节点功能，；</li><li><a href="https://github.com/hyperledger/indy-plenum" target="_blank" rel="noopener"><strong>Indy-Plenum</strong></a>：实现基于Plenum BFT共识机制，定义wallet基类；</li></ul></li><li><p>客户端工具</p><ul><li><a href="https://github.com/hyperledger/indy-sdk" target="_blank" rel="noopener"><strong>Indy-SDK</strong></a>：由两个主要组件构成：libindy(底层)，libVCX(实现层)；</li><li><a href="https://github.com/hyperledger/indy-agent" target="_blank" rel="noopener"><strong>Indy-Agent</strong></a>：项目实现Agent Client，有以下几种功能方向的App：<ul><li>Edge Agent App；</li><li>Edge Agent Web App；</li><li>Edge Agent Lightweight App；</li><li>Cloud Agent Node；</li><li>Ledger Node；</li><li>Credential Registry Agent Mode；</li></ul></li></ul></li><li><p>通用组件：</p><p><a href="https://github.com/hyperledger/indy-crypto" target="_blank" rel="noopener"><strong>Indy-Crypto</strong></a>：承用了Hyperledger URSA，作为Indy的密码学代码库；</p><p><a href="https://github.com/hyperledger/indy-hipe" target="_blank" rel="noopener"><strong>Indy-HIPE(Hyperledger Indy Project Enhancements)</strong></a>：实现了Indy的功能增强组件。</p></li></ul><p>接下来将按照项目文件的主体部分进行逐层解析。</p><h3 id="indy-plenum">1. Indy-Plenum</h3><figure><img src="./Indy-Plenum.png" alt="Indy-Plenum.png"><figcaption>Indy-Plenum.png</figcaption></figure><p>从内容上看，Plenum项目主要实现了基于RBFT改进的共识机制以及共识操作方法，定义了四种链分别存储整个Indy的配置、事务等信息，定义了DID的wallet以及DID签名验证方法。项目主要分为以下几个部分：</p><h4 id="plenum包">1.1 plenum包</h4><p>plenum包实现了基于 <a href="http://lig-membres.imag.fr/aublin/rbft/report.pdf" target="_blank" rel="noopener"><strong>RBFT</strong></a> 改进的Plenum BFT共识算法，在Commit阶段手机n-of-l个的BLS签名，在共识Order阶段，对多个BLS签名进行聚合。（<strong>注</strong>：BLS签名算法在Indy-Crypto中详细说明）</p><p>Plenum共识改进部分大致在以下三点体现：</p><ul><li>RBFT每个请求都会发起三段commit，Plenum是一堆请求才发起三段commit；</li><li>Plenum在PRE-PREPARE和PREPARE阶段都保存了默克尔树根与state树根；</li><li>三段commit都是用了BLS多签名聚合方法，客户端不需要其他节点响应。</li></ul><p>可以通过这个链接看到Plenum共识协议流程图：<a href="https://hyperledger-indy.readthedocs.io/projects/plenum/en/latest/diagrams/index.html" target="_blank" rel="noopener">Plenum Diagrams</a></p><p><strong>此外</strong>，plenum包定义了DID的钱包（wallet）基类，以及DID对消息签名、签名验证的方法。</p><p>钱包类主要数据结构如下：</p><ul><li>name -&gt; str：id名；</li><li>ids -&gt; Dict[Identifier, IdData]：DID到IdData的映射，一个DID一个IdData；</li><li>idsToSigners -&gt; Dict[Identifier, Signer]：DID到Signer的映射，一个DID一个Signer；</li><li>aliasesToIds -&gt; Dict[Alias, Identifier]：(别名)Alias到DID的映射，一个DID对应多个Alias。</li></ul><p>钱包类主要方法：</p><ul><li>Encrypt/Decrypt：均使用 <a href="https://download.libsodium.org/doc/" target="_blank" rel="noopener">libsodium</a>密码库的python封装进行加解密；</li><li>sign/verify：签名和签名验证方法都是基于<a href="https://download.libsodium.org/doc/" target="_blank" rel="noopener">libsodium</a>的sign方法进行的，使用signKey签名，使用veryKey+DID进行验证；</li><li><strong>DID Create</strong>：<ul><li>指定或产生Seed，32byte；</li><li>根据Ed25519算法产生公私钥对 MSK,MPK；</li><li>再将产生的私钥作为种子Seed，使用Ed25519，生成新的公钥VerkeyRaw，新的签名私钥signKey；</li><li>将verKeyRaw的前16字节进行base58解码，成为DID，后16字节为verKey。</li><li>当signKey、verKey丢失时，将可以使用MSK再次重新生成。</li></ul></li><li><strong>Wallet storage</strong>：使用 <a href="https://github.com/jsonpickle/jsonpickle" target="_blank" rel="noopener">jsonpickle</a> 进行JSON序列化和反序列化，保存在本地。</li></ul><h4 id="ledger包">1.2 ledger包</h4><p>ledger包定义了整个区块链结构、创世块、Merkle tree结构以及实现了Merkle tree快速验证方法。</p><h4 id="crypto包">1.3 crypto包</h4><p>crypto包是对Indy-Crypto项目部分功能的封装，主要实现了BLS多重签名。（<strong>注：</strong>BLS多重签名将在Indy-Crypto项目中详细说明）</p><h4 id="存储组件">1.4 存储组件</h4><figure><img src="./storages.png" alt="img"><figcaption>img</figcaption></figure><p>在Ledger组件中默认使用RocksDB和LevelDB进行KV存储，且使用<a href="https://blog.ethereum.org/2015/11/15/merkling-in-ethereum/" target="_blank" rel="noopener"><strong>Merkle Patricia Trie</strong></a> 存储账本状态。每个节点均维护四个账本：</p><ul><li>Audit Ledger：主要负责与其他三个Ledger同步，为失败节点恢复数据，并对账本正确性进行审计；</li><li>Pool Ledger：主要维护池中节点的信息（Membership）；</li><li>Domain Ledger：为主要账本，记录交易；</li><li>Config Ledger：是Pool节点的配置账本。</li></ul><h4 id="底层性能">1.5 底层性能</h4><p>目前暂未有数据文件表明Plenum的性能指标，还需进一步实际测试。</p><p>TODO: 测试Plenum性能指标。</p><h3 id="indy-node">2. Indy-Node</h3><figure><img src="./Indy-Node.png" alt="Indy-Node.png"><figcaption>Indy-Node.png</figcaption></figure><p>Indy-Node项目主要实现了基于Plenum BFT共识协议的分布式账本，以及节点的功能。主要包括：处理读写请求、定义交易类型以及交易分类存储。</p><p>接下来将按照项目文件的主体部分进行逐层解析。</p><h4 id="indy-node-1">2.1 indy-node</h4><p>Indy-node包主要实现基于Plenum BFT共识协议的分布式账本、对交易读写请求的处理以及提供了对特定交易的支持，各类交易都会记录到不同种类的Ledger中：</p><ul><li>存储到Domain Ledger的交易：<ul><li><strong>NYM</strong>：NYM交易主要实现创建新DID、对已存在的DID用户进行角色变更（<strong>注：</strong>角色变更涉及到权限管理，可查看<code>交易权限管理</code>部分的详情）<strong>DID Document</strong>就是对NYM交易进行溯源，即可得到一份完整的DID Document；</li><li>ATTRIB：主要实现对已有NYM添加一个属性；</li><li>SCHEMA：增加一个声明模板，模板主要包含：<code>属性名</code>、<code>模板名</code>、<code>模板版本号</code>；</li><li>CLAIM_DEF：对一个声明进行定义，由<code>Issuer</code>创建并公开，若要对一个声明进行升级，需要用新的Issuer DID进行新的声明，主要包含：<code>声明公钥</code>、<code>声明撤销公钥</code>、<code>签名类型（只支持CL签名算法）</code>；</li></ul></li><li>存储到Pool Ledger的交易：<ul><li>NODE：在池中添加一个节点，或更新一个池中的节点；</li></ul></li><li>存储到Config Ledger的交易：<ul><li>POOL_UPGRADE：由Trustee发起，升级Pool中的配置，也可更新池中特定的节点设置；</li><li>NODE_UPGRADE：记录节点升级后的节点状态，由升级的节点发出；</li><li>POOL_CONFIG：更改池中的配置。</li></ul></li></ul><h4 id="indy-common">2.2 indy-common</h4><p>indy-common包主要定义了角色权限，以及一些对Indy-Plenum项目方法的封装。</p><h4 id="dev-setupevironment">2.3 dev-setup/evironment</h4><p>dev-setup包和evironment包提供了节点部署方案，可以在本机部署（目前只支持Ubuntu、macOS），也可以部署在容器Docker上，可以部署在云端。</p><h4 id="交易权限管理">2.4 交易权限管理</h4><p>Indy中节点可分为<code>common user</code>，<code>trust anchor</code>，<code>steward</code>，<code>trustee</code> 四类，每种特殊交易都有特定的角色权限才可以进行。具体可看<a href="https://hyperledger-indy.readthedocs.io/projects/node/en/latest/auth_rules.html" target="_blank" rel="noopener">链接</a>。</p><h3 id="indy-sdk">3. Indy-SDK</h3><figure><img src="./Indy-SDK.png" alt="Indy-SDK.png"><figcaption>Indy-SDK.png</figcaption></figure><p>Indy-SDK作为Plenum分布式账本的SDK，主要是实现了代理端软件Agent可以与分布式账本、DID钱包以及DID doc进行互通，实现凭证Credential，为不同编程语言封装了主要功能。</p><h4 id="libindy">3.1 libindy</h4><p>如上图所示，libindy包主要面向应用提供了基础的区块构建方法，实现了对钱包Wallet、凭证Credential以及DID的操作，且提供不同编程语言调用的封装。并基于SDK提供了命令行工具CLI。</p><h5 id="credential">Credential</h5><p>Indy Credential工作流图如下图所示： <img src="./工作流图.svg" alt="工作流图"></p><ol type="1"><li><strong>Issuer生成凭证模板(Create Credential Schema)</strong>: Issuer创建某个凭证Schema，并将Schema交易发送给Ledger；</li><li><strong>Issuer生成凭证定义(Create Credential Definition)</strong>: Issuer想Ledger发送获取某个凭证Schema请求，得到Schema后创建凭证定义，存储公私钥对和正确性证明在本地，将该种凭证定义发送给Ledger；</li><li><strong>Issuer生成凭证撤销表(Create Revocation Registry)</strong>: Issuer生成凭证撤销表，并将撤销表入口、撤销表定义发送到Ledger；</li><li><strong>Prover生成主密钥(Create Master secret)</strong>: Prover生成主密钥，并保存在本地；</li><li><strong>Issuer生成凭证提议(Create Credential Offer)</strong>: Issuer想要发行凭证给Prover，向wallet请求，wallet获取对应的正确性证明，再讲cred_offer消息发送给Prover；</li><li><strong>Prover请求，Issuer发行凭证(Request and Issue Credential)</strong>: Prover收到cred_offer消息，向Ledger发送GET_CRED_DEF请求，填写好相应的表单之后生成凭证请求发送给Issuer；Issuer正式发行凭证给Prover，并向Ledger更新凭证撤销表入口；Prover获得凭证后向Ledger验证凭证有效，保存在本地；</li><li><strong>Prover展示凭证(Show Credential on UI)</strong>: Prover向wallet请求，wallet返回对应Credential；</li><li><strong>Prover向Verifier展示凭证(Present Credential to 3rd Party(proof request))</strong>: Verifier发起证明请求，Prover给出相应的凭证，并向Ledger核实该凭证的撤消状态，确认之后便将凭证发送给Verifier；Verifier拿到凭证向Ledger核实；</li><li><strong>Issuer撤销凭证(Revoke Credential)</strong>： Issuer获取密钥和撤销注册表，并向Ledger同步撤销注册表的入口。</li></ol><p>(<strong>注</strong>：Credential相关密码学部分将会在Indy-Crypto部分详细说明)</p><h5 id="command-line-interface">Command Line Interface</h5><p>CLI组件设计如下图所示：</p><figure><img src="./cli-components.svg" alt="cli-components"><figcaption>cli-components</figcaption></figure><h5 id="wallet">Wallet</h5><p>Wallet组件设计如下图所示：</p><figure><img src="./wallet-components.svg" alt="Wallet Components"><figcaption>Wallet Components</figcaption></figure><p>在Secrets API，允许调用密钥生成、DID生成等需要访问加密实体的方法；在Non-secrets API只允许访问存取wallet中特定的DID数据。Wallet API提供方法将钱包记录在本地SQL数据库中存取。</p><h5 id="decentrailized-key-management">Decentrailized Key Management</h5><p>相关文档并不多，只介绍了当密钥丢失时的措施：</p><ul><li>离线物理恢复密钥；</li><li>需要trustee级别的用户进行恢复；</li><li>考虑到安全性，恢复往往需要与密钥轮换和撤销相结合。</li></ul><p>此外，在官方文档中提到了使用Shamir Secret Sharing Scheme是通过分布式密钥碎片存储，在密钥丢失时，只需要将碎片重新整合起来即可恢复。（<strong>注</strong>：Shamir Secret Sharing Scheme会在Indy-Crypto中简单介绍）</p><h4 id="libvcx">3.2 libvcx</h4><p>libvcx包实现了一种Agent-2-Agent的通信协议，用于credentials的交换。主要还是使用JSON进行通信，通信时使用SSL证书进行加密通信。（<strong>注</strong>：Credential的选择性披露将在Indy-Crypto中详细说明）</p><h3 id="indy-agent">4. Indy-Agent</h3><p>Indy-Agent项目是一个基于Indy-SDK实现的代理客户端的合集，目前已有多种语言的客户端实现。</p><h3 id="indy-crypto">5. Indy-Crypto</h3><p>Indy-Crypto项目是Hyperledger URSA密码库的一部分，主要在Indy项目使用的密码学方法有： <code>BLS多签算法</code> ， <code>CL群签名算法</code> 。其中，Indy使用BLS多签算法，减少Plenum共识算法的轮训，减少签名长度；Indy使用CL群签名算法对Credential进行选择性披露，实现零知识证明。</p><h4 id="bls-multi-sign16">5.1 <a href="https://eprint.iacr.org/2018/483" target="_blank" rel="noopener">BLS multi-sign</a></h4><h5 id="准备阶段">1). 准备阶段</h5><p>有两个哈希方程 <span class="math inline">\(H_0: \{ 0, 1 \} ^* \rightarrow \Bbb{G}_2\)</span> ， <span class="math inline">\(H_1: \{ 0, 1 \}^* \rightarrow \Bbb{Z}_q\)</span></p><p>$ H_0$是将元素哈希到 <span class="math inline">\(\Bbb{G}_2\)</span> 群，<span class="math inline">\(H_1\)</span>是将元素哈希到q阶整数群。</p><h5 id="参数生成">2). 参数生成</h5><p><span class="math inline">\(Pg(k): par \leftarrow (q, \Bbb{G}_1,\Bbb{G}_2, \Bbb{G}_t,e,g_1,g_2) \leftarrow G(k)\)</span></p><p>生成一个双线性配对群，其中q是阶数，$ _1, _2$ 是q阶群，<span class="math inline">\(e : \Bbb{G}_t \leftarrow \Bbb{G}_1 × \Bbb{G}_2\)</span> 是一种映射关系，<span class="math inline">\(g_1,g_2\)</span> 分别是 $ _1, _2$ 的生成子。</p><h5 id="密钥生成">3). 密钥生成</h5><p><span class="math inline">\(Kg(par) : sk \xleftarrow{random} \Bbb{Z}_q ; pk \leftarrow g_2^{sk}\)</span></p><p>在整数群众随机抽取得出私钥 <span class="math inline">\(sk\)</span> ，公钥 <span class="math inline">\(pk\)</span> 由私钥计算得出。</p><h5 id="公钥聚合">4). 公钥聚合</h5><p><span class="math inline">\(KAg({pk_1,…,pk_n}) : apk \leftarrow \prod_{i=1}^n{pk_i^{H_1(pk_i, \{ pk_1,…,pk_n \} )}}\)</span></p><p>将所有的用户公钥都聚合起来，最终形成一个聚合公钥 <span class="math inline">\(apk\)</span> 。</p><h5 id="签名">5). 签名</h5><p><span class="math inline">\(Sign(par, \{ pk_1,…,pk_n \} ,sk,m) : s_i \leftarrow H_0(m)^{a_i \cdot sk_i} , where\ a_i \leftarrow H_1(pk_i, \{ pk_1,…,pk_n \} )\)</span></p><p>每个用户 <span class="math inline">\(i\)</span> 对消息 <span class="math inline">\(m\)</span> 用私钥签名，得出签名 <span class="math inline">\(s_i\)</span></p><p><span class="math inline">\(\sigma \leftarrow \prod_{j=1}^n s_j\)</span></p><p>再将签名发给一个节点，节点进行聚合计算，生成聚合签名 <span class="math inline">\(\sigma\)</span></p><h5 id="验证">6). 验证</h5><p><span class="math inline">\(Vf(par,apk,m, \sigma ) : \ e( \sigma , g_2^{-1}) \cdot e(H_0(m),apk) = 1_{ \Bbb{G}_t}\)</span></p><p>将聚合公钥和聚合签名输入，进行两次双线性配对，若上面的式子成立，则说明验证成功；否则失败。</p><h4 id="camenisch-lysyanskaya-sign17">5.2 <a href="https://link.springer.com/chapter/10.1007%2F3-540-36413-7_20" target="_blank" rel="noopener">Camenisch-Lysyanskaya Sign</a></h4><h5 id="准备阶段-1">1). 准备阶段</h5><p>有一个哈希方程 <span class="math inline">\(Hash: \{ 0, 1 \} ^* \rightarrow \Bbb{Z}_q\)</span></p><p><span class="math inline">\(Hash\)</span> 函数是将元素哈希到q阶整数群。</p><h5 id="参数生成-1">2). 参数生成</h5><p><span class="math inline">\(Pg(k): par \leftarrow (q,\Bbb{G}, \Bbb{G}_t,e,g) \leftarrow G(k)\)</span></p><p>生成一个双线性配对群，其中q是阶数，$ $ 是q阶群，<span class="math inline">\(e : \Bbb{G}_t \leftarrow \Bbb{G} × \Bbb{G}\)</span> 是一种映射关系，<span class="math inline">\(g\)</span> 是 <span class="math inline">\(\Bbb{G}\)</span> 的生成子。</p><h5 id="密钥生成-1">3). 密钥生成</h5><p><span class="math inline">\(Kg(par) : sk_1,sk_2 \xleftarrow{random} \Bbb{Z}_q ; pk_1 \leftarrow g^{sk_1}; \ pk_2 \leftarrow g^{sk_2}\)</span></p><p>在整数群众随机抽取得出子私钥 <span class="math inline">\(sk_1,sk_2\)</span> ，子公钥 <span class="math inline">\(pk_1,pk_2\)</span> 由私钥计算得出。</p><p>最终输出私钥： <span class="math inline">\(SK=(sk_1,sk_2)\)</span> ， 公钥： <span class="math inline">\(PK=(par,pk_1,pk_2)\)</span> 。</p><h5 id="签名-1">4). 签名</h5><p>输入 <span class="math inline">\(message\)</span> ，生成消息 <span class="math inline">\(M \leftarrow Hash(message)\)</span> ，在群 $  $ 随机选取随机数 <span class="math inline">\(A \in \Bbb{G}\)</span> , 计算 <span class="math inline">\(B \leftarrow A^{sk_2}, \ C \leftarrow A^{sk_1}B^{sk_1 \cdot M}\)</span> ，最终输出对消息 <span class="math inline">\(M\)</span> 的签名：$ (A,B,C)$ 。</p><h5 id="验证-1">5). 验证</h5><p>输入对消息 <span class="math inline">\(M\)</span> 的签名 $ (A,B,C)$ ，使用公钥 <span class="math inline">\(PK\)</span> 验证，若</p><p><span class="math inline">\(e(A,pk_2)=e(B,g)\)</span> 且 <span class="math inline">\(e(C,g)=e(A,pk_1) \cdot e(B,pk_1)^M\)</span> 则验证成功。</p><h4 id="anonymous-credentials-with-type-3-revocation">5.3 Anonymous credentials with type-3 revocation</h4><p>这是Indy项目中Credential（凭证）的整体方案，包括<strong>凭证颁发</strong>、<strong>凭证存储</strong>、<strong>凭证选择性披露与验证</strong>、<strong>凭证撤销</strong>。</p><p>在整个Credential的方案中有三种角色：issuer（凭证发行人）、holder（凭证持有人）、verifier（验证者）。这种方案是基于Camenisch-Lysyanskaya Sign方案改进的，可实现选择性披露、“一次性”凭证的功能。</p><p>详情可看这个<a href="https://github.com/hyperledger/indy-crypto/blob/master/libindy-crypto/docs/AnonCred.pdf" target="_blank" rel="noopener">PDF文档</a> （建议由密码学功底的人看）</p><h4 id="shamir-secret-sharing-scheme">5.4 Shamir Secret Sharing Scheme</h4><p>TODO</p><h2 id="四hyperledger-aries">四、Hyperledger Aries</h2><p><a href="https://github.com/hyperledger/aries" target="_blank" rel="noopener"><strong>Hyperledger Aries</strong></a> 是今年5月Hyperledger宣布开源的项目，目前该项目还处于初始阶段，Aires 的产品包括:</p><ul><li>用于创建和签名区块链事务的区块链接口层（称为解析器）</li><li>安全存储（安全存储技术）用于构建区块链客户机加密信息和其他信息的加密钱包</li><li>一种加密的消息传递系统，用于使用多种传输协议在客户端之间进行账外交互</li><li>使用 Ursa 中的 ZKP 原语实现支持 ZKP 的 W3C 可验证凭证</li><li>一种去中心化密钥管理系统（DKMS）规范</li><li>一种基于安全消息传递功能构建的高级协议和类API用例的机制</li></ul><p>我个人认为这是Hyperledger Indy项目的一种扩展延伸，实现功能点几乎一样；</p><p><strong>但是</strong>，Indy是专注于为身份认证而建立的特定区块链，Aries是不适用区块链的项目，项目组期望能在Aries成熟之后融入Indy项目。Hyperledger之后会将Indy项目中与区块链无关的功能迁移到Aries项目，Induy专注于区块链功能。</p><h2 id="五落地案例">五、落地案例</h2><p>主要落地应用是在加拿大British Columbia省的 <a href="https://vonx.io/" target="_blank" rel="noopener">Verfiable Organizations Network(VON)</a>，该项目已开源(<a href="https://github.com/bcgov/von" target="_blank" rel="noopener">链接</a>)，目的在于帮助商人建立可信的持续的电子身份验证，从而加速申请政府机构的许可证和执照。</p><p>该项目已经在2019年1月推出上线，减少了新供应商或客户进行尽职调查的时间。下一步目标是扩展应用程序，鼓励更多的司法管辖区域使用。</p><h2 id="六推广模式">六、推广模式</h2><p>目前Indy的推广模式相关文章/报道较少(可能也是我菜，找不到/不会找 _(:3」∠)_ )</p><ul><li>以投资者的角度分析了Sovrin项目 (<a href="https://news.huoxing24.com/20181112141034187154.html" target="_blank" rel="noopener">链接</a>)</li><li>采访Sovrin主创报道文章，主要讲述了Sovrin是什么，要解决什么问题，怎么解决的，展望未来(<a href="https://sovrin.org/use-case-spotlight-the-government-of-british-columbia-uses-the-sovrin-network-to-take-strides-towards-a-fully-digital-economy/" target="_blank" rel="noopener">链接</a>)</li></ul><h2 id="七qa">七、Q&amp;A</h2><p>Q：Hyperledger Indy是否支持智能合约？</p><p>A：Indy专注于数字身份管理，Indy不是为了支持任何资产交换而开发的，而是为了解决与我们当前数字环境的问题。该项目旨在取代我们用来通过分散机制验证用户数字身份的主流机制，例如用户名 - 密码组合，这种机制更安全可靠。由于其独特的使用案例，<strong>Indy无法支持任何智能合约。</strong></p><p>Q：Authentication是如何进行的？授权的粒度？</p><p>Indy对DID、Credential以及节点的授权都有不同，详情可见<a href="https://hyperledger-indy.readthedocs.io/projects/node/en/latest/auth_rules.html" target="_blank" rel="noopener">链接</a>。</p><p>Q：是否支持多个区块链平台？</p><p>A：目前Indy项目的底层是Plenum BFT，共识并没有模块化，底层耦合度较高，所以<strong>不支持</strong>。</p><p>Q：用户和机构如何介入？</p><p>A：详情可见<a href="https://hyperledger-indy.readthedocs.io/projects/node/en/latest/add-node.html" target="_blank" rel="noopener">链接1</a>、<a href="https://hyperledger-indy.readthedocs.io/projects/node/en/latest/start-nodes.html" target="_blank" rel="noopener">链接2</a></p><p>Q：区块节点部署方式？</p><p>A：目前Indy节点支持本地部署(macOS，Ubuntu)，容器部署(docker)以及云端部署，都有一键部署工具可用。</p><h2 id="参考链接文献">参考链接/文献</h2><blockquote><ol type="1"><li><a href="https://mwherman2000.github.io/indy-arm/" target="_blank" rel="noopener">Hyperledger Indy/Sovrin/DID Comprehensive Architecture Reference Model (INDY ARM)</a></li><li><a href="https://github.com/hyperledger/indy-agent" target="_blank" rel="noopener">hyperledger/<strong>indy-agent</strong></a></li><li><a href="https://github.com/hyperledger/indy-sdk" target="_blank" rel="noopener">hyperledger/<strong>indy-sdk</strong></a></li><li><a href="https://github.com/decentralized-identity/universal-resolver" target="_blank" rel="noopener">decentralized-identity/universal-resolver</a></li><li><a href="https://github.com/hyperledger/indy-node" target="_blank" rel="noopener">hyperledger/<strong>indy-node</strong></a></li><li><a href="https://github.com/hyperledger/indy-plenum" target="_blank" rel="noopener">hyperledger/<strong>indy-plenum</strong></a></li><li><a href="https://w3c-ccg.github.io/did-spec/" target="_blank" rel="noopener">Decentralized Identifiers (DIDs) v0.13</a></li><li><a href="https://github.com/hyperledger/indy-crypto" target="_blank" rel="noopener">hyperledger/<strong>indy-crypto</strong></a></li><li><a href="https://github.com/hyperledger/indy-crypto" target="_blank" rel="noopener">hyperledger/<strong>indy-hipe</strong></a></li><li><a href="http://lig-membres.imag.fr/aublin/rbft/report.pdf" target="_blank" rel="noopener">Aublin, P.-L &amp; Mokhtar, Sonia &amp; Quéma, Vivien. (2013). RBFT: Redundant byzantine fault tolerance. Proceedings - International Conference on Distributed Computing Systems. 297-306. 10.1109/ICDCS.2013.53.</a></li><li><a href="https://hyperledger-indy.readthedocs.io/projects/plenum/en/latest/diagrams/index.html" target="_blank" rel="noopener">Plenum Diagrams</a></li><li><a href="https://download.libsodium.org/doc/" target="_blank" rel="noopener">Libsodium document</a></li><li><a href="https://github.com/jsonpickle/jsonpickle" target="_blank" rel="noopener">jsonpickle: Python library for serializing any arbitrary object graph into JSON.</a></li><li><a href="https://blog.ethereum.org/2015/11/15/merkling-in-ethereum/" target="_blank" rel="noopener">Merkling in Ethereum</a></li><li><a href="https://hyperledger-indy.readthedocs.io/projects/node/en/latest/auth_rules.html" target="_blank" rel="noopener">Current implemented rules in auth_map</a></li><li><a href="https://eprint.iacr.org/2018/483" target="_blank" rel="noopener">Dan Boneh, Manu Drijvers, and Gregory Neven. Compact multi-signatures for 62 smaller blockchains. Cryptology ePrint Archive, 2018.</a></li><li><a href="https://link.springer.com/chapter/10.1007%2F3-540-36413-7_20" target="_blank" rel="noopener">Camenisch J., Lysyanskaya A. (2003) A Signature Scheme with Efficient Protocols. In: Cimato S., Persiano G., Galdi C. (eds) Security in Communication Networks. SCN 2002. Lecture Notes in Computer Science, vol 2576. Springer, Berlin, Heidelberg</a></li><li><a href="https://github.com/hyperledger/aries" target="_blank" rel="noopener">Hyperledger Aries is infrastructure for blockchain-rooted, peer-to-peer interactions</a></li><li><a href="https://medium.com/@kctheservant/exploring-hyperledger-indy-through-indy-dev-example-10075d2547ae" target="_blank" rel="noopener">Exploring Hyperledger Indy through indy-dev Example</a></li><li><a href="https://vonx.io/" target="_blank" rel="noopener">Verifiable Organizations Network: Global digital trust for organizations</a></li><li><a href="https://github.com/bcgov/von" target="_blank" rel="noopener">Verifiable Organizations Network</a></li><li><a href="https://cn.hyperledger.org/hyperledger-indy/2019/03/11/reducing-government-red-tape-british-columbia-creates-new-business-identity-model-with-hyperledger-indy" target="_blank" rel="noopener">Reducing Government Red Tape: British Columbia Creates New Business Identity Model with Hyperledger Indy</a></li><li><a href="https://www.quora.com/Does-Hyperledger-Indy-support-any-kind-of-smart-contracts" target="_blank" rel="noopener">Does Hyperledger Indy support any kind of smart contracts?</a></li><li><a href="https://hyperledger-indy.readthedocs.io/projects/node/en/latest/add-node.html" target="_blank" rel="noopener">Add Node to Existing Pool</a></li><li><a href="https://hyperledger-indy.readthedocs.io/projects/node/en/latest/start-nodes.html" target="_blank" rel="noopener">Create a Network and Start Nodes</a></li><li><a href="https://eprint.iacr.org/2008/539.pdf" target="_blank" rel="noopener">Camenisch, J., Kohlweiss, M., Soriente, C.: An Accumulator Based on Bilinear Maps and Efficient Revocation for Anonymous Credentials. In Jarecki, S., Tsudik, G., eds.: Public Key Cryptography. Volume 5443 of Lecture Notes in Computer Science., Springer (2009) 481–500</a></li><li><a href="https://github.com/hyperledger/indy-crypto/blob/master/libindy-crypto/docs/AnonCred.pdf" target="_blank" rel="noopener">Anonymous credentials with type-3 revocation. Dmitry Khovratovich, Michael Lodder. 9 February 2018, version 0.4</a></li><li><a href="https://news.huoxing24.com/20181112141034187154.html" target="_blank" rel="noopener">TokenGazer深度研究：Sovrin，技术落地可期，但推广难度较高</a></li><li><a href="https://sovrin.org/use-case-spotlight-the-government-of-british-columbia-uses-the-sovrin-network-to-take-strides-towards-a-fully-digital-economy/" target="_blank" rel="noopener">Use case spotlight: The Government of British Columbia uses the Sovrin Network to take strides towards a fully digital economy</a></li></ol></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Sovrin White Paper Reading</title>
      <link href="/2019/07/12/Sovrin-White-Paper-Reading/"/>
      <url>/2019/07/12/Sovrin-White-Paper-Reading/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述">问题描述</h2><p>在物质世界，我们使用物理凭证来证明我们的身份（identity）我们可以有驾照来证明我们的驾驶许可、可以有学位证书来证明我们的学历、可以有技能证书来证明我们的能力；但是在互联网上，却没有等同的解决方案来向互联网端的验证者证明自己的能力、资质、拥有权。</p><p>这些问题的本质是因为，在整个互联网中没有凭证以及凭证发行验证的标准。The World Wide Web Consortium(W3C)在2017年4月对凭证进行了标准化。但如何对凭证发行方的电子签名的验证进行标准化，还存在着疑问。现有解决方案是采用PKI证书密钥体系，但是这种方案需要多次证书交互，每次进行验证都需要与证书颁发中心进行交互验证证书，且存在中心作恶的风险。</p><a id="more"></a><h2 id="sovrin给出的解决方案">Sovrin给出的解决方案</h2><p>在区块链上部署<a href="http://www.weboftrust.info/downloads/dpki.pdf" target="_blank" rel="noopener">decentralized PKI(DPKI)</a>体系结构，每个实体可以进行ID标识，生成<a href="https://w3c-ccg.github.io/did-spec/" target="_blank" rel="noopener">Decentralized Identifier(DID)</a>，这样每个实体都以同一标准生成一个身份标识，所有人都可以发行电子签名的凭证，所有人都可以验证这些凭证。</p><figure><img src="./image-20190703144357168.png" alt="image-20190703144357168"><figcaption>image-20190703144357168</figcaption></figure><h2 id="sovrin愿景">Sovrin愿景</h2><p>全球化的分布式身份识别与可验证凭证方案。这种方案可以用在所有类型的区块链，并且广泛使用程度能超过DNS。</p><h2 id="sovrin隐私保护方案">Sovrin隐私保护方案</h2><ol type="1"><li><p><strong>Pseudonymity by default</strong> 成对且唯一的DID和公钥；</p></li><li><p><strong>Private agents by default</strong> 任何隐私数据都不会上链；</p><figure><img src="./image-20190703161333818.png" alt="image-20190703161333818"><figcaption>image-20190703161333818</figcaption></figure></li><li><p><strong>Selective disclosure by default</strong> 使用零知识证明的方法，对有选择地披露声明信息，保证隐私安全。</p><figure><img src="./image-20190703161524192.png" alt="image-20190703161524192"><figcaption>image-20190703161524192</figcaption></figure></li></ol><h2 id="参考文献">参考文献</h2><blockquote><ol type="1"><li><a href="https://sovrin.org/wp-content/uploads/Sovrin-Protocol-and-Token-White-Paper.pdf" target="_blank" rel="noopener">Sovrin-Protocol-and-Token-White-Paper1</a></li><li><a href="http://www.weboftrust.info/downloads/dpki.pdf" target="_blank" rel="noopener">Decentralized Public Key Infrastructure: A White Paper from Rebooting the Web of Trust</a></li><li><a href="https://w3c-ccg.github.io/did-spec/" target="_blank" rel="noopener">W3C: Decentralized Identifiers (DIDs) v0.13</a></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> 区块链项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blockchain </tag>
            
            <tag> Identity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Facebook Libra区块链白皮书研读</title>
      <link href="/2019/06/24/Libra-whitepaper-study/"/>
      <url>/2019/06/24/Libra-whitepaper-study/</url>
      
        <content type="html"><![CDATA[<h2 id="简述">简述</h2><p>Facebook这次发起的新区块链虚拟货币在技术层面上并未看到有大的革新，与现有的虚拟货币区别不大。从现在的白皮书以及技术文档上所指，最大的特点是<strong>币的价值和真实资产储备相挂钩</strong>，相对于比特币，波动性较小，价值更平稳，这更像是一种有政府背书的数字货币。</p><p>Libra使用了新的编程语言来编写智能合约，设计了基于拜占庭容错的共识算法LibraBFT，如何能承受住全球这么打的用户量，如何，这些问题在技术论文上也没有披露太多信息。</p><a id="more"></a><h2 id="应用背景">应用背景</h2><ol type="1"><li>现有区块链缺乏可扩展性，加密货币具有波动性，到目前为止，这些因素导致现有的加密货币在保值和交换媒介方面均表现欠佳，因而阻碍了它们在市场上的广泛使用。</li><li>一些项目还试图破坏现有体系并绕过监管，而不是在合规和监管方面进行创新，以提高反洗钱举措的效力。</li><li>携手金融部门(包括各个行业的监管机构和专家)进行合作和创新，是确保为这一新体系建立可持续、安全和可信的支撑框架的唯一途径。</li></ol><h2 id="应用愿景">应用愿景</h2><ol type="1"><li>Libra 的使命是<strong>建立一套简单的、无国界的货币和为数十亿人服务的金融基础设施</strong>。</li><li>Libra 完全由<strong>真实资产储备提供支持</strong>。对于每个新创建的Libra 加密货币，在 Libra 储备中都有相对应价值的银行存款和短期政府债券，以此建立人们对其<strong>内在价值的信任</strong>，并以此维持<strong>加密货币的价值稳定</strong>。</li><li>Libra协会成员包括分布在不同地理区域的各种企业、非营利组织、多边组织和学术机构。包含PayPal、Visa等支付业巨头，eBay、Uber、Booking等交易平台。</li><li>任何消费者、开发者或公司都可以使用 Libra 网络、在这个网络上构建产品，并通过他们的服务实现增值作用。</li></ol><h2 id="技术特色">技术特色</h2><ol type="1"><li>目标是扩展到数十亿账户，要求具有极高的交易吞吐量和低延迟；</li><li>设计和使用全新的Move编程语言，用于智能合约编程；</li><li>采用拜占庭容错共识机制，设计使用LibraBFT；</li></ol><h2 id="参考链接">参考链接</h2><p>[1]. <a href="https://libra.org/zh-CN/white-paper/" target="_blank" rel="noopener">Libra中文白皮书</a> [2]. <a href="https://developers.libra.org/docs/assets/papers/the-libra-blockchain.pdf" target="_blank" rel="noopener">Libra技术论文</a> [3]. <a href="https://developers.libra.org" target="_blank" rel="noopener">Libra开发文档</a></p>]]></content>
      
      
      <categories>
          
          <category> 区块链项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blockchain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>区块链实验课简易教程</title>
      <link href="/2019/05/29/blockchain-easy-test/"/>
      <url>/2019/05/29/blockchain-easy-test/</url>
      
        <content type="html"><![CDATA[<p>这是一个使用 Python3 + flask 写的简单平台，主要目的是体验区块链的场景。</p><p>项目库：https://github.com/dvf/blockchain</p><h2 id="一实验目标">一、实验目标</h2><ol type="1"><li>熟悉区块数据结构，了解哈希算法；</li><li>简单了解哈希碰撞(挖矿)的流程，并对发起新交易流程有所了解；</li><li>熟悉区块链的不可篡改性、顺序性，以及区块链分叉时的场景。</li></ol><h2 id="二实验基础">二、实验基础</h2><p>本实验涉及到以下必要知识点：</p><ol type="1"><li>掌握Python语言知识点，熟悉Python程序构建方法，了解flask web框架；</li><li>熟练使用 *nix系统，熟悉命令行操作（Windows也可）；</li><li>掌握HTTP协议，熟悉状态返回值的含义；</li><li>会使用普通IDE，会使用Postman等工具测试API。</li></ol><a id="more"></a><h2 id="三实验步骤">三、实验步骤</h2><h3 id="实验环境依赖">1. 实验环境依赖</h3><blockquote><p>Git</p><p>python version &gt;= 3.6</p><p>flask == 0.12.2</p><p>requests == 2.18.4</p></blockquote><p><a href="https://www.python.org/downloads/" target="_blank" rel="noopener">Python下载</a></p><p><a href="https://git-scm.com/downloads" target="_blank" rel="noopener">Git下载</a></p><h3 id="实验环境搭建">2. 实验环境搭建</h3><p>PS：在这里的命令行操作主要面向 *nix 系统。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 在适当的目录下拉取库</span><br><span class="line"><span class="meta">$</span> git clone https://github.com/dvf/blockchain.git</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 检查python版本号 &gt;= 3.6</span><br><span class="line">python --version</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 下载pipenv</span><br><span class="line"><span class="meta">$</span> pip install pipenv</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 在当前代码根目录下</span><br><span class="line"><span class="meta">$</span> pipenv install</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 启动服务器 (默认端口是5000) -p 设定端口号</span><br><span class="line"><span class="meta">$</span> pipenv run python blockchain.py</span><br><span class="line"><span class="meta">#</span> 起多个服务 PS：注意端口冲突</span><br><span class="line"><span class="meta">$</span> pipenv run python blockchain.py -p 5001</span><br></pre></td></tr></table></figure><p>另：可使用Docker标准环境搭建，可供不希望更改python环境的用户使用。</p><p>(<strong>注意</strong> 这是另外一种实验环境搭建方法，上面做完可不做这一步)</p><p>Docker桌面工具下载地址：<a href="https://www.docker.com/products/docker-desktop" target="_blank" rel="noopener">Docker Desktop for Mac and Windows</a></p><p>命令行下载(面向Ubuntu) ：<a href="https://docs.docker.com/install/linux/docker-ce/ubuntu/" target="_blank" rel="noopener">Get Docker CE for Ubuntu</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 在适当的目录下拉取库</span><br><span class="line"><span class="meta">$</span> git clone https://github.com/dvf/blockchain.git</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 确保docker服务已经在运行，构建镜像</span><br><span class="line"><span class="meta">$</span> docker build -t blockchain .</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 起容器，-p 端口映射，外部通过端口80，访问容器内5000端口的服务</span><br><span class="line"><span class="meta">$</span> docker run --rm -p 80:5000 blockchain</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 起多个容器服务 注意端口</span><br><span class="line"><span class="meta">$</span> docker run --rm -p 81:5000 blockchain</span><br></pre></td></tr></table></figure><h3 id="与区块链进行交互">3. 与区块链进行交互</h3><p>实验很简单，使用API工具对服务器发起HTTP请求，也可以使用古老的<code>cURL</code>来替代Postman工具访问API。</p><p><a href="https://www.getpostman.com/downloads/" target="_blank" rel="noopener">Postman Download</a></p><p>API总共5中方法：</p><ol type="1"><li><code>/chain</code>：返回当前区块链表</li><li><code>/mine</code>：进行挖矿，生产一个区块</li><li><code>/transactions/new</code>：产生一笔新交易</li><li><code>/nodes/register</code>：节点注册，将多个节点绑定到一起</li><li><code>/nodes/resolve</code>：区块链同步</li></ol><h4 id="chain-方法测试">1). /chain 方法测试</h4><p>使用Postman 发送GET方法HTTP请求</p><figure><img src="./shotcut1.png" alt="shotcut1"><figcaption>shotcut1</figcaption></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> cURL方式访问</span><br><span class="line"><span class="meta">$</span> curl -X GET "http://localhost:5000/chain"</span><br></pre></td></tr></table></figure><p>可以看到区块链的结构如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"chain"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"index"</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="attr">"previous_hash"</span>: <span class="string">"1"</span>,</span><br><span class="line">      <span class="attr">"proof"</span>: <span class="number">100</span>,</span><br><span class="line">      <span class="attr">"timestamp"</span>: <span class="number">1558874710.4303942</span>,</span><br><span class="line">      <span class="attr">"transactions"</span>: []</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"length"</span>: <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创世块的<code>index</code>为1，<code>transactions</code>内不包含交易。</p><h4 id="mine-方法测试">2). /mine 方法测试</h4><p>使用Postman 发送GET方法HTTP请求</p><figure><img src="./shotcut2.png" alt="image-20190526204644640"><figcaption>image-20190526204644640</figcaption></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> cURL方式访问</span><br><span class="line"><span class="meta">$</span> curl -X GET "http://localhost:5000/mine"</span><br></pre></td></tr></table></figure><p>可以看到服务器将交易池的所有交易打包产生了一个新的区块<code>index2</code>，并计算了前一块的哈希值。</p><p>若交易池内没有交易，系统默认产生<code>sender</code>为0的交易，方便演示 :)</p><p>这时，再调用<code>/chain</code>方法，查看返回的记录，有什么变化？测试<code>previous_has</code>是否就是前一块的哈希。</p><h4 id="transactionsnew方法测试">3). /transactions/new方法测试</h4><p>使用Postman 发送POST方法HTTP请求，这里需要使用JSON格式写入body。</p><figure><img src="./shotcut3.png" alt="image-20190526204808458"><figcaption>image-20190526204808458</figcaption></figure><p>如上图所示，alice向bob发出数量为1的交易。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> cURL方式访问</span><br><span class="line"><span class="meta">$</span> curl -X POST -H "Content-Type: application/json" -d '&#123;</span><br><span class="line"> "sender": "alice",</span><br><span class="line"> "recipient": "bob",</span><br><span class="line"> "amount": 1</span><br><span class="line">&#125;' "http://localhost:5000/transactions/new"</span><br></pre></td></tr></table></figure><p>这笔交易将会发到交易池，等待矿工将它打包到区块里。</p><p>这时，再调用<code>/mine</code>方法，查看返回的记录，有什么变化？</p><h4 id="nodesregister方法测试">4). /nodes/register方法测试</h4><p>在这里，需要两个以上服务端，即两个以上终端进行操作。</p><p><strong>注意</strong>：这里分为两种情况，<strong>使用pipenv配置的环境</strong>，<strong>使用Docker</strong>配置的环境，请按已有的环境登记节点。</p><h5 id="使用pipenv配置的环境">使用pipenv配置的环境</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 在代码根目录内，重新起一个服务，注意端口要设置成不一样</span><br><span class="line"><span class="meta">$</span> pipenv run python blockchain.py -p 5001</span><br></pre></td></tr></table></figure><p>使用Postman 发送POST方法的HTTP请求，这里需要填入JSON格式写入body。</p><p><strong>注意</strong>：这里填入的node是你新起的服务端口，可以有一个，可以有多个</p><figure><img src="./shocut4.png" alt="image-20190526204930747"><figcaption>image-20190526204930747</figcaption></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> cURL方式访问</span><br><span class="line"><span class="meta">$</span> curl -X POST -H "Content-Type: application/json" -d '&#123;</span><br><span class="line">    "nodes": ["http://0.0.0.0:5001"]</span><br><span class="line">&#125;' "http://localhost:5000/nodes/register"</span><br></pre></td></tr></table></figure><p>在 http://0.0.0.0:5001 的服务节点也要用<code>/nodes/register</code>方法把端口<code>5000</code>的服务节点加进去，数据就可以互通。</p><h5 id="使用docker配置的环境">使用Docker配置的环境</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 重起一个新的节点</span><br><span class="line"><span class="meta">$</span> docker run --rm -p 81:5000 blockchain</span><br></pre></td></tr></table></figure><p>在登记节点时，需要知道本机的本地ip(local IP)，在这里假设本地IP是<code>196.128.0.1</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> cURL方式访问</span><br><span class="line"><span class="meta">#</span> 在80端口登记81端口的服务</span><br><span class="line"><span class="meta">$</span> curl -X POST -H "Content-Type: application/json" -d '&#123;</span><br><span class="line">    "nodes": ["http://196.128.0.1:81"]</span><br><span class="line">&#125;' "http://localhost:80/nodes/register"</span><br></pre></td></tr></table></figure><p><strong>同样的</strong>，在81端口也需要登记80端口的服务。</p><h4 id="nodesresolve方法测试">5). /nodes/resolve方法测试</h4><p>在刚才起的新服务节点<code>5001</code>端口(端口号因人而异)，调用<code>/chain</code>方法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> curl -X GET "http://localhost:5001/chain"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>返回</span><br><span class="line">&#123;</span><br><span class="line">  "chain": [</span><br><span class="line">    &#123;</span><br><span class="line">      "index": 1,</span><br><span class="line">      "previous_hash": "1",</span><br><span class="line">      "proof": 100,</span><br><span class="line">      "timestamp": 1558874708.5040278,</span><br><span class="line">      "transactions": []</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  "length": 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，还是空的，只有1个区块。</p><p>这时调用<code>/nodes/resolve</code>方法与登记好节点的区块链进行同步拉取。</p><p>例如，<code>5000</code>端口现在的区块链如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> curl -X GET "http://localhost:5000/chain"</span><br><span class="line">&#123;</span><br><span class="line">  "chain": [</span><br><span class="line">    &#123;</span><br><span class="line">      "index": 1,</span><br><span class="line">      "previous_hash": "1",</span><br><span class="line">      "proof": 100,</span><br><span class="line">      "timestamp": 1558874710.4303942,</span><br><span class="line">      "transactions": []</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      "index": 2,</span><br><span class="line">      "previous_hash": "43417cdaeda03ca51a0959828b681e52a95c0ea77f8544114b1b9f4358dd3bbc",</span><br><span class="line">      "proof": 5363,</span><br><span class="line">      "timestamp": 1558874791.834334,</span><br><span class="line">      "transactions": [</span><br><span class="line">        &#123;</span><br><span class="line">          "amount": 1,</span><br><span class="line">          "recipient": "2adafd5dd2184a989289f38a02d35a9e",</span><br><span class="line">          "sender": "0"</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      "index": 3,</span><br><span class="line">      "previous_hash": "c22e009dd1d09a08b681013b5c0bd8c9f7e798483186562c9ab7f98370c035f2",</span><br><span class="line">      "proof": 31893,</span><br><span class="line">      "timestamp": 1558875113.180196,</span><br><span class="line">      "transactions": [</span><br><span class="line">        &#123;</span><br><span class="line">          "amount": 1,</span><br><span class="line">          "recipient": "bob",</span><br><span class="line">          "sender": "alice"</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          "amount": 1,</span><br><span class="line">          "recipient": "2adafd5dd2184a989289f38a02d35a9e",</span><br><span class="line">          "sender": "0"</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  "length": 3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在调用5001端口的<code>/nodes/resolve</code>方法进行同步：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> curl -X GET "http://0.0.0.0:5001/nodes/resolve"</span><br><span class="line">&#123;</span><br><span class="line">  "message": "Our chain was replaced",</span><br><span class="line">  "new_chain": [</span><br><span class="line">    &#123;</span><br><span class="line">      "index": 1,</span><br><span class="line">      "previous_hash": "1",</span><br><span class="line">      "proof": 100,</span><br><span class="line">      "timestamp": 1558874710.4303942,</span><br><span class="line">      "transactions": []</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      "index": 2,</span><br><span class="line">      "previous_hash": "43417cdaeda03ca51a0959828b681e52a95c0ea77f8544114b1b9f4358dd3bbc",</span><br><span class="line">      "proof": 5363,</span><br><span class="line">      "timestamp": 1558874791.834334,</span><br><span class="line">      "transactions": [</span><br><span class="line">        &#123;</span><br><span class="line">          "amount": 1,</span><br><span class="line">          "recipient": "2adafd5dd2184a989289f38a02d35a9e",</span><br><span class="line">          "sender": "0"</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      "index": 3,</span><br><span class="line">      "previous_hash": "c22e009dd1d09a08b681013b5c0bd8c9f7e798483186562c9ab7f98370c035f2",</span><br><span class="line">      "proof": 31893,</span><br><span class="line">      "timestamp": 1558875113.180196,</span><br><span class="line">      "transactions": [</span><br><span class="line">        &#123;</span><br><span class="line">          "amount": 1,</span><br><span class="line">          "recipient": "bob",</span><br><span class="line">          "sender": "alice"</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          "amount": 1,</span><br><span class="line">          "recipient": "2adafd5dd2184a989289f38a02d35a9e",</span><br><span class="line">          "sender": "0"</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，5001端的区块链已经完全和5000端的同步了。</p><h3 id="处理区块链分叉">4. 处理区块链分叉</h3><p>此时，<code>5000</code>和<code>5001</code>两个节点的区块链都是完全一致的。若在5000端和5001端同时进行一次交易，那么会出现什么结果呢？两个节点的链长是一样的，最后是谁同步谁的？</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 在5000端，alice给bob发10块</span><br><span class="line"><span class="meta">$</span> curl -X POST -H "Content-Type: application/json" -d '&#123;</span><br><span class="line"> "sender": "alice",</span><br><span class="line"> "recipient": "bob",</span><br><span class="line"> "amount": 10</span><br><span class="line">&#125;' "http://localhost:5000/transactions/new"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 在5001端，bob给alice发10块</span><br><span class="line"><span class="meta">$</span> curl -X POST -H "Content-Type: application/json" -d '&#123;</span><br><span class="line"> "sender": "bob",</span><br><span class="line"> "recipient": "alice",</span><br><span class="line"> "amount": 10</span><br><span class="line">&#125;' "http://localhost:5001/transactions/new"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 在两个节点，都生成一个区块</span><br><span class="line"><span class="meta">$</span> curl -X GET "http://0.0.0.0:5000/mine"</span><br><span class="line"><span class="meta">$</span> curl -X GET "http://0.0.0.0:5001/mine"</span><br></pre></td></tr></table></figure><p>此时，在5000端调用<code>/nodes/resolve</code>方法将不会和5001端的同步，反之也是。</p><p>当两个节点之中，有一个节点先于另一个节点出块，那么另一个节点将会遵从先出快节点的区块链。Have a try :)</p><h3 id="修改哈希碰撞难度">5. 修改哈希碰撞难度</h3><p>修改哈希碰撞难度，可有效降低出块的时间。</p><p>在<code>blockchain.py</code>文件 178行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">valid_proof</span><span class="params">(last_proof, proof, last_hash)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Validates the Proof</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :param last_proof: &lt;int&gt; Previous Proof</span></span><br><span class="line"><span class="string">        :param proof: &lt;int&gt; Current Proof</span></span><br><span class="line"><span class="string">        :param last_hash: &lt;str&gt; The hash of the Previous Block</span></span><br><span class="line"><span class="string">        :return: &lt;bool&gt; True if correct, False if not.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        guess = <span class="string">f'<span class="subst">&#123;last_proof&#125;</span><span class="subst">&#123;proof&#125;</span><span class="subst">&#123;last_hash&#125;</span>'</span>.encode()</span><br><span class="line">        guess_hash = hashlib.sha256(guess).hexdigest()</span><br><span class="line">        <span class="comment"># 在这里修改，0的个数要与数字一致</span></span><br><span class="line">        <span class="comment"># 数字越大，0越多，哈希碰撞难度越大</span></span><br><span class="line">        <span class="keyword">return</span> guess_hash[:<span class="number">4</span>] == <span class="string">"0000"</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blockchain </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo+GoDaddy+GitHub Pages 构建一个属于自己的博客平台</title>
      <link href="/2019/05/20/how-i-build-this-website/"/>
      <url>/2019/05/20/how-i-build-this-website/</url>
      
        <content type="html"><![CDATA[<h2 id="关于博客">关于博客</h2><p>学习技术总是无底洞，越往深处挖掘，越有挑战也越有乐趣。之前就很想要有个属于自己域名，自己的博客，可以在自己的博客里分享自己学到的、感受的，这也是在这世上孤独的自己的一种乐趣。如今将想法做成现实，希望能多多commit :)</p><a id="more"></a><h2 id="github-pages">GitHub Pages</h2><p>首先当然是要在Github创建一个repository, 用于存放自己的blog文件.</p><p>申请好之后在仓库<code>Settings</code>处往下拉, 到<code>GitHub Pages栏中</code> <img src="./snapshot6.png" alt="snapshot6"></p><figure><img src="./snapshot7.png" alt="snapshot7"><figcaption>snapshot7</figcaption></figure><p>选择<code>master branch</code>刷新后, 就会在<code>username.github.io</code>自动生成一个网站, GitHub Pages就已经生成了, 之后我们在GoDaddy里申请好了域名, 再把新域名填入<code>Custom domain</code>就好了.</p><h2 id="godaddy域名申请">GoDaddy域名申请</h2><p>在网上的一些<a href="https://www.godaddy.com/" target="_blank" rel="noopener">GoDaddy</a>申请配置教程稍微有点过时了, 所以在这也说说如何配置.</p><h3 id="选择godaddy的原因">选择GoDaddy的原因</h3><p>其实狗爹这里的域名价格并不是最实惠的, 国内的万网之类的也是可以, 但是使用国内域名可能存在备案之类的,感觉麻烦的, 于是.. (申请的时候搜索一下GoDaddy优惠券会有不小的优惠)</p><h3 id="申请">申请</h3><figure><img src="./snapshot1.png" alt="snapshot1"><figcaption>snapshot1</figcaption></figure><p>查询自己喜欢的域名是否已经被占用, 选好之后添加到购物车. 进入购物车前会推荐你使用它们的隐私服务, <strong>No Thanks</strong> 就好了.</p><p>可使用支付宝, 但不知为啥我这一直用不了支付宝支付, 自动被拒绝了, 所以使用了银联. 第一年只需要14块钱, 也算是很优惠了:) 一般来说 <em>.com </em>.live之类的域名还算便宜, *.cn的比较贵. <img src="./snapshot2.png" alt="snapshot2"></p><h3 id="dns更换">DNS更换</h3><p>狗爹这里的DNS不太稳定, 所以建议使用<a href="https://www.dnspod.cn" target="_blank" rel="noopener">DNSPod</a>进行域名解析.</p><p>首先在刚刚购买的域名这进行DNS更换 <img src="./snapshot3.png" alt="snapshot3"> 选择自定义的dns服务器, 填入以下地址:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f1g1ns1.dnspod.net</span><br><span class="line">f1g1ns2.dnspod.net</span><br></pre></td></tr></table></figure><p>在DNSPod注册完成后, 在控制台域名解析中添加域名 <img src="./snapshot4.png" alt="snapshot4"></p><p>添加主机记录, 用于解析. 其中ip地址是你申请的GitHub Pages的ip地址, 如果不知道ip的话就ping一下就行了. <img src="./snapshot5.png" alt="snapshot5"></p><p>完成了之后, 需要一些时间来让DNS迭代, 一般一两个小时以内就行了.</p><h3 id="在github-pages使用自己的域名">在GitHub Pages使用自己的域名</h3><p>在Github中创建的仓库设置中<code>Custom domain</code>填入新域名就好了, <strong>建议强制使用HTTPS</strong>. 有可能存在一时半会无法解析新域名的情况, 这是DNS还没迭代好, 等一会就好了.</p><h2 id="hexo使用">Hexo使用</h2><p>Hexo是一种简单快捷又强大的博客构建工具，可参照<a href="http://hexo.io/docs/" target="_blank" rel="noopener">Hexo官方文档</a>进行搭建。</p><h3 id="依赖">依赖</h3><ol type="1"><li><a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js</a>，version &gt;= 6.9</li><li>Git</li></ol><h3 id="安装与使用hexo">安装与使用Hexo</h3><p>在全局安装hexo-cli</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>安装成功之后在合适的位置创建Blog文件夹, 用于存放Bolg资源.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir myBlog &amp;&amp; cd myBlog #名字自拟</span><br><span class="line">hexo init # hexo 初始化</span><br></pre></td></tr></table></figure><p>初始化完成, 自动构建了一个简易Hexo包, 结构如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> tree -L 1</span><br><span class="line">.</span><br><span class="line">├── _config.yml  #配置文件</span><br><span class="line">├── node_modules #模块文件夹</span><br><span class="line">├── package-lock.json</span><br><span class="line">├── package.json #所需模块配置信息</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source       #源码, 资源所在包</span><br><span class="line">└── themes       #使用的主题包</span><br></pre></td></tr></table></figure><p>运行以下命令, 根据你的<code>_config.yml</code>配置, 以及<code>source</code>中的资源自动生成静态文件.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br><span class="line"># 以下缩减方式也可</span><br><span class="line">hexo g</span><br></pre></td></tr></table></figure><p>该命令在文件夹下自动生成了<code>public</code>文件夹, 之后是该文件夹deploy到远程网站(Github)中.</p><p>可在本地调试, 查看效果, 默认使用端口4000:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br><span class="line"><span class="meta">#</span> 以下缩减方式也可</span><br><span class="line">hexo s</span><br><span class="line"><span class="meta">#</span> 终端输出</span><br><span class="line">INFO  Start processing</span><br><span class="line">INFO  Hexo is running at http://localhost:4000 . Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure><p>在Blog发布一篇新文章"My First Post":</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new "My First Post"</span><br></pre></td></tr></table></figure><p>随即在 <code>source/_post</code> 文件夹创建一个<code>My-First-Post.md</code>的Markdown文件, 在上面自由创作就猴啦.</p><h3 id="config.yml配置">_config.yml配置</h3><p>在这个yml文件中可以配置大部分Blog应有的设置信息, 看懂英文就行, 这里不多赘述. 但是有几个需要提及的.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim _config.yml</span><br></pre></td></tr></table></figure><p>在最底下的一部分来配置远端Deploy, 在这里建议使用新的分支, 最后再merge到master分支.</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">git</span></span><br><span class="line"><span class="attr">  repository:</span> <span class="attr">https://github.com/username/repo</span></span><br><span class="line"><span class="attr">  branch:</span> <span class="string">hexo-dev</span></span><br></pre></td></tr></table></figure><p>完成之后在本地调试<code>hexo g &amp;&amp; hexo s</code>后, 即可deploy到Github pages了:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy</span><br><span class="line"><span class="meta">#</span> 以下缩减也可以</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>其余配置详情可以看官方文档的配置(<a href="https://hexo.io/docs/configuration" target="_blank" rel="noopener">链接</a>)</p><h3 id="使用theme">使用Theme</h3><p>Hexo默认使用的主题是landscape, 还有许多有趣的主题可以使用.</p><p>本博客使用的主题是<a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">NexT</a>, 如何配置详情就请查看链接内写的吧.</p><p>有其他功能部件使用, 就放以后再更吧 &lt;_&lt;</p><h2 id="参考链接">参考链接</h2><blockquote><ol type="1"><li><a href="http://hexo.io/docs/" target="_blank" rel="noopener">Documentation | Hexo</a></li><li><a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js</a></li><li><a href="https://www.godaddy.com/" target="_blank" rel="noopener">GoDaddy</a></li><li><a href="https://www.dnspod.cn" target="_blank" rel="noopener">DNSPod</a></li><li><a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">NexT</a></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> GitHub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>A lightweight attribute-based encryption scheme for the Internet of Things</title>
      <link href="/2019/05/16/A-lightweight-attribute-based-encryption-scheme-for-the-Internet-of-Things/"/>
      <url>/2019/05/16/A-lightweight-attribute-based-encryption-scheme-for-the-Internet-of-Things/</url>
      
        <content type="html"><![CDATA[<h2 id="论文阅读a-lightweight-attribute-based-encryption-scheme-for-the-internet-of-things">论文阅读：A lightweight attribute-based encryption scheme for the Internet of Things</h2><p>文如其名, 比较lightweight, 才9页(笑. 由北京科技大学的博士与中科院博士联手出品.</p><h3 id="abstract">ABSTRACT</h3><blockquote><p>In this paper, a lightweight no-pairing ABE scheme based on elliptic curve cryptography (ECC) is proposed to address the security and privacy issues in IoT. The security of the proposed scheme is based on the ECDH assumption instead of bilinear Diffie–Hellman assumption, and is proved in the attribute based selective-set model. By uniformly determining the criteria and defining the metrics for measuring the communication overhead and computational overhead, the cMomparison analyses with the existing ABE schemes are made in detail. The results show that the proposed scheme has improved execution efficiency and low communication costs. In addition, the limitations and the improving directions of it are also discussed in detail.</p><p>We propose a no-pairing ECC-Based ABE scheme to deal with the data security and privacy issues in IoT. Since it replaces the expensive bilinear pairing operation with <strong>point scalar multiplication on elliptic curve</strong>, it can meet the lightweight requirement and is suitable for IoT.</p></blockquote><p>本文提出了个适用于IoT的ABE解决方案, 因为双线性配对型的ABE很复杂,代价很高,所以采用基于ECC的方法. 同时, 在安全方面采用基于ECDH假设来取代二线Diffie-Hellman假设.</p><p>用在椭圆曲线上的点标量乘法代替代价高的双线性配对,可以减少计算开销和通信开销,更适用于IoT设备.</p><p>ps:Diffie-Hellman密钥交换(<a href="https://blog.csdn.net/lee244868149/article/details/51790397" target="_blank" rel="noopener">csdn</a>和<a href="https://www.zhihu.com/question/29383090" target="_blank" rel="noopener">知乎</a>)</p><a id="more"></a><h3 id="预备知识">预备知识</h3><h4 id="ecc基础">1.ECC基础</h4><p>ECC首先是个公钥加密的算法,生成一对公私钥,私钥用来加密,公钥进行解密与验证.</p><p>私钥是一个数字(非常大),通常是随机选出来的. 通过椭圆曲线乘法生成一个公钥. 比特币是在公钥的基础上继续进行哈希函数生成比特币地址.</p><h5 id="私钥">私钥</h5><p>为了生成私钥,需要挑选一个足够安全的熵源以保证随机性.从编程的角度来看,一般是通过在一个密码学安全的随机源中 去除一长串随机字节,对其进行SHA256哈希算法进行运算,就可以产生一个256位二进制数,一般是以16进制表示.</p><p>有如下随机生成的秘药,以十六进制格式表示:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD</span><br></pre></td></tr></table></figure><p>比特币私钥空间大小是2<sup>256,用十进制表示的话,大约是10</sup>77. 目前可见宇宙被估计只含有10^80个原子.</p><h5 id="公钥">公钥</h5><p>公钥K是通过使用私钥k进行椭圆曲线乘法运算得到公钥,这个过程不可逆: K=k*G,其中G是生成点的常数点. 逆向求私钥及其困难,只能暴力破解.</p><h5 id="椭圆曲线密码学解释">椭圆曲线密码学解释</h5><p>比特币使用的是secp256k1标准的特殊椭圆曲线. 由下述函数定义:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y^2=(x^3 + 7) over (Fp)  or  y^2 mod p=(x^3 + 7) mod p</span><br></pre></td></tr></table></figure><p>上述mod p(素数p取模)表明该曲线实在素数阶p的有限域内, 也写作Fp, 其中: &gt;p = 2^256 – 2^32 – 2^9 – 2^8 – 2^7 – 2^6 – 2^4 – 1, 这是⼀个⾮常⼤的素数.</p><p>上面的素数阶和有限域让我看得头疼,是啥? 带着问题,来到这个<a href="https://blog.csdn.net/qmickecs/article/details/77281602" target="_blank" rel="noopener">博客</a>认真补习了一下离散数学的知识. 这个<a href="https://zhuanlan.zhihu.com/p/33751859" target="_blank" rel="noopener">博客</a>学习ECC的原理.</p><p><strong>椭圆曲线普通方程</strong> :</p><blockquote><p><span class="math inline">\(\large y^2+a_1xy+a_3y=x^3+a_2x^2+a_4x+a_6\)</span> <br> 无穷远点(0,Y,0)</p></blockquote><p>平常点(x,y)斜率k: &gt;<span class="math inline">\(\Large k=-\frac{F_x(x,y)}{F_y(x,y)}=\frac{3x^2+2a_2x+a_4-a_1y}{2y+a_1x+a_3}\)</span></p><p><strong>椭圆曲线Abel群</strong> :</p><p>在椭圆曲线定义了交换群(Abel群) &gt;任意取椭圆曲线上两点P、Q（若P、Q两点重合，则作P点的切线），作直线交于椭圆曲线的另一点R'，过R'做y轴的平行线交于R，定义P+Q=R。这样，加法的和也在椭圆曲线上，并同样具备加法的交换律、结合律.</p><p><img src="https://img-blog.csdn.net/2018040420440653?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0t5b25fUmF5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p><p><strong>有限域椭圆曲线</strong> :</p><p>因为椭圆曲线是连续的,需要将曲线上的点变成离散的点.把椭圆曲线定义在有限域上. 所以椭圆曲线是模p的有限域,记作GF(p)或Fp.</p><p>可表示为(P,+,*),其中p是一个质数,P集合表示{0,1,..,p-1}.其中加运算和乘运算都是模运算. 详情可以看这个<a href="https://www.jianshu.com/p/a754ad2dfe14" target="_blank" rel="noopener">博客</a>,在这不展开.</p><p>椭圆曲线在有限域就表示为 <strong>Ep(a,b)</strong> ,p是质数, x,y∈[0,p-1] &gt;<span class="math inline">\(\large y^2=x^3+ax+b\pmod p\)</span></p><p>选择两个满足下列条件的小于p的非负整数a,b &gt;<span class="math inline">\(\large 4a^3+27b^2\ne0\pmod p\)</span></p><p>Fp上的椭圆曲线同样有加法</p><ul><li>无穷远点O∞是零元, 有O∞+ O∞= O∞，O∞+P=P</li><li>P(x,y)的逆元是 (x,-y mod p)= (x,p-y) ，有P+(-P)= O∞</li><li>P(x1,y1),Q(x2,y2)的和R(x3,y3) 有如下关系：<ol type="1"><li><span class="math inline">\(x_3\equiv k^2-x_1-x_2\pmod p\)</span></li><li><span class="math inline">\(y_3\equiv k(x_1-x_3)-y_1\pmod p\)</span></li><li>若P=Q, 则 <span class="math inline">\(k=(3x_2+a)/2y_1\pmod p\)</span></li><li>若P≠Q, 则 <span class="math inline">\(k=(y_2-y_1)/(x_2-y_1)\pmod p\)</span></li></ol></li></ul><p><strong>举例</strong> :椭圆曲线已知E_23(1,1)上两点P(3,10)，Q(9,7)，求(1)-P，(2)P+Q，(3) 2P</p><figure><img src="https://www.zhihu.com/equation?tex=%5Cbegin%7Barray%7D%7Bl%7D+%5Cleft%28+1+%5Cright%29+-+P+%3D+%5Cleft%28+%7B3%2C+-+10%5Cbmod+23%7D+%5Cright%29+%3D+%5Cleft%28+%7B3%2C13%7D+%5Cright%29+%5C%5C+%5C%5C+%5Cleft%28+2+%5Cright%29k+%3D+%5Cfrac%7B%7B7+-+10%7D%7D%7B%7B9+-+3%7D%7D+%3D+-+%7B2%5E%7B+-+1%7D%7D%5Cbmod+23+%5C%5C+2+%5Ccdot+%7B2%5E%7B+-+1%7D%7D+%3D+1%5Cbmod+23+%5CRightarrow+%7B2%5E%7B+-+1%7D%7D+%3D+12+%5C%5C+k+%3D+-+12%5Cbmod+23+%3D+11+%5C%5C+P+%2B+Q+%3D+%5Cleft%28+%7B%7B%7B11%7D%5E2%7D+-+3+-+9%5Cbmod+23%2C11+%5Ctimes+%5Cleft%28+%7B3+-+%5Cleft%28+%7B+-+6%7D+%5Cright%29%7D+%5Cright%29%5Cbmod+23%7D+%5Cright%29+%3D+%5Cleft%28+%7B17%2C20%7D+%5Cright%29+%5C%5C+%5C%5C+%5Cleft%28+3+%5Cright%29k+%3D+%5Cfrac%7B%7B3+%5Ctimes+%7B3%5E2%7D+%2B+1%7D%7D%7B%7B2+%5Ctimes+10%7D%7D%5Cbmod+23+%3D+7+%5Ccdot+%7B5%5E%7B+-+1%7D%7D%5Cbmod+23+%5C%5C+5+%5Ccdot+%7B5%5E%7B+-+1%7D%7D+%3D+1%5Cbmod+23+%5CRightarrow+%7B5%5E%7B+-+1%7D%7D+%3D+14+%5C%5C+k+%3D+7+%5Ccdot+14%5Cbmod+23+%3D+6+%5C%5C+2P+%3D+%5Cleft%28+%7B%7B6%5E2%7D+-+3+-+3%5Cbmod+23%2C6+%5Ctimes+%5Cleft%28+%7B3+-+7%7D+%5Cright%29%5Cbmod+23%7D+%5Cright%29+%3D+%5Cleft%28+%7B7%2C12%7D+%5Cright%29+%5C%5C+%5Cend%7Barray%7D+" alt="公式"><figcaption>公式</figcaption></figure><p><strong>椭圆曲线加密</strong> : &gt;考虑K=kG ，其中K、G为椭圆曲线Ep(a,b)上的点，n为G的阶（nG=O∞），k为小于n的整数。则给定k和G，根据加法法则，计算K很容易但反过来，给定K和G，求k就非常困难。因为实际使用中的ECC原则上把p取得相当大，n也相当大，要把n个解点逐一算出来列成上表是不可能的。这就是椭圆曲线加密算法的数学依据. &gt; &gt;点G称为基点（base point） &gt; &gt;k（kn）为私有密钥（privte key） &gt; &gt;K为公开密钥（public key)</p><p><strong>ECC保密通信算法</strong> :</p><ol type="1"><li>Alice选定一条椭圆曲线E，并取椭圆曲线上一点作为基点G 假设选定E29(4,20)，基点G(13,23) , 基点G的阶数n=37</li><li>Alice选择一个私有密钥k，并生成公开密钥K=kG 比如25, K= kG = 25G = (14,6）</li><li>Alice将E和点K、G传给Bob</li><li>Bob收到信息后，将待传输的明文编码到上的一点M（编码方法略），并产生一个随机整数r（r小于n,n为G的阶数） 假设r=6 要加密的信息为3,因为M也要在E29(4,20) 所以M=(3,28)</li><li>Bob计算点C1=M+rK和C2=rG C1= M+6K= M+6<em>25</em>G=M+2G=(3,28)+(27,27)=(6,12) C2=6G=(5,7)</li><li>Bob将C1、C2传给Alice</li><li>Alice收到信息后，计算C1-kC2，结果就应该是点M C1-kC2 =(6,12)-25C2 =(6,12)-25*6G =(6,12)-2G =(6,12)-(27,27) =(6,12)+(27,2) =(3,28)</li></ol><p>数学原来上能解密是因为:C1-kC2=M+rK-krG=M+rkG-krG=M</p><p>论文对ECC进行了剖析. &gt;ECC can provide security based on the known public key cryp-tography primitives, which are Elliptic Curve Digital Signature Al-gorithm (ECDSA), key exchange/agreement (ECDH, Elliptic Curve Diffie–Hellman) and Elliptic Curve Integrated Encryption Standard (ECIES). Compared with other public key cryptography schemes, ECC has 3 distinguished features, which make it very fit for resources-constrained environments [22]. &gt; - It only requires significantly smaller key size than RSA and the modular exponent based public key schemes on the same level of security. &gt; - Its point scalar multiplication operation is much faster than modular exponent operation and bilinear mapping operation. &gt; - It is easy to be implemented in hardware. &gt; &gt; In this paper, we take these advantages of ECC and the features of ABE to construct an ABE scheme for IoT, where Elliptic Curve Decisional Diffie–Hellman Problem (ECDDHP) serves as the complexity assumption, and the Elliptic Curve Integrated Encryption Standard (ECIES) is adopted to encrypt the data.</p><p>ECC提供的安全性基于ECDSA,ECDH,ECIES.与其他的公钥加密算法,ECC有如下几个非常适用于资源节约型的环境的特性.</p><ol type="1"><li>相对于RSA,可以用较小量级的密钥大小提供与RSA相同等级的安全性.</li><li>标量乘法运算比模指数运算和双线性映射快得多.</li><li>在硬件上更容易实现.</li></ol><p>本文基于这些ECC的功能,来构建在IoT上的ABE方案. <strong>ECDDH</strong> 来作复杂度假设, <strong>ECIES</strong> 对数据加密.</p><h3 id="ecddh">ECDDH</h3><p><em>ECDH</em> 是一种在椭圆曲线上的Diffie-Hellman的密钥交换协议. 可以帮助具有椭圆曲线公私钥对的双方通过不安全的通道生成 <strong>共享密钥</strong>. 这个共享密钥可以直接当成密钥或者派生出新的密钥来加密接下来通讯内容. &gt;例如, Alice与Bob使用同一套ECC系统(q,a,b,G,p) &gt; &gt; Alice的密钥对是<code>(S_A , P_A=S_A*G)</code>. Bob的密钥对<code>(S_B , P_B=S_B*G)</code> &gt; &gt;那么他们的共享密码K_{A,B}就是: <code>K_{A,B}=S_A* P_B=S_B* P_A=S_A* S_B* G</code></p><p><strong>ECDDH(elliptic curve decisional Diffie–Hellman problem)</strong> 是ECDH的重要变体. &gt;对于具有生成元G的q阶椭圆曲线群G_E, DHH表明, 给定c*G和d*G的条件下,c*d*G是G_E中的随机元素. &gt; (其中,c,d都是在q阶整数上随机取的.) &gt; &gt;也就是说，对于给定的三元组（c·G，d·G，c·d·G）和（c·G，d·G，Z），无法判断Z = c·d·G</p><h3 id="ecies">ECIES</h3><p>ECIES椭圆曲线集成加密方案,包含有密钥交换和公钥加密的部分.</p><p>使用ECDH生成共享密钥,数据的机密性由对称加密算法保证,密钥和数据完整性由MAC密钥的功能保证.</p><p>以下是ECIES的加密与解密步骤: <img src="https://img-blog.csdn.net/20180404205856773?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0t5b25fUmF5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="加解密步骤"></p><h3 id="access-structure">Access structure</h3><p>访问结构用于描述访问策略,可用访问树表示,由如下定义: &gt;(Access Structure [11]). Let <span class="math inline">\(\{A_1, A_2,..., A_n\}\)</span> be a set of attributes. A collection <span class="math inline">\(\mathbb{A}\)</span> = <span class="math inline">\(2^\{A_1,A_2,...,A_n\}\)</span> is monotone, for <span class="math inline">\(\forall B,C\)</span>: if <span class="math inline">\(B\in \mathbb{A}\)</span> and <span class="math inline">\(B\subseteq C\)</span>, then <span class="math inline">\(C ∈ \mathbb{A}\)</span>. An access structure (respectively, monotone) is a collection (respectively, monotone) <span class="math inline">\(\mathbb{A}\)</span> of non-empty subsets of <span class="math inline">\(\{A_1,A_2,..,A_n\}\)</span>, i.e.,<span class="math inline">\(\mathbb{A}⊆\)</span><span class="math inline">\(2^{A_1,A_2,..,A_n}\setminus \emptyset\)</span>. The sets in A are called the authorized attributes sets, and the sets not in A are called the unauthorized attributes sets.</p><p>有那么一组属性组 <span class="math inline">\(\{A_1, A_2,..., A_n\}\)</span>, 设有一二元集合 <span class="math inline">\(\mathbb{A}\)</span> = <span class="math inline">\(2^\{A_1,A_2,...,A_n\}\)</span>, 如果对与任意的B与C,有B属于A,且B是C的子集,得到 C也属于A.那么二元集合A是单调的.</p><p>所以访问结构是属性集合 <span class="math inline">\(\{A_1, A_2,..., A_n\}\)</span> 的非空子集 <span class="math inline">\(\mathbb{A}\)</span> ,集合 <span class="math inline">\(\mathbb{A}\)</span> 称为授权集.</p><p><strong>访问树</strong> 的具体定义与原理 在这篇<a href="https://zhuanlan.zhihu.com/p/21664741" target="_blank" rel="noopener">文章</a>有详细提及, 在这不详细说.</p><h2 id="算法实现细节">算法实现细节</h2><p>该算法是用KP-ABE的结构, 涵括了AA(attribute authority). 由四个算法步骤组成:</p><ol type="1"><li>Setup: 在中心节点生成public key parameters,PK和master key,MK. master key作为私钥在中心节点所用, public key parameters向外公开.</li><li>Encrypt: 由发送者执行,将消息M输入,中心节点的PK加密输入(确定中心节点),设定属性集r,输出密文CM.</li><li>key-Generation:由中心节点执行,将访问结构R和中心节点MK输入,根据R输出解密钥匙D.</li><li>Decrypt: 由接收者执行,输入发送者发送的密文CM,中心节点给的解密钥匙D,中心节点的PK,当R(r)=1时, 可以得出解密后的消息M.</li></ol><h3 id="本文的给出的kp-abe算法">本文的给出的KP-ABE算法</h3><p>本文所给出的轻量级的ABE是基于ECC的,假定ECC的参数是(q,a,b,G,p).</p><p>对于属性集w, 密钥是由基于拉格朗日插值法的secret sharing构建的. 且该方法有一个ECC-based的密钥生成中心. （拉格朗日插值法学习<a href="https://www.zhihu.com/question/58333118/answer/262507694" target="_blank" rel="noopener">链接</a>）</p><ol type="1"><li><p><strong>Setup</strong>:首先是定义中心节点的属性集U,对U中每个属性<span class="math inline">\(i\)</span>, 在ECC的q阶正整数群内随机找一个对应的数字 <span class="math inline">\(s_i\)</span>,每个属性<span class="math inline">\(i\)</span>的公钥就是<span class="math inline">\(P_i=s_i\cdot G\)</span>. 同样地,在q阶正整数群内随机找一个数字<span class="math inline">\(s\)</span>作为中心节点的MK,中心节点的PK就等于 <span class="math inline">\(PK=s \cdot G\)</span>, 所以中心节点的公开参数可以表示为: <span class="math inline">\(Params=\{ PK,P_1,..,P_\left | U \right|\}\)</span></p></li><li><p><strong>Encryption(M,w,Params)</strong>: 与现存的ABE不同的是, 消息M是由ECIES加密的,而不是模指数运算或者双线性配对加密的.</p><ul><li>随机从ECC的q阶正整数群选择k来计算C',<span class="math inline">\(C&#39;=k \cdot PK=(K_x,K_y)\)</span>,若C'为0则重选k.</li><li>分别对Params中<span class="math inline">\(P_i\)</span>计算<span class="math inline">\(C_i\)</span>, <span class="math inline">\(C_i=k \cdot P_i, i \in w\)</span>.</li><li><span class="math inline">\(K_x\)</span>为加密密钥,<span class="math inline">\(K_y\)</span>则是整合的密钥. <span class="math inline">\(C=ENC(M,K_x)\)</span>, <span class="math inline">\(MAC_M=HMAC(M,K_y)\)</span></li><li>密文cipher-text就可以表示为<span class="math inline">\(CM=(w,C,MAC_M,C_i,i\in w)\)</span>.</li></ul></li><li><p><strong>KeyGeneration(<span class="math inline">\(\Gamma,MK\)</span>)</strong>: 当且仅当 <span class="math inline">\(\Gamma (w)=1\)</span>时,通过算法生成解密的密钥.</p><ul><li>对访问控制树 <span class="math inline">\(\Gamma\)</span>上的每个节点u都自上而下进行定义,这些节点的门限都是<span class="math inline">\(d_u\)</span>. 多项式<span class="math inline">\(q_u(x)\)</span>由此定义</li><li>对于访问树 <span class="math inline">\(\Gamma\)</span>的根R,设<span class="math inline">\(q_R(0)=s\)</span> (ps: s就是setup步骤的MK) 并随机选择<span class="math inline">\(d_R-1\)</span>个其他点做多项式<span class="math inline">\(q_R(x)\)</span></li><li>对于其他节点u, <span class="math inline">\(q_u(0)=q_{parent(u)}(index(u))\)</span>,也要随机选择<span class="math inline">\(d_u-1\)</span>个其他点来定义<span class="math inline">\(q_u(x)\)</span></li><li>当访问树的叶子节点都被定义了之后,叶子节点u的secret share解密密钥就可以表示为: <span class="math inline">\(\large D_u=q_u(0)/s_i\)</span>,其中<span class="math inline">\(i\)</span>是一个属性,<span class="math inline">\(s_i\)</span>在setup步骤上就已经定义,<span class="math inline">\(s_i^-1\)</span>是<span class="math inline">\(s_i\)</span>在ECC群中的逆元.根据这样的访问树结构就能逐步还原.</li><li>最终解密密钥可以表示为: <span class="math inline">\(D=(D_u=q_u(0)/s_i, i=attr(u)\ and\ \ i\in w)\)</span>.</li></ul></li><li><p><strong>Decryption(CM,D,Params)</strong>:与其他算法相似,在访问树里的节点的解密算法用递归的方法实现.</p><ul><li><p>对每个叶子节点u, 令 <span class="math inline">\(i=attr(u)\)</span> 有: $ DecryptNode(CM,D,u)=$ \begin{cases} D_u C_i=q_u(0) s_i^-1kP_i\ =q_u(0) s_i^-1ks_iG\ =q_u(0) kG , &amp;(iw)\ , &amp;Otherwise. \end{cases}</p></li><li><p>对非叶子节点,可以对每个子节点v调用<span class="math inline">\(DecryptNode(CM,D,v)\)</span>.</p></li></ul></li></ol><ul><li><p>令<span class="math inline">\(w_u\)</span>为u的<span class="math inline">\(d_u\)</span>个子节点的集合, 对每一个<span class="math inline">\(w_u\)</span>的元素v进行<span class="math inline">\(DecryptNode(CM,D,v)\)</span>.</p></li><li><p>若存在<span class="math inline">\(w_u\)</span>,那么有: &gt;<embed src="http://latex.codecogs.com/gif.latex?%5Clarge%20DecryptNode%28CM%2CD%2Cu%29%5C%5C%20%3D%5Clarge%5Csum_%7Bv%5Cin%20w_u%7D%5CDelta_%7Bi%2Cw%27_u%7D%280%29%5Ccdot%20DecryptNode%28CM%2CD%2Cv%29%5C%5C%20%5Clarge%5Cmbox%7Bwhere%20%7D%20i%3D%5Cmbox%7Bindex%7D%28v%29%2C%20w%27_u%3D%5C%7B%5Cmbox%7Bindex%7D%28v%29%2Cv%5Cin%20w_u%5C%7D%5C%5C%20%3D%5Clarge%5Csum_%7Bv%5Cin%20w_u%7D%5CDelta_%7Bi%2Cw%27_u%7D%280%29%5Ccdot%20q_v%280%29%5Ccdot%20k%5Ccdot%20G%5C%5C%20%3D%5Clarge%5Csum_%7Bv%5Cin%20w_u%7D%5CDelta_%7Bi%2Cw%27_u%7D%280%29%5Ccdot%20q_%7Bparent%28v%29%7D%28index%28v%29%29%5Ccdot%20k%5Ccdot%20G%5C%5C%20%3D%5Clarge%5Csum_%7Bv%5Cin%20w_u%7D%5CDelta_%7Bi%2Cw%27_u%7D%280%29%5Ccdot%20q_u%28i%29%5Ccdot%20k%5Ccdot%20G%5C%5C%20%3D%5Clarge%20q_u%280%29%5Ccdot%20k%5Ccdot%20G."></p></li><li><p>对根节点有: <span class="math inline">\(DecryptNode(CM, D, R) = q_R(0)·k·G = s·k·G = (K′_x, K′_y)\)</span>. 其中<span class="math inline">\(K&#39;_x\)</span>就是消息M的解密密钥,<span class="math inline">\(K&#39;_y\)</span>是消息M的集合密钥.<span class="math inline">\(M&#39;=DEC(C,K&#39;_X)\)</span>.</p></li><li><p>如果<span class="math inline">\(HMAC(M&#39;,K&#39;_y)=MAC_M\)</span>,那么就表示消息M已经被正确解密. 所以说所有的正确性,完整性都由<span class="math inline">\(MAC_M\)</span>验证.</p></li></ul><hr><h2 id="算法表现与分析">算法表现与分析</h2><p>本文为了评估所提出的ABE方案的轻量级的特点,在 <em>通信开销</em> 和 KP-ABE和CP-ABE的 <em>加算开销</em> 上分析. 并给出该算法的限制.</p><h3 id="通信开销指标">通信开销指标</h3><p>通信开销取决于所传输的消息的长度. 传输的消息包括了 <strong>密文cipher-text</strong> ,<strong>公钥</strong> 和 <strong>私钥</strong>.</p><p>现有大多数ABE方案都是基于双线性配对的RSA-based方案. 有两个群<span class="math inline">\(G_1,G_2\)</span>, <span class="math inline">\(G_1\)</span>是一个大素数阶的双线性群, 双线性映射可以表示为 <span class="math inline">\(G_1 \times G_1 \rightarrow G_2\)</span>. 且<span class="math inline">\(G_1,G_2\)</span> 的基本运算都是模指数运算. 在相同安全级别上,RSA的密钥对比ECC的密钥对长得多.RSA的密钥对长度在 <span class="math inline">\(G_1\)</span> 是ECC的3.2倍,<span class="math inline">\(G_2\)</span> 是6.4倍.</p><p>在ABE方案中,密文需要包含属性集, 密文的长度与属性集成线性增长.</p><p>密文 <span class="math inline">\(CM=(w,C,MAC_M,C_i,i\in w)\)</span> ,<span class="math inline">\(C_i\)</span>是椭圆曲线的一点,且长度为<span class="math inline">\(2l\)</span>,由于先前的假设,消息M和MAC的长度都为安全级别<span class="math inline">\(l\)</span>,所以<span class="math inline">\(C\)</span>和<span class="math inline">\(MAC_M\)</span>也是<span class="math inline">\(l\)</span>位长. 所以给出的方案的密文长度是 <span class="math inline">\((l+l+k*2l)=(2k+2)l\)</span>.</p><p>另外,公钥是 <span class="math inline">\(\{PK,P_i,i\in U\}\)</span>,每一个元素都是椭圆曲线上的一点,所以公钥长度为 <span class="math inline">\((2l+n*2l)=(2n+2)l\)</span>. 私钥是 <span class="math inline">\(\{D_u=q_u(0)/s_i,\ i=attr(u)\mbox{ and }i\in w\}\)</span>, 长度是<span class="math inline">\(k\cdot l\)</span>.</p><h3 id="计算开销指标">计算开销指标</h3><p>本文对比了现有的CP-ABE和KP-ABE. 计算开销一般是由双线性映射(公钥的加密解密操作)的成本衡量的.本方案中没涉及,所以不计算.本文的加密算法包括了(1+k)点标量乘法,且解密的递归过程不超过(2k-1)点标量乘法,所以总的最多有3k个点标量乘法.</p><p>与其他的方案的比较如下图:</p><p><img src="https://img-blog.csdn.net/2018040419231284?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0t5b25fUmF5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p><p>可以看出在 <strong>公私钥长度</strong> 都远比其他方案要短, <strong>密文长度</strong> 在属性大于10个时大于常数级的方案. <strong>计算开销</strong> 也明显小于一般方案. 所以说在 <strong>轻量级</strong> 的属性加密方案上,该文的方案是很优秀的.</p><h3 id="提出的abe方案的限制">提出的ABE方案的限制</h3><ol type="1"><li><p>撤销属性灵活性较差: 使用的是单调访问结构和秘密共享机制,都是在"AND"和"OR"门上进行的,不支持"NOT"门, 难以表达复杂的访问策略,属性撤销也很麻烦.通常操作都是重新加密来实现属性撤销. 本文并没有讨论属性撤销属性.</p></li><li><p>可扩展性差: 通信开销和计算开销都与加密属性数量成线性关系.</p></li><li><p>通用性较差: 本方案是单一权限上的应用,不适用于多权限结构.</p></li></ol><h2 id="参考文章">参考文章</h2><blockquote><ol type="1"><li>Yao X, Tian Y, Tian Y. A lightweight attribute-based encryption scheme for the Internet of Things[J]. Future Generation Computer Systems, 2015, 49(C):104-112.</li><li><a href="http://pangjiuzala.github.io/2016/03/03/Bitcoin%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E5%AF%86%E7%A0%81%E5%AD%A6/" target="_blank" rel="noopener">Bitcoin加密技术之椭圆曲线密码学</a></li><li><a href="https://blog.csdn.net/qmickecs/article/details/77281602" target="_blank" rel="noopener">谈谈有限域那些事儿</a></li><li><a href="https://blog.csdn.net/qmickecs/article/details/76585303" target="_blank" rel="noopener">离散对数和椭圆曲线加密原理</a></li><li><a href="https://zhuanlan.zhihu.com/p/33751859" target="_blank" rel="noopener">ECC入门+实例 (身份证比特币加密算法)</a></li><li><a href="https://zhuanlan.zhihu.com/p/21664741" target="_blank" rel="noopener">数学、英语对程序员来说重要吗？记线性秘密分享方案（Linear Secret Sharing Scheme，LSSS）的实现</a></li><li><span class="citation" data-cites="马同学的回答">[如何直观地理解拉格朗日插值法？ @马同学的回答]</span><a href="https://www.zhihu.com/question/58333118/answer/262507694" target="_blank" rel="noopener">6</a></li><li><a href="https://www.jianshu.com/p/a754ad2dfe14" target="_blank" rel="noopener">密码学中的离散数学知识学习</a></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> 论文研究 </category>
          
          <category> 密码学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ECC </tag>
            
            <tag> 属性加密 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
