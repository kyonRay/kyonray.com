<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[区块链实验课简易教程]]></title>
    <url>%2F2019%2F05%2F29%2Fblockchain-easy-test%2F</url>
    <content type="text"><![CDATA[这是一个使用 Python3 + flask 写的简单平台，主要目的是体验区块链的场景。 项目库：https://github.com/dvf/blockchain 一、实验目标 熟悉区块数据结构，了解哈希算法； 简单了解哈希碰撞(挖矿)的流程，并对发起新交易流程有所了解； 熟悉区块链的不可篡改性、顺序性，以及区块链分叉时的场景。 二、实验基础本实验涉及到以下必要知识点： 掌握Python语言知识点，熟悉Python程序构建方法，了解flask web框架； 熟练使用 *nix系统，熟悉命令行操作（Windows也可）； 掌握HTTP协议，熟悉状态返回值的含义； 会使用普通IDE，会使用Postman等工具测试API。 三、实验步骤1. 实验环境依赖 Git python version &gt;= 3.6 flask == 0.12.2 requests == 2.18.4 Python下载 Git下载 2. 实验环境搭建PS：在这里的命令行操作主要面向 *nix 系统。 12345678910111213141516# 在适当的目录下拉取库$ git clone https://github.com/dvf/blockchain.git# 检查python版本号 &gt;= 3.6python --version# 下载pipenv$ pip install pipenv# 在当前代码根目录下$ pipenv install# 启动服务器 (默认端口是5000) -p 设定端口号$ pipenv run python blockchain.py# 起多个服务 PS：注意端口冲突$ pipenv run python blockchain.py -p 5001 另：可使用Docker标准环境搭建，可供不希望更改python环境的用户使用。 (注意 这是另外一种实验环境搭建方法，上面做完可不做这一步) Docker桌面工具下载地址：Docker Desktop for Mac and Windows 命令行下载(面向Ubuntu) ：Get Docker CE for Ubuntu 1234567891011# 在适当的目录下拉取库$ git clone https://github.com/dvf/blockchain.git# 确保docker服务已经在运行，构建镜像$ docker build -t blockchain .# 起容器，-p 端口映射，外部通过端口80，访问容器内5000端口的服务$ docker run --rm -p 80:5000 blockchain# 起多个容器服务 注意端口$ docker run --rm -p 81:5000 blockchain 3. 与区块链进行交互实验很简单，使用API工具对服务器发起HTTP请求，也可以使用古老的cURL来替代Postman工具访问API。 Postman Download API总共5中方法： /chain：返回当前区块链表 /mine：进行挖矿，生产一个区块 /transactions/new：产生一笔新交易 /nodes/register：节点注册，将多个节点绑定到一起 /nodes/resolve：区块链同步 1). /chain 方法测试使用Postman 发送GET方法HTTP请求 12# cURL方式访问$ curl -X GET "http://localhost:5000/chain" 可以看到区块链的结构如下： 123456789101112&#123; "chain": [ &#123; "index": 1, "previous_hash": "1", "proof": 100, "timestamp": 1558874710.4303942, "transactions": [] &#125; ], "length": 1&#125; 创世块的index为1，transactions内不包含交易。 2). /mine 方法测试使用Postman 发送GET方法HTTP请求 12# cURL方式访问$ curl -X GET "http://localhost:5000/mine" 可以看到服务器将交易池的所有交易打包产生了一个新的区块index2，并计算了前一块的哈希值。 若交易池内没有交易，系统默认产生sender为0的交易，方便演示 :) 这时，再调用/chain方法，查看返回的记录，有什么变化？测试previous_has是否就是前一块的哈希。 3). /transactions/new方法测试使用Postman 发送POST方法HTTP请求，这里需要使用JSON格式写入body。 如上图所示，alice向bob发出数量为1的交易。 123456# cURL方式访问$ curl -X POST -H "Content-Type: application/json" -d '&#123; "sender": "alice", "recipient": "bob", "amount": 1&#125;' "http://localhost:5000/transactions/new" 这笔交易将会发到交易池，等待矿工将它打包到区块里。 这时，再调用/mine方法，查看返回的记录，有什么变化？ 4). /nodes/register方法测试在这里，需要两个以上服务端，即两个以上终端进行操作。 注意：这里分为两种情况，使用pipenv配置的环境，使用Docker配置的环境，请按已有的环境登记节点。 使用pipenv配置的环境12# 在代码根目录内，重新起一个服务，注意端口要设置成不一样$ pipenv run python blockchain.py -p 5001 使用Postman 发送POST方法的HTTP请求，这里需要填入JSON格式写入body。 注意：这里填入的node是你新起的服务端口，可以有一个，可以有多个 1234# cURL方式访问$ curl -X POST -H "Content-Type: application/json" -d '&#123; "nodes": ["http://0.0.0.0:5001"]&#125;' "http://localhost:5000/nodes/register" 在 http://0.0.0.0:5001 的服务节点也要用/nodes/register方法把端口5000的服务节点加进去，数据就可以互通。 使用Docker配置的环境12# 重起一个新的节点$ docker run --rm -p 81:5000 blockchain 在登记节点时，需要知道本机的本地ip(local IP)，在这里假设本地IP是196.128.0.1 12345# cURL方式访问# 在80端口登记81端口的服务$ curl -X POST -H "Content-Type: application/json" -d '&#123; "nodes": ["http://196.128.0.1:81"]&#125;' "http://localhost:80/nodes/register" 同样的，在81端口也需要登记80端口的服务。 5). /nodes/resolve方法测试在刚才起的新服务节点5001端口(端口号因人而异)，调用/chain方法： 123456789101112131415$ curl -X GET "http://localhost:5001/chain"#返回&#123; "chain": [ &#123; "index": 1, "previous_hash": "1", "proof": 100, "timestamp": 1558874708.5040278, "transactions": [] &#125; ], "length": 1&#125; 可以看到，还是空的，只有1个区块。 这时调用/nodes/resolve方法与登记好节点的区块链进行同步拉取。 例如，5000端口现在的区块链如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344$ curl -X GET "http://localhost:5000/chain"&#123; "chain": [ &#123; "index": 1, "previous_hash": "1", "proof": 100, "timestamp": 1558874710.4303942, "transactions": [] &#125;, &#123; "index": 2, "previous_hash": "43417cdaeda03ca51a0959828b681e52a95c0ea77f8544114b1b9f4358dd3bbc", "proof": 5363, "timestamp": 1558874791.834334, "transactions": [ &#123; "amount": 1, "recipient": "2adafd5dd2184a989289f38a02d35a9e", "sender": "0" &#125; ] &#125;, &#123; "index": 3, "previous_hash": "c22e009dd1d09a08b681013b5c0bd8c9f7e798483186562c9ab7f98370c035f2", "proof": 31893, "timestamp": 1558875113.180196, "transactions": [ &#123; "amount": 1, "recipient": "bob", "sender": "alice" &#125;, &#123; "amount": 1, "recipient": "2adafd5dd2184a989289f38a02d35a9e", "sender": "0" &#125; ] &#125; ], "length": 3&#125; 现在调用5001端口的/nodes/resolve方法进行同步： 1234567891011121314151617181920212223242526272829303132333435363738394041424344$ curl -X GET "http://0.0.0.0:5001/nodes/resolve"&#123; "message": "Our chain was replaced", "new_chain": [ &#123; "index": 1, "previous_hash": "1", "proof": 100, "timestamp": 1558874710.4303942, "transactions": [] &#125;, &#123; "index": 2, "previous_hash": "43417cdaeda03ca51a0959828b681e52a95c0ea77f8544114b1b9f4358dd3bbc", "proof": 5363, "timestamp": 1558874791.834334, "transactions": [ &#123; "amount": 1, "recipient": "2adafd5dd2184a989289f38a02d35a9e", "sender": "0" &#125; ] &#125;, &#123; "index": 3, "previous_hash": "c22e009dd1d09a08b681013b5c0bd8c9f7e798483186562c9ab7f98370c035f2", "proof": 31893, "timestamp": 1558875113.180196, "transactions": [ &#123; "amount": 1, "recipient": "bob", "sender": "alice" &#125;, &#123; "amount": 1, "recipient": "2adafd5dd2184a989289f38a02d35a9e", "sender": "0" &#125; ] &#125; ]&#125; 可以看到，5001端的区块链已经完全和5000端的同步了。 4. 处理区块链分叉此时，5000和5001两个节点的区块链都是完全一致的。若在5000端和5001端同时进行一次交易，那么会出现什么结果呢？两个节点的链长是一样的，最后是谁同步谁的？ 1234567891011121314151617# 在5000端，alice给bob发10块$ curl -X POST -H "Content-Type: application/json" -d '&#123; "sender": "alice", "recipient": "bob", "amount": 10&#125;' "http://localhost:5000/transactions/new"# 在5001端，bob给alice发10块$ curl -X POST -H "Content-Type: application/json" -d '&#123; "sender": "bob", "recipient": "alice", "amount": 10&#125;' "http://localhost:5001/transactions/new"# 在两个节点，都生成一个区块$ curl -X GET "http://0.0.0.0:5000/mine"$ curl -X GET "http://0.0.0.0:5001/mine" 此时，在5000端调用/nodes/resolve方法将不会和5001端的同步，反之也是。 当两个节点之中，有一个节点先于另一个节点出块，那么另一个节点将会遵从先出快节点的区块链。Have a try :) 5. 修改哈希碰撞难度修改哈希碰撞难度，可有效降低出块的时间。 在blockchain.py文件 178行： 12345678910111213141516def valid_proof(last_proof, proof, last_hash): """ Validates the Proof :param last_proof: &lt;int&gt; Previous Proof :param proof: &lt;int&gt; Current Proof :param last_hash: &lt;str&gt; The hash of the Previous Block :return: &lt;bool&gt; True if correct, False if not. """ guess = f'&#123;last_proof&#125;&#123;proof&#125;&#123;last_hash&#125;'.encode() guess_hash = hashlib.sha256(guess).hexdigest() # 在这里修改，0的个数要与数字一致 # 数字越大，0越多，哈希碰撞难度越大 return guess_hash[:4] == "0000"]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>blockchain</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+GoDaddy+GitHub Pages 构建一个属于自己的博客平台]]></title>
    <url>%2F2019%2F05%2F20%2Fhow-i-build-this-website%2F</url>
    <content type="text"><![CDATA[关于博客学习技术总是无底洞，越往深处挖掘，越有挑战也越有乐趣。之前就很想要有个属于自己域名，自己的博客，可以在自己的博客里分享自己学到的、感受的，这也是在这世上孤独的自己的一种乐趣。如今将想法做成现实，希望能多多commit :) GitHub Pages首先当然是要在Github创建一个repository, 用于存放自己的blog文件. 申请好之后在仓库Settings处往下拉, 到GitHub Pages栏中 选择master branch刷新后, 就会在username.github.io自动生成一个网站, GitHub Pages就已经生成了, 之后我们在GoDaddy里申请好了域名, 再把新域名填入Custom domain就好了. GoDaddy域名申请在网上的一些GoDaddy申请配置教程稍微有点过时了, 所以在这也说说如何配置. 选择GoDaddy的原因其实狗爹这里的域名价格并不是最实惠的, 国内的万网之类的也是可以, 但是使用国内域名可能存在备案之类的,感觉麻烦的, 于是.. (申请的时候搜索一下GoDaddy优惠券会有不小的优惠) 申请 查询自己喜欢的域名是否已经被占用, 选好之后添加到购物车. 进入购物车前会推荐你使用它们的隐私服务, No Thanks 就好了. 可使用支付宝, 但不知为啥我这一直用不了支付宝支付, 自动被拒绝了, 所以使用了银联. 第一年只需要14块钱, 也算是很优惠了:) 一般来说 .com .live之类的域名还算便宜, *.cn的比较贵. DNS更换狗爹这里的DNS不太稳定, 所以建议使用DNSPod进行域名解析. 首先在刚刚购买的域名这进行DNS更换选择自定义的dns服务器, 填入以下地址: 12f1g1ns1.dnspod.netf1g1ns2.dnspod.net 在DNSPod注册完成后, 在控制台域名解析中添加域名 添加主机记录, 用于解析. 其中ip地址是你申请的GitHub Pages的ip地址, 如果不知道ip的话就ping一下就行了. 完成了之后, 需要一些时间来让DNS迭代, 一般一两个小时以内就行了. 在GitHub Pages使用自己的域名在Github中创建的仓库设置中Custom domain填入新域名就好了, 建议强制使用HTTPS. 有可能存在一时半会无法解析新域名的情况, 这是DNS还没迭代好, 等一会就好了. Hexo使用Hexo是一种简单快捷又强大的博客构建工具，可参照Hexo官方文档进行搭建。 依赖 Node.js，version &gt;= 6.9 Git 安装与使用Hexo在全局安装hexo-cli 1npm install -g hexo-cli 安装成功之后在合适的位置创建Blog文件夹, 用于存放Bolg资源. 12mkdir myBlog &amp;&amp; cd myBlog #名字自拟hexo init # hexo 初始化 初始化完成, 自动构建了一个简易Hexo包, 结构如下: 123456789$ tree -L 1.├── _config.yml #配置文件├── node_modules #模块文件夹├── package-lock.json├── package.json #所需模块配置信息├── scaffolds├── source #源码, 资源所在包└── themes #使用的主题包 运行以下命令, 根据你的_config.yml配置, 以及source中的资源自动生成静态文件. 123hexo generate# 以下缩减方式也可hexo g 该命令在文件夹下自动生成了public文件夹, 之后是该文件夹deploy到远程网站(Github)中. 可在本地调试, 查看效果, 默认使用端口4000: 123456hexo server# 以下缩减方式也可hexo s# 终端输出INFO Start processingINFO Hexo is running at http://localhost:4000 . Press Ctrl+C to stop. 在Blog发布一篇新文章”My First Post”: 1hexo new "My First Post" 随即在 source/_post 文件夹创建一个My-First-Post.md的Markdown文件, 在上面自由创作就猴啦. _config.yml配置在这个yml文件中可以配置大部分Blog应有的设置信息, 看懂英文就行, 这里不多赘述. 但是有几个需要提及的. 1vim _config.yml 在最底下的一部分来配置远端Deploy, 在这里建议使用新的分支, 最后再merge到master分支. 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repository: https://github.com/username/repo branch: hexo-dev 完成之后在本地调试hexo g &amp;&amp; hexo s后, 即可deploy到Github pages了: 123hexo deploy# 以下缩减也可以hexo d 其余配置详情可以看官方文档的配置(链接) 使用ThemeHexo默认使用的主题是landscape, 还有许多有趣的主题可以使用. 本博客使用的主题是NexT, 如何配置详情就请查看链接内写的吧. 有其他功能部件使用, 就放以后再更吧 &lt;_&lt; 参考链接 Documentation | Hexo Node.js GoDaddy DNSPod NexT]]></content>
      <categories>
        <category>博客搭建</category>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[A lightweight attribute-based encryption scheme for the Internet of Things]]></title>
    <url>%2F2019%2F05%2F16%2FA-lightweight-attribute-based-encryption-scheme-for-the-Internet-of-Things%2F</url>
    <content type="text"><![CDATA[论文阅读：A lightweight attribute-based encryption scheme for the Internet of Things文如其名, 比较lightweight, 才9页(笑.由北京科技大学的博士与中科院博士联手出品. ABSTRACT In this paper, a lightweight no-pairing ABE scheme based on elliptic curve cryptography (ECC) is proposed to address the security and privacy issues in IoT. The security of the proposed scheme is based on the ECDH assumption instead of bilinear Diffie–Hellman assumption, and is proved in the attribute based selective-set model. By uniformly determining the criteria and defining the metrics for measuring the communication overhead and computational overhead, the cMomparison analyses with the existing ABE schemes are made in detail. The results show that the proposed scheme has improved execution efficiency and low communication costs. In addition, the limitations and the improving directions of it are also discussed in detail. We propose a no-pairing ECC-Based ABE scheme to deal with the data security and privacy issues in IoT. Since it replaces the expensive bilinear pairing operation with point scalar multiplication on elliptic curve, it can meet the lightweight requirement and is suitable for IoT. 本文提出了个适用于IoT的ABE解决方案, 因为双线性配对型的ABE很复杂,代价很高,所以采用基于ECC的方法.同时, 在安全方面采用基于ECDH假设来取代二线Diffie-Hellman假设. 用在椭圆曲线上的点标量乘法代替代价高的双线性配对,可以减少计算开销和通信开销,更适用于IoT设备. ps:Diffie-Hellman密钥交换(csdn和知乎) 预备知识1.ECC基础ECC首先是个公钥加密的算法,生成一对公私钥,私钥用来加密,公钥进行解密与验证. 私钥是一个数字(非常大),通常是随机选出来的. 通过椭圆曲线乘法生成一个公钥. 比特币是在公钥的基础上继续进行哈希函数生成比特币地址. 私钥为了生成私钥,需要挑选一个足够安全的熵源以保证随机性.从编程的角度来看,一般是通过在一个密码学安全的随机源中去除一长串随机字节,对其进行SHA256哈希算法进行运算,就可以产生一个256位二进制数,一般是以16进制表示. 有如下随机生成的秘药,以十六进制格式表示: 11E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD 比特币私钥空间大小是2^256,用十进制表示的话,大约是10^77. 目前可见宇宙被估计只含有10^80个原子. 公钥公钥K是通过使用私钥k进行椭圆曲线乘法运算得到公钥,这个过程不可逆: K=k*G,其中G是生成点的常数点. 逆向求私钥及其困难,只能暴力破解. 椭圆曲线密码学解释比特币使用的是secp256k1标准的特殊椭圆曲线. 由下述函数定义: 1y^2=(x^3 + 7) over (Fp) or y^2 mod p=(x^3 + 7) mod p 上述mod p(素数p取模)表明该曲线实在素数阶p的有限域内, 也写作Fp, 其中: p = 2^256 – 2^32 – 2^9 – 2^8 – 2^7 – 2^6 – 2^4 – 1, 这是⼀个⾮常⼤的素数. 上面的素数阶和有限域让我看得头疼,是啥? 带着问题,来到这个博客认真补习了一下离散数学的知识.这个博客学习ECC的原理. 椭圆曲线普通方程 : $\large y^2+a_1xy+a_3y=x^3+a_2x^2+a_4x+a_6$ &lt;/br&gt;无穷远点(0,Y,0) 平常点(x,y)斜率k: $\Large k=-\frac{F_x(x,y)}{F_y(x,y)}=\frac{3x^2+2a_2x+a_4-a_1y}{2y+a_1x+a_3}$ 椭圆曲线Abel群 : 在椭圆曲线定义了交换群(Abel群) 任意取椭圆曲线上两点P、Q（若P、Q两点重合，则作P点的切线），作直线交于椭圆曲线的另一点R’，过R’做y轴的平行线交于R，定义P+Q=R。这样，加法的和也在椭圆曲线上，并同样具备加法的交换律、结合律. 有限域椭圆曲线 : 因为椭圆曲线是连续的,需要将曲线上的点变成离散的点.把椭圆曲线定义在有限域上.所以椭圆曲线是模p的有限域,记作GF(p)或Fp. 可表示为(P,+,*),其中p是一个质数,P集合表示{0,1,..,p-1}.其中加运算和乘运算都是模运算.详情可以看这个博客,在这不展开. 椭圆曲线在有限域就表示为 Ep(a,b) ,p是质数, x,y∈[0,p-1] $\large y^2=x^3+ax+b\pmod p$ 选择两个满足下列条件的小于p的非负整数a,b $\large 4a^3+27b^2\ne0\pmod p$ Fp上的椭圆曲线同样有加法 无穷远点O∞是零元, 有O∞+ O∞= O∞，O∞+P=P P(x,y)的逆元是 (x,-y mod p)= (x,p-y) ，有P+(-P)= O∞ P(x1,y1),Q(x2,y2)的和R(x3,y3) 有如下关系： $x_3\equiv k^2-x_1-x_2\pmod p$ $y_3\equiv k(x_1-x_3)-y_1\pmod p$ 若P=Q, 则 $k=(3x_2+a)/2y_1\pmod p$ 若P≠Q, 则 $k=(y_2-y_1)/(x_2-y_1)\pmod p$ 举例 :椭圆曲线已知E_23(1,1)上两点P(3,10)，Q(9,7)，求(1)-P，(2)P+Q，(3) 2P 椭圆曲线加密 : 考虑K=kG ，其中K、G为椭圆曲线Ep(a,b)上的点，n为G的阶（nG=O∞），k为小于n的整数。则给定k和G，根据加法法则，计算K很容易但反过来，给定K和G，求k就非常困难。因为实际使用中的ECC原则上把p取得相当大，n也相当大，要把n个解点逐一算出来列成上表是不可能的。这就是椭圆曲线加密算法的数学依据. 点G称为基点（base point） k（kn）为私有密钥（privte key） K为公开密钥（public key) ECC保密通信算法 : Alice选定一条椭圆曲线E，并取椭圆曲线上一点作为基点G 假设选定E29(4,20)，基点G(13,23) , 基点G的阶数n=37 Alice选择一个私有密钥k，并生成公开密钥K=kG 比如25, K= kG = 25G = (14,6） Alice将E和点K、G传给Bob Bob收到信息后，将待传输的明文编码到上的一点M（编码方法略），并产生一个随机整数r（r小于n,n为G的阶数） 假设r=6 要加密的信息为3,因为M也要在E29(4,20) 所以M=(3,28) Bob计算点C1=M+rK和C2=rG C1= M+6K= M+625G=M+2G=(3,28)+(27,27)=(6,12) C2=6G=(5,7) Bob将C1、C2传给Alice Alice收到信息后，计算C1-kC2，结果就应该是点M C1-kC2 =(6,12)-25C2 =(6,12)-25*6G =(6,12)-2G =(6,12)-(27,27) =(6,12)+(27,2) =(3,28) 数学原来上能解密是因为:C1-kC2=M+rK-krG=M+rkG-krG=M 论文对ECC进行了剖析. ECC can provide security based on the known public key cryp-tography primitives, which are Elliptic Curve Digital Signature Al-gorithm (ECDSA), key exchange/agreement (ECDH, Elliptic Curve Diffie–Hellman) and Elliptic Curve Integrated Encryption Standard (ECIES). Compared with other public key cryptography schemes, ECC has 3 distinguished features, which make it very fit for resources-constrained environments [22]. It only requires significantly smaller key size than RSA and the modular exponent based public key schemes on the same level of security. Its point scalar multiplication operation is much faster than modular exponent operation and bilinear mapping operation. It is easy to be implemented in hardware. In this paper, we take these advantages of ECC and the features of ABE to construct an ABE scheme for IoT, where Elliptic Curve Decisional Diffie–Hellman Problem (ECDDHP) serves as the complexity assumption, and the Elliptic Curve Integrated Encryption Standard (ECIES) is adopted to encrypt the data. ECC提供的安全性基于ECDSA,ECDH,ECIES.与其他的公钥加密算法,ECC有如下几个非常适用于资源节约型的环境的特性. 相对于RSA,可以用较小量级的密钥大小提供与RSA相同等级的安全性. 标量乘法运算比模指数运算和双线性映射快得多. 在硬件上更容易实现. 本文基于这些ECC的功能,来构建在IoT上的ABE方案. ECDDH 来作复杂度假设, ECIES 对数据加密. ECDDH_ECDH_ 是一种在椭圆曲线上的Diffie-Hellman的密钥交换协议.可以帮助具有椭圆曲线公私钥对的双方通过不安全的通道生成 共享密钥.这个共享密钥可以直接当成密钥或者派生出新的密钥来加密接下来通讯内容. 例如, Alice与Bob使用同一套ECC系统(q,a,b,G,p) Alice的密钥对是(S_A , P_A=S_A*G). Bob的密钥对(S_B , P_B=S_B*G) 那么他们的共享密码K_{A,B}就是: K_{A,B}=S_A* P_B=S_B* P_A=S_A* S_B* G ECDDH(elliptic curve decisional Diffie–Hellman problem) 是ECDH的重要变体. 对于具有生成元G的q阶椭圆曲线群G_E, DHH表明, 给定c*G和d*G的条件下,c*d*G是G_E中的随机元素.(其中,c,d都是在q阶整数上随机取的.) 也就是说，对于给定的三元组（c·G，d·G，c·d·G）和（c·G，d·G，Z），无法判断Z = c·d·G ECIESECIES椭圆曲线集成加密方案,包含有密钥交换和公钥加密的部分. 使用ECDH生成共享密钥,数据的机密性由对称加密算法保证,密钥和数据完整性由MAC密钥的功能保证. 以下是ECIES的加密与解密步骤: Access structure访问结构用于描述访问策略,可用访问树表示,由如下定义: (Access Structure [11]). Let $\{A_1, A_2,…, A_n\}$ be a set of attributes. A collection $\mathbb{A}$ = $2^\{A_1,A_2,…,A_n\}$ is monotone, for $\forall B,C$: if $B\in \mathbb{A}$ and $B\subseteq C$, then $C ∈ \mathbb{A}$. An access structure (respectively, monotone) is a collection (respectively, monotone) $\mathbb{A}$ of non-empty subsets of $\{A_1,A_2,..,A_n\}$, i.e.,$\mathbb{A}⊆$$2^{A_1,A_2,..,A_n}\setminus \emptyset$. The sets in A are called the authorized attributes sets, and the sets not in A are called the unauthorized attributes sets. 有那么一组属性组 $\{A_1, A_2,…, A_n\}$, 设有一二元集合 $\mathbb{A}$ = $2^\{A_1,A_2,…,A_n\}$,如果对与任意的B与C,有B属于A,且B是C的子集,得到 C也属于A.那么二元集合A是单调的. 所以访问结构是属性集合 $\{A_1, A_2,…, A_n\}$ 的非空子集 $\mathbb{A}$ ,集合 $\mathbb{A}$ 称为授权集. 访问树 的具体定义与原理 在这篇文章有详细提及, 在这不详细说. 算法实现细节该算法是用KP-ABE的结构, 涵括了AA(attribute authority). 由四个算法步骤组成: Setup: 在中心节点生成public key parameters,PK和master key,MK. master key作为私钥在中心节点所用,public key parameters向外公开. Encrypt: 由发送者执行,将消息M输入,中心节点的PK加密输入(确定中心节点),设定属性集r,输出密文CM. key-Generation:由中心节点执行,将访问结构R和中心节点MK输入,根据R输出解密钥匙D. Decrypt: 由接收者执行,输入发送者发送的密文CM,中心节点给的解密钥匙D,中心节点的PK,当R(r)=1时,可以得出解密后的消息M. 本文的给出的KP-ABE算法本文所给出的轻量级的ABE是基于ECC的,假定ECC的参数是(q,a,b,G,p). 对于属性集w, 密钥是由基于拉格朗日插值法的secret sharing构建的. 且该方法有一个ECC-based的密钥生成中心.（拉格朗日插值法学习链接） Setup:首先是定义中心节点的属性集U,对U中每个属性$i$, 在ECC的q阶正整数群内随机找一个对应的数字 $s_i$,每个属性$i$的公钥就是$P_i=s_i\cdot G$. 同样地,在q阶正整数群内随机找一个数字$s$作为中心节点的MK,中心节点的PK就等于 $PK=s \cdot G$, 所以中心节点的公开参数可以表示为: $Params=\{ PK,P_1,..,P_\left | U \right|\}$ Encryption(M,w,Params): 与现存的ABE不同的是, 消息M是由ECIES加密的,而不是模指数运算或者双线性配对加密的. 随机从ECC的q阶正整数群选择k来计算C’,$C’=k \cdot PK=(K_x,K_y)$,若C’为0则重选k. 分别对Params中$P_i$计算$C_i$, $C_i=k \cdot P_i, i \in w$. $K_x$为加密密钥,$K_y$则是整合的密钥. $C=ENC(M,K_x)$, $MAC_M=HMAC(M,K_y)$ 密文cipher-text就可以表示为$CM=(w,C,MAC_M,C_i,i\in w)$. KeyGeneration($\Gamma,MK$): 当且仅当 $\Gamma (w)=1$时,通过算法生成解密的密钥. 对访问控制树 $\Gamma$上的每个节点u都自上而下进行定义,这些节点的门限都是$d_u$. 多项式$q_u(x)$由此定义 对于访问树 $\Gamma$的根R,设$q_R(0)=s$ (ps: s就是setup步骤的MK) 并随机选择$d_R-1$个其他点做多项式$q_R(x)$ 对于其他节点u, $q_u(0)=q_{parent(u)}(index(u))$,也要随机选择$d_u-1$个其他点来定义$q_u(x)$ 当访问树的叶子节点都被定义了之后,叶子节点u的secret share解密密钥就可以表示为:$\large D_u=q_u(0)/s_i$,其中$i$是一个属性,$s_i$在setup步骤上就已经定义,$s_i^-1$是$s_i$在ECC群中的逆元.根据这样的访问树结构就能逐步还原. 最终解密密钥可以表示为:$D=(D_u=q_u(0)/s_i, i=attr(u)\ and\ \ i\in w)$. Decryption(CM,D,Params):与其他算法相似,在访问树里的节点的解密算法用递归的方法实现. 对每个叶子节点u, 令 $i=attr(u)$ 有:$ DecryptNode(CM,D,u)=$\begin{cases}D_u \cdot C_i=q_u(0) \cdot s_i^-1\cdot k\cdot P_i\\=q_u(0) \cdot s_i^-1\cdot k\cdot s_i\cdot G\\=q_u(0) \cdot k\cdot G , &amp;(i\in w)\\\perp , &amp;Otherwise.\end{cases} 对非叶子节点,可以对每个子节点v调用$DecryptNode(CM,D,v)$. 令$w_u$为u的$d_u$个子节点的集合, 对每一个$w_u$的元素v进行$DecryptNode(CM,D,v)$. 若存在$w_u$,那么有: 对根节点有:$DecryptNode(CM, D, R) = q_R(0)·k·G = s·k·G = (K′_x, K′_y)$.其中$K’_x$就是消息M的解密密钥,$K’_y$是消息M的集合密钥.$M’=DEC(C,K’_X)$. 如果$HMAC(M’,K’_y)=MAC_M$,那么就表示消息M已经被正确解密. 所以说所有的正确性,完整性都由$MAC_M$验证. 算法表现与分析本文为了评估所提出的ABE方案的轻量级的特点,在 _通信开销_ 和 KP-ABE和CP-ABE的 _加算开销_ 上分析.并给出该算法的限制. 通信开销指标通信开销取决于所传输的消息的长度. 传输的消息包括了 密文cipher-text ,公钥 和 私钥. 现有大多数ABE方案都是基于双线性配对的RSA-based方案.有两个群$G_1,G_2$, $G_1$是一个大素数阶的双线性群,双线性映射可以表示为 $G_1 \times G_1 \rightarrow G_2$. 且$G_1,G_2$ 的基本运算都是模指数运算.在相同安全级别上,RSA的密钥对比ECC的密钥对长得多.RSA的密钥对长度在 $G_1$ 是ECC的3.2倍,$G_2$ 是6.4倍. 在ABE方案中,密文需要包含属性集, 密文的长度与属性集成线性增长. 密文 $CM=(w,C,MAC_M,C_i,i\in w)$ ,$C_i$是椭圆曲线的一点,且长度为$2l$,由于先前的假设,消息M和MAC的长度都为安全级别$l$,所以$C$和$MAC_M$也是$l$位长. 所以给出的方案的密文长度是 $(l+l+k*2l)=(2k+2)l$. 另外,公钥是 $\{PK,P_i,i\in U\}$,每一个元素都是椭圆曲线上的一点,所以公钥长度为 $(2l+n*2l)=(2n+2)l$.私钥是 $\{D_u=q_u(0)/s_i,\ i=attr(u)\mbox{ and }i\in w\}$, 长度是$k\cdot l$. 计算开销指标本文对比了现有的CP-ABE和KP-ABE. 计算开销一般是由双线性映射(公钥的加密解密操作)的成本衡量的.本方案中没涉及,所以不计算.本文的加密算法包括了(1+k)点标量乘法,且解密的递归过程不超过(2k-1)点标量乘法,所以总的最多有3k个点标量乘法. 与其他的方案的比较如下图: 可以看出在 公私钥长度 都远比其他方案要短, 密文长度 在属性大于10个时大于常数级的方案.计算开销 也明显小于一般方案. 所以说在 轻量级 的属性加密方案上,该文的方案是很优秀的. 提出的ABE方案的限制 撤销属性灵活性较差: 使用的是单调访问结构和秘密共享机制,都是在”AND”和”OR”门上进行的,不支持”NOT”门, 难以表达复杂的访问策略,属性撤销也很麻烦.通常操作都是重新加密来实现属性撤销. 本文并没有讨论属性撤销属性. 可扩展性差: 通信开销和计算开销都与加密属性数量成线性关系. 通用性较差: 本方案是单一权限上的应用,不适用于多权限结构. 参考文章 Yao X, Tian Y, Tian Y. A lightweight attribute-based encryption scheme for the Internet of Things[J]. Future Generation Computer Systems, 2015, 49(C):104-112. Bitcoin加密技术之椭圆曲线密码学 谈谈有限域那些事儿 离散对数和椭圆曲线加密原理 ECC入门+实例 (身份证比特币加密算法) 数学、英语对程序员来说重要吗？记线性秘密分享方案（Linear Secret Sharing Scheme，LSSS）的实现 如何直观地理解拉格朗日插值法？ @马同学的回答 密码学中的离散数学知识学习]]></content>
      <categories>
        <category>论文研究</category>
        <category>密码学</category>
      </categories>
      <tags>
        <tag>ECC</tag>
        <tag>属性加密</tag>
      </tags>
  </entry>
</search>
