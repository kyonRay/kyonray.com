<?xml version="1.0" encoding="utf-8" ?>
<search>


  <entry>
    <title>Hyperledger Indy Research: Anonymous credentials with type-3 revocation</title>
    <link href="/2019/08/13/Hyperledger-Indy-Research-Anonymous-credentials-with-type-3-revocation/" />
    <url>/2019/08/13/Hyperledger-Indy-Research-Anonymous-credentials-with-type-3-revocation/</url>

    <content type="html">
      <![CDATA[<h2 id="一简述">一、简述</h2><p>匿名凭证的作用是允许用户证明当前identity符合某个属性，且不暴露出其他属性。本文描述的方法通过使用零知识证明的方式保证属性在披露的过程中不被其他人知道，且可实现凭证一次性使用，第二次用于展示给Verifier的时候会被感知。</p><p>由于其原稿难懂，有多个符号错误，计算错误，符号未命名的问题，所以本人进行翻译、纠正。</p><a id="more"></a><p>Indy选择性披露核心的流程在于：</p><p>Init：</p><ul><li><p>issuser生成属性模板</p></li><li><p>prover/holder使用自己的私钥master key和属性（可以盲化或不盲化），用属性模板生成证明，向issuer获取证书</p></li><li><p>issuer用自己的私钥对属性进行签名，将其发送给Holder</p></li></ul><p>Verify：</p><ul><li><p>prover选择要披露的属性，，根据证书生成证书的proof，将proof和属性给Verifier</p></li><li><p>Verifier根据issuer的公钥，proof，属性。用证书验证属性是否在proof里。验证proof是否是由Issuer的公钥签发</p></li></ul><p>核心性质：</p><ul><li><p>不可伪造性(unforgeable)，即没有人可以使用未经Issuer签发的凭证通过Verifier的验证</p></li><li><p>不可链接性(unlinkable)，即不可能使用同样的凭证与多个匿名的presentation关联。技术上用knowledge proof证明他拥有凭证。</p></li><li><p>可拓展性(delegatable)，Prover A可以将具有特定属性X的证书C(credential)委托给Prover B，同时Verifier在当B提供属性Y的时候不获取A的身份。技术上代表可以进一步创建证书链。</p></li></ul><h2 id="二protocol-overview">二、Protocol Overview</h2><p>最简单的凭证生命周期：一个凭证，单个issuer，单个持有人，单个验证者</p><ol type="1"><li>Issuer制定凭证模板<span class="math inline">\(\mathcal S\)</span>：签凭证使用的密码学类型、<span class="math inline">\(l\)</span> 个凭证属性、隐藏属性 <span class="math inline">\(A_h \subset \{1,2,…,l\}\)</span> 、凭证公钥 <span class="math inline">\(P_k\)</span> 、非撤销凭证属性数<span class="math inline">\(l_r\)</span> 非撤销公钥<span class="math inline">\(P_r\)</span> ，并将凭证公布到区块链上，定义其语义；</li><li>Holder检索到凭证模板，并设定隐藏属性；</li><li>Holder想Issuer请求凭证，并将隐藏属性以黑盒的形式发给Issuer，并对已知属性的值达成协议 <span class="math inline">\(A_k=\{1,2,...,l\}/A_h\)</span> ；</li><li>Issuer返回凭证对<span class="math inline">\(（C_p，C_{NR}）\)</span> 给Holder。第一个 <span class="math inline">\(C_p\)</span> 凭证包括了必须设定的 <span class="math inline">\(l\)</span>个属性，第二个<span class="math inline">\(C_{NR}\)</span> 赋值了第一个凭证的非撤销状态；Issuer随后将该凭证的未撤销状态公布到链上；</li><li>Holder连接到Verifier，Verifier发送证明请求 <span class="math inline">\(\mathcal E\)</span> 给Holder，证明请求包括了凭证模板<span class="math inline">\(\mathcal{S}_E\)</span> 和披露断言 <span class="math inline">\(\mathcal D\)</span> ；对于属性 <span class="math inline">\(m\)</span> 与验证值 <span class="math inline">\(V\)</span> 的披露断言模式可以有 <span class="math inline">\(m&gt;V, m&lt;V, m=V\)</span> ；</li><li>Holder检查所持有的凭证对是否符合 Verifier发来的模板 <span class="math inline">\(\mathcal{S}_E\)</span> ，并从区块链中检索该模板未被撤销的见证(witness)；</li><li>Holder 使用符合证明请求 <span class="math inline">\(\mathcal E\)</span> 的未撤销凭证，生成了证明 <span class="math inline">\(P\)</span> ，并发送给Verifier；</li><li>Verifier验证证明<span class="math inline">\(P\)</span>；</li></ol><p>以下<strong>时序图</strong>描述整个协议流程：</p><p>Prover与Issuer交互：</p><p><img src="./Issuer与Prover交互.svg"></p><p>Prover与Verifier交互：</p><p><img src="./Prover与Verifier交互.svg"></p><h2 id="三具体方案步骤">三、具体方案步骤</h2><p>接下来以整个方案的流程逐步详细介绍：</p><h3 id="schema准备">1. Schema准备</h3><h4 id="issuer定义凭证属性">1.1 Issuer定义凭证属性</h4><p><strong>（1.1.1）</strong>Issuer定义一个有 <span class="math inline">\(l\)</span> 个属性 <span class="math inline">\(\{m_1,…,m_l\}\)</span> 的Schema <span class="math inline">\(\mathcal{S}\)</span> ，并设置隐藏属性集合 <span class="math inline">\(A_h \subset \{1,2,…,l\}\)</span> 。</p><p>在Sovrin中，<span class="math inline">\(m_1\)</span> 保留为链接向Holder的链接， <span class="math inline">\(m_2\)</span> 保留为枚举器， <span class="math inline">\(m_3\)</span> 保留为策略地址<span class="math inline">\(I\)</span> ，并且<span class="math inline">\(\{1,3\}\subset A_h, and\ 2 \notin A_h\)</span>；</p><p>Issuer定义非撤销凭证内含 <span class="math inline">\(m_1,m_2\)</span> 两个属性；</p><h4 id="issuer定义凭证密码方法">1.2 Issuer定义凭证密码方法</h4><ul><li><strong>（1.2.1）</strong>Issuer使用CL签名算法，生成一组<strong>Primary Credentia</strong>l公私钥对：<ul><li>随机获取1024-bit的素数 <span class="math inline">\(p&#39;, q&#39;\)</span> ，计算： <span class="math inline">\(p\leftarrow 2p&#39;+1,\ q\leftarrow 2q&#39;+1,\ n\leftarrow pq\)</span></li><li>随机取模n的二次剩余 <span class="math inline">\(S\)</span> ：<span class="math inline">\(S\)</span> 不是n的倍数，且mod n同余于某个数的平方，例如 <span class="math inline">\(S\equiv x^2(mod\ n),\ S^{(n-1)/2}\equiv 1(mod\ n)\)</span> ；</li><li>随机取 <span class="math inline">\(x_Z，x_{R_1},…,x_{R_l}\ \in[2;p&#39;q&#39;-1]\)</span></li><li>计算得公钥 <span class="math inline">\(P_k = (n,S,Z\leftarrow S^{x_Z},\{R_i\leftarrow S^{x_{R_i}}\}_{1\leqslant i \leqslant l})\)</span> ，私钥 <span class="math inline">\(s_k=(p&#39;,q&#39;)\)</span></li></ul></li></ul><h4 id="issuer提供凭证密钥正确性">1.3 Issuer提供凭证密钥正确性</h4><ul><li><p><strong>（1.3.1）</strong> Issuer生成一堆随机数 <span class="math inline">\(\widetilde{x_Z}，\widetilde{x_{R_1}},…,\widetilde{x_{R_l}}\ \in[2;p&#39;q&#39;-1]\)</span></p></li><li><p>Issuer计算：</p></li></ul><p><span class="math display">\[\widetilde{Z}\leftarrow S^{\widetilde{x_Z}}\\\{\widetilde{R_i}\leftarrow S^{\widetilde{x_{R_i}}}(mod\ n)\}_{i\le i\le l}\\c\leftarrow H_1(Z||\widetilde Z||\{R_i,\widetilde{R_i}\}_{1\le i\le l})\\\widehat{x_Z}\leftarrow \widetilde{x_Z}+cx_Z\\\{\widehat{x_{R_i}}\leftarrow \widetilde{x_{R_i}}+cx_{R_i}\}_{1\le i\le l}\]</span></p><ul><li>Issuer最终将证明 <span class="math inline">\(\mathcal P_I=(c,\widehat{x_Z},\{\widehat{x_{R_i}}\}_{1\le i\le l})\)</span> 发送出去。</li></ul><h4 id="issuer定义non-revocation凭证">1.4 Issuer定义Non-revocation凭证</h4><ul><li><p><strong>（1.4.1）</strong>Issuer使用CKS聚合器与签名方法以追踪Primary Credential的撤销状态，生成一组<strong>Non-revocation Credential</strong>的密钥对：</p><ul><li>设有双线性配对群 <span class="math inline">\((q, \Bbb{G}_1,\Bbb{G}_2, \Bbb{G}_t,e,g,g&#39;)\)</span> ，其中 <span class="math inline">\(\Bbb{G}_1,\Bbb{G}_2,\Bbb{G}_t\)</span> 都是素数 <span class="math inline">\(q\)</span> 阶群，<span class="math inline">\(e : \Bbb{G}_t \leftarrow \Bbb{G}_1 × \Bbb{G}_2\)</span> 是一种映射关系，<span class="math inline">\(g,g’\)</span> 分别是 <span class="math inline">\(\Bbb{G}_1,\Bbb{G}_2\)</span> 的生成子。</li><li>随机生成 <span class="math inline">\(h,h_0,h_1,h_2, \widetilde{h} \in \Bbb{G}_1\)</span> ；</li><li>随机生成 <span class="math inline">\(u,\widehat{h} \in \Bbb{G}_2\)</span> ；</li><li>随机生成 <span class="math inline">\(sk, x \in \Bbb{Z}_q\)</span> ；</li><li>计算得出撤销公钥： <span class="math inline">\(P_r=(g,g&#39;,h,h_0,h_1,h_2,\widetilde{h}, \widehat{h},u,pk\leftarrow g^{sk},y\leftarrow \widehat{h}^x)\)</span> 得出私钥 <span class="math inline">\((x,sk)\)</span></li></ul></li><li><p><strong>（1.4.2）</strong>Issuer生成新的聚合器(Accumulator) <span class="math inline">\(A\)</span> ，其中 <span class="math inline">\(L\)</span> 是凭证的index ：</p><ul><li><p>随机生成 <span class="math inline">\(\gamma \in \Bbb{Z}_q\)</span> ；</p></li><li><p>计算：</p></li></ul><p><span class="math display">\[\tag{1.1}g_1,g_2,…,g_L,g_{L+2},…,g_{2L},\ where\ g_i=g^{\gamma^i}\]</span></p><p><span class="math display">\[\tag{1.2}g&#39;_1,g&#39;_2,…,g&#39;_L,g_{L+2},…,g&#39;_{2L},\ where\ g&#39;_i=g&#39;^{\gamma^i}\]</span></p><p><span class="math display">\[\tag{1.3}z=(e(g,g&#39;))^{\gamma^{L+1}}\]</span></p><ul><li><p>设置值 <span class="math inline">\(V\leftarrow \emptyset\)</span> ，聚合器 <span class="math inline">\(acc\leftarrow 1\)</span> ；</p></li><li><p>进而得出聚合器的公钥 <span class="math inline">\(P_a=(z)\)</span> ，私钥 <span class="math inline">\((\gamma)\)</span> ；</p></li><li><p>之后Issuer把 <span class="math inline">\((P_a,V)\)</span> 公布到区块链上供其他人进行累积、验证， 聚合器的DID设置为 <span class="math inline">\(ID_a=z\)</span> 。</p></li></ul></li></ul><h3 id="credential发行">2. Credential发行</h3><h4 id="holder获取凭证模板进行验证模板是issuer发的">2.1 Holder获取凭证模板，进行验证模板是Issuer发的</h4><p>Holder拿到模板以及Issuer的公钥、证明 <span class="math inline">\((c,\widehat{x_Z},\{\widehat{x_{R_i}}\}_{1\le i\le l})\)</span> ，进行进一步计算： <span class="math display">\[\widehat Z\leftarrow Z^{-c}S^{\widehat{x_Z}}\ (mod\ n)\\\{\widehat{R_i}\leftarrow R_i^{-c}S^{\widehat{x_{R_i}}}\ (mod\ n)\}_{1\le i\le l}\]</span> 验证： <span class="math display">\[c=H_1(Z||\hat Z||\{R_i,\widehat{R_i}\}_{1\le i\le l})\]</span></p><h4 id="holder进行凭证设定">2.2 Holder进行凭证设定</h4><ul><li><p>Holder从区块链中获取了凭证的模板 <span class="math inline">\(\mathcal S\)</span> ，并设置属性 <span class="math inline">\(\{m_i\}_{i\in A_h}\)</span> ，其余未设置的属性皆为0；</p></li><li><p>Holder建立与Issuer的连接，从Issuer那获取随机数 <span class="math inline">\(n_0\)</span> ，Holder的DID为 <span class="math inline">\(\mathcal{H}\)</span> ；</p></li><li><p><strong>（2.2.1）</strong>Holder做以下计算，为Primary Credential的数据做准备：</p><ul><li><p>生成 2128-bit随机数 <span class="math inline">\(v&#39;\)</span> ，673-bit随机数 <span class="math inline">\(\widetilde{v&#39;}\)</span></p></li><li><p>生成593-bit随机数 <span class="math inline">\(\{\widetilde{m_i}\}_{i\in A_h}\)</span></p></li><li><p>使用Primary Credential的公钥 <span class="math inline">\(P_k\)</span> 计算Primary Credential的盲化secret： <span class="math display">\[\tag{2.1}U\leftarrow (S^{v&#39;})\prod_{i\in A_h}R_i^{m_i}\]</span></p></li><li><p>计算commitment Attribute属性值 <span class="math inline">\(vca\)</span> ，其中 <span class="math inline">\(blind\)</span> 是盲化因子： <span class="math display">\[\tag{2.2}\{vca_i\}_{i\in A_{commit}}=\{S^{blind}\cdot Z^{m_i}\}_{i\in A_{commit}}\\\widetilde{r_i}=rand(593bit)_{i\in A_{commit}}\]</span></p></li></ul><p><span class="math display">\[\tag{2.3}\{\widetilde{commitment_i}=Z^{\widetilde{m_i}}\cdot S^{\widetilde{r_i}}\}_{i\in A_{commit}}\]</span></p><ul><li>另外计算盲化正确proof：</li></ul><p><span class="math display">\[\tag{2.4}\widetilde{U}\leftarrow (S^{\widetilde v&#39;})\prod_{i\in A_h}R_i^{\widetilde m_i}\]</span></p><p><span class="math display">\[\tag{2.5}c\leftarrow H(\{\widetilde{commitment_i}\}||\{vca_i\}||U||\widetilde U||n_0)_{i\in A_{commit}}\]</span></p><p><span class="math display">\[\tag{2.6}\widehat{v&#39;}\leftarrow \widetilde{v&#39;} + cv&#39;\]</span></p></li></ul><p><span class="math display">\[\tag{2.7.1}\{\widehat{m_i}\leftarrow \widetilde{m_i} +cm_i\}_{i\in A_h}\]</span></p><p><span class="math display">\[\tag{2.7.2}\{\widehat{r_i}\leftarrow \widetilde{r_i}+c\cdot blind\}_{i\in A_{commit}}\]</span></p><ul><li><p>生成80-bit随机数 <span class="math inline">\(n_1\)</span></p></li><li><p>将 <span class="math inline">\(\{U,c,\widehat{v&#39;},\{\widehat{m_i}\}_{i\in A_h},n_1,attr\_name\subset\{A_h\},\{A_{commit}\}=\{attr\_name,vca\}\}\)</span> 打包发送给Issuer</p></li><li><p><strong>（2.2.2）</strong>Holder做以下计算，为Non-Credential的数据做准备：</p><ul><li><p>获取撤销公钥 <span class="math inline">\(P_R\)</span> ，并生成随机数 <span class="math inline">\(s&#39;_R \in \Bbb{Z}_q\)</span> ；</p></li><li><p>计算 <span class="math display">\[ \tag{2.8}U_R\leftarrow h_2^{s&#39;_R},\ where\ h_2\ in\ P_R \]</span></p></li><li><p>将 <span class="math inline">\(U_R\)</span> 发送给Issuer</p></li></ul></li></ul><h4 id="issuer收到凭证模板确认后颁发">2.3 Issuer收到凭证模板，确认后颁发</h4><ul><li><p><strong>（2.3.1）</strong>Issuer验证Holder发来的Primary Credential模板数据是否正确：</p><ul><li>计算<span class="math inline">\(\widehat{U}\leftarrow (U^{-c})\prod_{i\in A_h}R_i^{\widehat m_i}(S^{\widehat{v&#39;}})\)</span> ；</li><li><span class="math inline">\(\{\widehat{commitment_i}\leftarrow vca_i^{-c}\cdot Z^{\widehat{m_i}}S^{\widehat{r_i}}\}_{i\in A_{commit}}\)</span></li><li>验证<span class="math inline">\(c= H(\{\widehat{commitment_i}\}||\{vca_i\}||U||\widehat U||n_0)_{i\in A_{commit}}\)</span> ；</li></ul></li><li><p>验证 <span class="math inline">\(\widehat{v&#39;}\)</span> 是一个673-bit的数，<span class="math inline">\(\{\widehat{m_i},\widehat{r_i}\}_{i\in A_h}\)</span> 是594-bit的数；</p></li><li><p><strong>（2.3.2）</strong>Issuer准备为Holder发行Primary凭证：</p><ul><li>为当前Holder赋值一个唯一值 <span class="math inline">\(i&lt;L\)</span> 作为标识, 计算 <span class="math inline">\(m_2\leftarrow H(i||\mathcal{H})\)</span> 记录了当前Holder 的信息，并将 <span class="math inline">\(m_2\)</span> 和<span class="math inline">\(i\)</span>保存在本地数据库；</li><li>设置可被披露的属性值 <span class="math inline">\(A_k\)</span> ；</li><li>生成2724-bit 随机数 <span class="math inline">\(v&#39;&#39;\)</span>, 随机素数 <span class="math inline">\(e,\ where\ 2^{596}\leqslant e \leqslant 2^{596}+2^{119}\)</span> ；</li><li>随机生成 <span class="math inline">\(r&lt;p&#39;q&#39;\)</span> ，其中 <span class="math inline">\(p&#39;,q&#39;\)</span> 从Primary凭证私钥中得出 ;</li><li>计算<strong>签名</strong>：</li></ul><p><span class="math display">\[\tag{2.9}Q\leftarrow \cfrac{Z}{US^{v&#39;&#39;}\prod_{i\in A_k}R_i^{m_i}(mod\ n)}\\\]</span></p><p><span class="math display">\[\tag{2.10}A\leftarrow Q^{e^{-1}(mod\ p&#39;q&#39;)}(mod\ n)\]</span></p><ul><li>计算签名<strong>Proof</strong>： <span class="math display">\[\tag{2.11}\widehat A\leftarrow Q^r\ (mod\ n)\]</span> <span class="math display">\[\tag{2.12}c&#39; \leftarrow H(Q||A||\widehat A||n_1)\]</span> <span class="math display">\[\tag{2.13}s_e\leftarrow r-c&#39;e^{-1}\ (mod\ p&#39;q&#39;)\]</span></li></ul></li><li><p><strong>（2.3.3）</strong>Issuer 将primary pre-credential <span class="math inline">\((\{m_i\}_{i\in A_k},A,e,v&#39;&#39;,s_e,c&#39;)\)</span> 发送给Holder；</p></li><li><p><strong>（2.3.4）</strong>Issuer 非撤销凭证（Non-revocation Credential）的颁发</p><ul><li><p>生成随机数 <span class="math inline">\(s&#39;&#39;,c\leftarrow Z_q\)</span> ；</p></li><li><p>将Primary凭证中的 <span class="math inline">\(m_2\)</span> 也加入到非撤销凭证中，进行两个凭证的关联；</p></li><li><p><span class="math inline">\(acc_V\)</span>是聚合器值，为证书分配一个未使用的索引index <span class="math inline">\(i\)</span> ，<span class="math inline">\(V\)</span> 是现在未被撤销的集合；</p></li><li><p>计算（其中L为最多颁发的证书个数，在代码中表示为n）： <span class="math display">\[\tag{2.14} \sigma \leftarrow (h_0h_1^{m_2}\cdot U_R\cdot g_i\cdot h_2^{s&#39;&#39;})^{\cfrac{1}{x+c}}\]</span> <span class="math display">\[\tag{2.15}w\leftarrow \prod_{j\in V}g&#39;_{L+1-j+i}\]</span> <span class="math display">\[\tag{2.16}\sigma_i \leftarrow g&#39;^{1/(sk+\gamma^i)}\]</span> <span class="math display">\[\tag{2.17}u_i \leftarrow u^{\gamma_i}\]</span> <span class="math display">\[\tag{2.18}acc_V\leftarrow acc_V\cdot g&#39;_{L+1-i}\]</span> <span class="math display">\[\tag{2.19}V\leftarrow V\cup\{i\}\]</span> <span class="math display">\[\tag{2.20}wit_i\leftarrow \{\sigma_i,u_i,g_i,w,V\}\]</span></p></li><li><p>将非撤销凭证 <span class="math inline">\((I_A,\sigma,c,s&#39;&#39;,wit_i,g_i,g&#39;_i,i)\)</span> 发给Holder；</p></li><li><p>将更新的 <span class="math inline">\(V,acc_V\)</span> 放到区块链中；</p></li></ul></li></ul><h4 id="holder收到两个凭证进行存储">2.4 Holder收到两个凭证，进行存储</h4><ul><li><p><strong>（2.4.1）</strong>Holder存储凭证</p></li><li><p>计算 <span class="math inline">\(v\leftarrow v&#39;+v&#39;&#39;\)</span>；</p></li><li><p>验证 <span class="math inline">\(e\)</span> 是素数，且符合 <span class="math inline">\(2^{596}\leqslant e \leqslant 2^{596}+2^{119}\)</span> ；</p><ul><li>计算： <span class="math display">\[\tag{2.21}Q\leftarrow \cfrac{Z}{S^v \prod_{i\in C_S}R_i^{m_i}}\ (mod\ n)\]</span></li></ul></li><li><p><strong>（2.4.2）</strong>验证 <span class="math inline">\(Q=A^e(mod\ n)\)</span>；</p></li><li><p><strong>（2.4.3）</strong>计算： <span class="math display">\[  \tag{2.22}\widehat A \leftarrow A^{c&#39;+s_e\cdot e}  \]</span></p><ul><li>验证 <span class="math inline">\(c&#39;=H(Q||A||\widehat A||n_1)\)</span> ；</li></ul></li><li><p>存储Primary凭证<span class="math inline">\(C_p=(\{m_i\}_{i\in C_s},A,e,v)\)</span> ；</p></li><li><p>计算 <span class="math inline">\(s\leftarrow s&#39;_R+s&#39;&#39;\)</span>， 存储非撤销凭证 <span class="math inline">\(C_{NR}\leftarrow(I_A,\sigma,c,s,wit_i,g_i,g&#39;_i,i)\)</span> ；</p></li><li><p><strong>（2.4.4）</strong>三个等式证明Holder收到的Non-revocation 凭证的正确性 <span class="math display">\[\cfrac{e(g_i,acc_V)}{e(g,w)}=z\\e(pk\cdot g_i,\sigma_i)=e(g,g&#39;)\\e(\sigma,y\cdot \widehat h^{c})=e(h_0\cdot h_1^{m_2}h_2^sg_i,\widehat h)\]</span></p></li></ul><h3 id="凭证撤销">3. 凭证撤销</h3><p><strong>（3.1）</strong>Issuer在数据库找到要被撤销的凭证，并找出他的索引号 <span class="math inline">\(i\)</span> ，以及聚合器 <span class="math inline">\(A\)</span>，有效凭证集合 <span class="math inline">\(V\)</span></p><ul><li>从 <span class="math inline">\(V\)</span> 中剔除 <span class="math inline">\(i\)</span> ： <span class="math inline">\(V \leftarrow V -\{i\}\)</span> ；</li><li>从聚合器中剔除：<span class="math inline">\(acc_V\leftarrow acc_V/g&#39;_{L+1-i}\)</span> ；</li><li>公布出新的 <span class="math inline">\(\{V,acc_V\}\)</span> ；</li></ul><h3 id="holder展示凭证">4. Holder展示凭证</h3><h4 id="verifier向holder发出proof-request">4.1 Verifier向Holder发出Proof Request</h4><ul><li>Verifier向Holder发出 <span class="math inline">\(d\)</span> 个凭证模板集合 <span class="math inline">\(\{\mathcal S_1,\mathcal S_2,...\mathcal S_d\}\)</span> 的证明请求（Proof Request）；</li><li>Holder 需要对应的给出 <span class="math inline">\(d\)</span> 个凭证证明对 <span class="math inline">\((C_p,C_{NR})\)</span> 回应；</li><li>假设模板集合有 <span class="math inline">\(X\)</span> 个属性，其中，公开属性集合 <span class="math inline">\(x_1:A_h=X-x_1\)</span> ，需证明相等的属性 <span class="math inline">\(x_2: m_i=m_j\)</span> ，需证明不相等属性 <span class="math inline">\(x_3:m_i(&gt;&lt;\geq \leq) z\)</span> ；</li><li><span class="math inline">\(x_4=X-x_1-x_2\)</span> ，映射 <span class="math inline">\(\phi:A_h\ to\ \{1,2,...,x_4\}\)</span>，<span class="math inline">\(A_v\)</span> 表示 <span class="math inline">\(x_1\)</span> 披露的属性索引集合；</li><li>Verifier给Holder发80-bit随机数 <span class="math inline">\(n_2\)</span> ，用于之后与Holder交互；</li></ul><h4 id="holder提供证明">4.2 Holder提供证明</h4><ul><li><p><strong>（4.2.1）</strong>Holder准备对应凭证对 <span class="math inline">\((C_p,C_{NR})\)</span> 去验证；</p><ul><li>生成 <span class="math inline">\(x_4\)</span> 个592-bit随机数 <span class="math inline">\(\widetilde{y_1},\widetilde{y_2},...,\widetilde{y_{x_4}}\)</span> ，并设定 <span class="math inline">\(\widetilde{m_j}\leftarrow \widetilde{y_{\phi(j)}} , where\ j\in A_h\)</span> ；</li><li>生成两个空集合 <span class="math inline">\(\mathcal T,\mathcal C\)</span> ；</li><li>对所有凭证对 <span class="math inline">\((C_p,C_{NR})\)</span> 都准备证明；</li></ul></li><li><p><strong>（4.2.2）</strong>Holder给出非撤销证明：</p><ul><li><p>加载Issuer的撤销公钥 <span class="math inline">\(p=(h,h_1,h_2,\widetilde h,\widehat h,u,pk,y)\)</span> ；</p></li><li><p>加载非撤销凭证 <span class="math inline">\(C_{NR}=(I_A,\sigma,c,s,wit_i,g_i,g&#39;_i,i)\)</span> ；</p></li><li><p>获取现在的未撤销凭证索引集合 <span class="math inline">\(V\)</span> ，聚合器 <span class="math inline">\(acc\)</span> ；</p></li><li><p>更新非撤销凭证 <span class="math inline">\(C_{NR}\)</span> ： <span class="math display">\[\tag{4.1}w\leftarrow w\cdot \cfrac{\prod_{j\in (V\backslash V_{old})}g&#39;_{L+1-j+i}}{\prod_{j\in (V_{old}\backslash V)}g&#39;_{L+1-j+i}};\ where\ V_{old}\ is\ from\ wit_i;\\V_{old}\leftarrow V;\]</span></p></li><li><p>随机取随机数： <span class="math inline">\(\rho,r,r&#39;,r&#39;&#39;,r&#39;&#39;&#39;,o,o&#39;\ mod\ q\)</span> ；</p></li><li><p>计算以下公式，并将最终所得放到集合 <span class="math inline">\(\mathcal C\)</span> ：</p></li></ul><p><span class="math display">\[\tag{4.2}E\leftarrow h^{\rho}\widetilde h^o;\]</span> <span class="math display">\[\tag{4.3}D\leftarrow g^{r}\widetilde h^{o&#39;};\]</span> <span class="math display">\[\tag{4.4}A\leftarrow \sigma \widetilde h^{\rho};\]</span> <span class="math display">\[\tag{4.5}\mathcal G \leftarrow g_i\widetilde h^r;\]</span> <span class="math display">\[\tag{4.6}\mathcal W \leftarrow w\widehat h^{r&#39;};\]</span> <span class="math display">\[\tag{4.7}\mathcal S \leftarrow \sigma_i \widehat h^{r&#39;&#39;};\]</span> <span class="math display">\[\tag{4.8}\mathcal U \leftarrow u_i\widehat h^{r&#39;&#39;&#39;};\]</span> &gt; E、D分别是对<span class="math inline">\(\rho\)</span> 和 <span class="math inline">\(r\)</span> 的承诺</p></li></ul><blockquote><p><span class="math inline">\(\mathcal G\)</span>, <span class="math inline">\(\mathcal W\)</span>, <span class="math inline">\(\mathcal S\)</span>, <span class="math inline">\(\mathcal U\)</span> 分别是对<span class="math inline">\(g_i\)</span>, <span class="math inline">\(w\)</span>, <span class="math inline">\(\sigma_i\)</span>, <span class="math inline">\(u_i\)</span>的盲化</p><p><span class="math inline">\(NonRevocProofCList \leftarrow \{ E, D, A, \mathcal G, \mathcal W, \mathcal S, \mathcal U \}\)</span>, 作为c_list</p><p>以上过程由ProofBuilder::_create_c_list_values() 完成</p></blockquote><ul><li><p>计算： <span class="math display">\[  \tag{4.9}  m\leftarrow \rho \cdot c;\]</span> <span class="math display">\[  \tag{4.10}  t\leftarrow o\cdot c;\]</span> <span class="math display">\[  \tag{4.11}  m&#39;\leftarrow r\cdot r&#39;&#39;;\]</span> <span class="math display">\[  \tag{4.12}  t&#39;\leftarrow o&#39;\cdot r&#39;&#39;;\]</span></p></li><li><p>随机取随机数：<span class="math inline">\(\widetilde{\rho},\widetilde{o},\widetilde{o&#39;},\widetilde{c},\widetilde{m},\widetilde{m&#39;},\widetilde{t},\widetilde{t&#39;},\widetilde{m_2},\widetilde{s},\widetilde{r},\widetilde{r&#39;},\widetilde{r&#39;&#39;},\widetilde{r&#39;&#39;&#39;},mod\ q\)</span> ；</p></li><li><p>计算以下公式，并将最终所得放到集合 <span class="math inline">\(\mathcal T\)</span> ： <span class="math display">\[  \tag{4.13} \overline{T_1}\leftarrow h^{\widetilde{\rho}}\widetilde h^{\widetilde o};\     \overline{T_2} \leftarrow E^{\widetilde c}h^{-\widetilde m}\widetilde h^{-\widetilde t}\]</span></p></li></ul><p><span class="math display">\[\tag{4.14}    \overline{T_3} \leftarrow e(acc_V,\widehat h)^{\widetilde c}\cdot e(\widetilde h,\widehat h)^{\widetilde r}\cdot e(\widetilde h,y)^{-\widetilde{\rho}}\cdot e(\widetilde h,\widehat h)^{-\widetilde m}\cdot e(h_1,\widehat h)^{-\widetilde{m_2}}\cdot e(h_2,\widehat h)^{-\widetilde s};\]</span></p><p><span class="math display">\[\tag{4.15}     \overline{T_4}\leftarrow e(\widetilde h,acc_V)^{\widetilde r}\cdot e(1/g,\widehat h)^{\widetilde {r&#39;}};\ \overline{T_5} \leftarrow g^{\widetilde r} \widetilde h^{\widetilde{o&#39;}};\]</span></p><p><span class="math display">\[\tag{4.16}    \overline{T_6}\leftarrow D^{\widetilde{r&#39;&#39;}}g^{-\widetilde{m&#39;}}\widetilde h^{-\widetilde{t&#39;}};\ \overline{T_7}\leftarrow e(pk\cdot \mathcal G,\widehat h)^{\widetilde{r&#39;&#39;}}\cdot e(\widetilde h,\widehat h)^{-\widetilde{m&#39;}}\cdot e(\widetilde h,\mathcal S)^{\widetilde r};\]</span></p><p><span class="math display">\[\tag{4.17}    \overline{T_8}\leftarrow e(\widetilde h,u)^{\widetilde r}\cdot e(1/g,\widehat h)^{\widetilde{r&#39;&#39;&#39;}};\]</span></p><ul><li><p><strong>（4.2.3）</strong>Holder 给出Primary凭证有效证明：</p><ul><li><p>对于每一个凭证 <span class="math inline">\(C_p=(\{m_j\},A,e,v)\)</span> 以及Issuer的公钥 <span class="math inline">\(pk_I\leftarrow (n,S,Z,{R_i}_{1\leq i\leq l})\)</span> ：</p><ul><li><p>随机选取2128-bit随机数 <span class="math inline">\(r\)</span> ；</p></li><li><p>计算：</p><p><span class="math display">\[\tag{4.18}A&#39;\leftarrow AS^r\ (mod\ n);v&#39;\leftarrow v-e\cdot r;\]</span> 并将 <span class="math inline">\(A&#39;\)</span> 放入集合 <span class="math inline">\(\mathcal C\)</span> ；</p></li></ul></li><li><p>计算：<span class="math inline">\(e&#39;\leftarrow e-2^{596}\)</span> ；</p><ul><li><p>随机取456-bit随机数 <span class="math inline">\(\widetilde e\)</span> ，3060-bit随机数 <span class="math inline">\(\widetilde v\)</span> ；</p></li><li><p>计算以下公式，并将结果放入集合 <span class="math inline">\(\mathcal T\)</span> ； <span class="math display">\[\tag{4.19}T\leftarrow (A&#39;)^{\widetilde e}\Big(\prod_{j\in \mathcal A_{\overline r}}R_j^{\widetilde{m_j}}\Big)(S^{\widetilde v})\ (mod\ n)\]</span></p></li></ul></li><li><p>对于每一个断言 <span class="math inline">\(p\)</span> ，其操作符 <span class="math inline">\(*\)</span> 都是 <span class="math inline">\(&gt;,\geq, &lt;,\leq\)</span> 其中之一</p><ul><li><p>计算 <span class="math inline">\(\Delta\)</span> ： <span class="math display">\[\tag{4.20}\Delta \leftarrow \begin{cases}z_j-m_j; &amp;\text{if } * \equiv\ \leq\\z_j-m_j-1; &amp;\text{if } * \equiv\ &lt;\\m_j-z_j; &amp;\text{if } * \equiv\ \geq\\m_j-z_j-1; &amp;\text{if } * \equiv\ &gt;\end{cases}\]</span></p></li><li><p>计算 <span class="math inline">\(a\)</span> ：</p><p><span class="math display">\[\tag{4.21}a\leftarrow \begin{cases} -1 &amp;\text{if } * \equiv\ \leq\ or\ &lt;\\ 1 &amp;\text{if } * \equiv\ \geq\ or\ &gt; \end{cases}\]</span></p></li></ul></li><li><p>寻找四个值<span class="math inline">\(u_1,u_2,u_3,u_4\)</span>符合以下等式： <span class="math display">\[\tag{4.22}\Delta =(u_1)^2+(u_2)^2+(u_3)^2+(u_4)^2\]</span></p><ul><li>随机取2128-bit随机数 <span class="math inline">\(r_1,r_2,r_3,r_4,r_{\Delta}\)</span> ；</li></ul></li><li><p>计算以下公式，并将结果按顺序放入集合 <span class="math inline">\(\mathcal C\)</span> ：</p><p><span class="math display">\[\tag{4.23}\{T_i\leftarrow Z^{u_i}S^{r_i}\ (mod\ n)\}_{1\le i\le 4};\]</span> <span class="math display">\[\tag{4.24}T_\Delta \leftarrow Z^\Delta S^{r_\Delta}\ (mod\ n);\]</span></p></li><li><p>随机取592-bit数 <span class="math inline">\(\widetilde{u_i}, 1\le i \le 4\)</span> ；</p><ul><li><p>随机取672-bit数 <span class="math inline">\(\widetilde{r_i}, 1\le i \le 4, \widetilde{r_\Delta}\)</span> ；</p></li><li><p>随机取2787-bit随机数 <span class="math inline">\(\widetilde{\alpha}\)</span> ；</p></li><li><p>计算以下公式，并将值按顺序放入集合 <span class="math inline">\(\mathcal T\)</span> ：</p></li></ul><p><span class="math display">\[  \tag{4.25}\{\overline{T_i}\leftarrow Z^{\widetilde{u_i}}S^{\widetilde{r_i}}\ (mod\ n)\}_{1\le i\le 4} ;  \]</span> <span class="math display">\[  \tag{4.26}\overline{T_\Delta}\leftarrow Z^{\widetilde{m_j}}S^{a\widetilde{r_\Delta}}\ (mod\ n);  \]</span> <span class="math display">\[  \tag{4.27}Q\leftarrow (S^{\widetilde{\alpha}}\prod_{i=1}^4 T_i^{\widetilde{u_i}}\ (mod\ n));  \]</span></p></li></ul></li></ul><h5 id="holder计算哈希向verifier提出挑战">4.2.1 Holder计算哈希，向Verifier提出挑战</h5><p>计算：<span class="math inline">\(c_H\leftarrow H(\mathcal T,\mathcal C,n_2)\)</span> ，并将其发给Verifier；</p><h5 id="最终披露">4.2.2 最终披露</h5><p>Holder进行最终的披露:</p><ul><li><strong>（4.2.2.1）</strong>对于Non-Revcation Credential：对参数 <span class="math inline">\(\rho, o,c,o&#39;,m,m&#39;,t,t&#39;,m_2,s,r,r&#39;,r&#39;&#39;,r&#39;&#39;&#39;\)</span> 都进行盲化处理，处理方法类似于下面的公式： <span class="math display">\[\tag{4.28}\widehat \rho \leftarrow \widetilde{\rho} -c_H\rho\ (mod\ q)\]</span></li></ul><p>最终得出<span class="math inline">\(\widehat\rho,\widehat o,\widehat c,\widehat{o&#39;},\widehat m,\widehat{m&#39;},\widehat t,\widehat {t&#39;},\widehat{m_2},\widehat s,\widehat r,\widehat {r&#39;},\widehat{r&#39;&#39;},\widehat{r&#39;&#39;&#39;}\)</span> 并将结果放入集合 <span class="math inline">\(\mathcal X\)</span> ；</p><ul><li><p><strong>（4.2.2.2）</strong>对于Primary 凭证 <span class="math inline">\(C_p=(\{m_j\},A,e,v)\)</span> 计算： <span class="math display">\[\tag{4.29}\widehat e\leftarrow \widetilde e+c_He&#39;;\]</span> <span class="math display">\[\tag{4.30}\widehat v\leftarrow \widetilde v+c_Hv&#39;;\]</span> <span class="math display">\[\tag{4.31}\{\widehat m_j\leftarrow \widetilde{m_j}+c_Hm_j\}_{j\in \mathcal A_{\overline r}}\]</span> 最终得出 <span class="math inline">\(Pr_C=(\widehat e,\widehat v,\{\widehat{m_j}\}_{j\in \mathcal A_{\overline r}},A&#39;)\)</span> 是凭证 <span class="math inline">\(C_p\)</span> 的子证明；</p></li><li><p><strong>（4.2.2.3）</strong>对每一个断言 <span class="math inline">\(p\)</span> ，计算： <span class="math display">\[\tag{4.32}\{\widehat{u_i}\leftarrow \widetilde{u_i}+c_Hu_i\}_{1\le i\le 4};\]</span> <span class="math display">\[\tag{4.33}\{\widehat{r_i}\leftarrow \widetilde{r_i}+c_Hr_i\}_{1\le i\le 4};\]</span> <span class="math display">\[\tag{4.34}\widehat{r_\Delta}\leftarrow \widetilde{r_\Delta}+c_Hr_\Delta;\]</span> <span class="math display">\[\tag{4.35}\widehat\alpha\leftarrow \widetilde\alpha +c_H(r_\Delta-u_1r_1-u_2r_2-u_3r_3-u_4r_4);\]</span> 最终得出 <span class="math inline">\(Pr_p=(\{\widehat{u_i}\},\{\widehat{r_i}\},\widehat{r_\Delta},\widehat{\alpha},\widehat{m_j})\)</span> 是断言 <span class="math inline">\(p\)</span> 的子证明；</p></li></ul><h5 id="holder发送信息给verifier">4.2.3 Holder发送信息给Verifier</h5><p>Holder发送 <span class="math inline">\((c_H,\mathcal X,\{Pr_c\},\{Pr_p\},\mathcal C)\)</span> 给verifier。</p><h4 id="verifier验证">4.3 Verifier验证</h4><p>对于凭证对 <span class="math inline">\((C_p,C_{NR})\)</span> ，Verifier收到证明相关参数 <span class="math inline">\((c_H,\mathcal X,\{Pr_c\},\{Pr_p\},\mathcal C)\)</span></p><h5 id="非撤销检查">4.3.1 非撤销检查</h5><p>Verifier计算以下公式，并将结果放入集合 <span class="math inline">\(\widehat T\)</span> ：</p><p><span class="math display">\[\tag{4.36} \widehat{T_1}\leftarrow E^{c_H}\cdot h^{\widehat{\rho}}\widetilde h^{\widehat o};\   \widehat{T_2} \leftarrow E^{\widehat c}h^{-\widehat m}\widetilde h^{-\widehat t}\]</span></p><p><span class="math display">\[\tag{4.37}    \widehat{T_3} \leftarrow \Big(\cfrac{e(h_o\mathcal G,\widehat h)}{e(A,y)} \Big)^{c_H}\cdot e(acc_V,\widehat h)^{\widehat c}\cdot e(\widetilde h,\widehat h)^{\widehat r}\cdot e(\widetilde h,y)^{-\widehat{\rho}}\cdot e(\widetilde h,\widehat h)^{-\widehat m}\cdot e(h_1,\widehat h)^{-\widehat{m_2}}\cdot e(h_2,\widehat h)^{-\widehat s};\]</span></p><p><span class="math display">\[\tag{4.38}     \widehat{T_4}\leftarrow \Big(\cfrac{e(\mathcal G,acc_V)}{e(g,\mathcal W)z} \Big)^{c_H}\cdot e(\widetilde h,acc_V)^{\widehat r}\cdot e(1/g,\widehat h)^{\widehat {r&#39;}};\ \widehat{T_5} \leftarrow D^{c_H}\cdot g^{\widetilde r} \widetilde h^{\widetilde{o&#39;}};\]</span></p><p><span class="math display">\[\tag{4.39}    \widehat{T_6}\leftarrow D^{\widehat{r&#39;&#39;}}g^{-\widehat{m&#39;}}\widetilde h^{-\widehat{t&#39;}};\ \widehat{T_7}\leftarrow \Big(\cfrac{e(pk\cdot \mathcal G,\mathcal S)}{e(g,g&#39;)} \Big)^{c_H}\cdot e(pk\cdot \mathcal G,\widehat h)^{\widehat{r&#39;&#39;}}\cdot e(\widetilde h,\widehat h)^{-\widehat{m&#39;}}\cdot e(\widetilde h,\mathcal S)^{\widehat r};\]</span></p><p><span class="math display">\[\tag{4.40}  \widehat{T_8}\leftarrow \Big(\cfrac{e(\mathcal G,u)}{e(g,\mathcal U)} \Big)^{c_H}\cdot e(\widetilde h,u)^{\widehat r}\cdot e(1/g,\widehat h)^{\widehat{r&#39;&#39;&#39;}};\]</span></p><h5 id="验证正确性">4.3.2 验证正确性</h5><p>Verifier获取Issuer的公钥 <span class="math inline">\(pk_I\leftarrow (n,S,Z,{R_i}_{1\leq i\leq l})\)</span> 、Primary凭证的证明 <span class="math inline">\(Pr_C=(\widehat e,\widehat v,\{\widehat{m_j}\}_{j\in \mathcal A_{\overline r}},A&#39;)\)</span> ，并使用已披露属性 <span class="math inline">\(\{m_j\}_{j\in \mathcal A_r}\)</span> ，定义空集合 <span class="math inline">\(\widehat{\mathcal T}\)</span> ；</p><ul><li><p><strong>（4.3.2.1）</strong>对于每个凭证 <span class="math inline">\(C_p\)</span> 都使用其对应的子证明 <span class="math inline">\(Pr_C\)</span> 进行计算，并将其结果放入集合 <span class="math inline">\(\widehat{\mathcal T}\)</span> ： <span class="math display">\[\tag{4.41}\widehat T\leftarrow \Bigg(\cfrac{Z}{\big(\prod_{j\in \mathcal A_r}R_j^{m_j}\big)(A&#39;)^{2^{596}}} \Bigg)^{-c_H}(A&#39;)^{\widehat e}\Bigg(\prod_{j\in (\mathcal A_{\widetilde r})}R_j^{\widehat{m_j}} \Bigg)(S^{\widehat v})\ (mod\ n)\]</span></p></li><li><p><strong>（4.3.2.2）</strong>对每个断言 <span class="math inline">\(p\)</span> 进行计算：</p><ul><li>得出<span class="math inline">\(\Delta&#39;\)</span> ：</li></ul><p><span class="math display">\[\tag{4.42}\Delta&#39; \leftarrow \begin{cases}z_j; &amp;\text{if } * \equiv\ \leq\\z_j-1; &amp;\text{if } * \equiv\ &lt;\\z_j; &amp;\text{if } * \equiv\ \geq\\z_j+1; &amp;\text{if } * \equiv\ &gt;\end{cases}\]</span></p><ul><li>得出<span class="math inline">\(a\)</span> ：</li></ul><p><span class="math display">\[\tag{4.43}a\leftarrow \begin{cases} -1 &amp;\text{if } * \equiv\ \leq\ or\ &lt;\\ 1 &amp;\text{if } * \equiv\ \geq\ or\ &gt; \end{cases}\]</span></p><ul><li>使用断言子证明 <span class="math inline">\(Pr_p=(\{\widehat{u_i}\},\{\widehat{r_i}\},\widehat{r_\Delta},\widehat{\alpha},\widehat{m_j})\)</span> 以及集合 <span class="math inline">\(\mathcal C\)</span> ，进行计算： <span class="math display">\[\tag{4.44}\{\widehat{T_i}\leftarrow T_i^{-c_H}Z^{\widehat{u_i}}S^{\widehat{r_i}}\ (mod\ n)\}_{1 \le i\le 4};\]</span> <span class="math display">\[\tag{4.45}\widehat{T_\Delta}\leftarrow (T_{\Delta}^aZ^{\Delta&#39;})^{-c_H}Z^{\widehat{m_j}}S^{a\widehat{r_\Delta}}\ (mod\ n);\]</span> <span class="math display">\[\tag{4.46}\widehat{Q}\leftarrow (T_\Delta^{-c_H})\prod_{i=1}^4 T_i^{\widehat{u_i}}(S^{\widehat \alpha})\ (mod\ n);\]</span> 最终将 <span class="math inline">\(\widehat{T_1},\widehat{T_2},\widehat{T_3},\widehat{T_4},\widehat{T_{\Delta}},\widehat Q\)</span> 加入到集合 <span class="math inline">\(\widehat{\mathcal T}\)</span> ；</li></ul></li></ul><h5 id="最终的哈希比较">4.3.3 最终的哈希比较</h5><p>Verifier计算 <span class="math inline">\(\widehat{c_H}\leftarrow H(\widehat{\mathcal T},\mathcal C,n_2)\)</span> ；如果 <span class="math inline">\(c_H=\widehat{c_H}\)</span> 则验证成功，否则失败；</p><h3 id="证明">5. 证明</h3><p>欲证明 <span class="math inline">\(c_H=\widehat{c_H}\)</span> 成立，即证明 <span class="math inline">\(H(\mathcal T,\mathcal C,n_2)=H(\widehat{\mathcal T},\mathcal C,n_2)\)</span> 成立，即证明 <span class="math inline">\(\mathcal T=\widehat{\mathcal T}\)</span> ；</p><p>在 <span class="math inline">\(\mathcal T\)</span> 中，集合为： <span class="math inline">\(\{T,\{\overline {T_i}\}_{1\le i\le 4},\overline{T_{\Delta}},Q \}\)</span> ；</p><p>在 <span class="math inline">\(\widehat{\mathcal T}\)</span> 中，集合为： <span class="math inline">\(\{\widehat T,\{\widehat{T_i}\}_{1\le i\le 4},\widehat{T_\Delta},\widehat Q\}\)</span> ；</p><h4 id="证明-twidehat-t">5.1 证明 <span class="math inline">\(T=\widehat T\)</span></h4><p><span class="math inline">\(\{\widehat{T_i}= T_i^{-c_H}Z^{\widehat{u_i}}S^{\widehat{r_i}}\ (mod\ n)\}_{1 \le i\le 4};\)</span></p><p>Prover计算:</p><p><span class="math inline">\(\overline{T_1}= Z^{\widetilde{u_1}}S^{\widetilde{r_1}}\ (mod\ n)\}\)</span></p><p>Verifier计算:</p><p><span class="math inline">\(\widehat{T_1}= T_1^{-c_H}Z^{\widehat{u_1}}S^{\widehat{r_1}}\ (mod\ n)\)</span></p><p>验证过程:</p><p><span class="math inline">\(T_1= Z^{u_1}S^{r_1}\ (mod\ n)\)</span></p><p><span class="math inline">\(u_1,r_1\)</span>为随机数</p><p><span class="math inline">\(c=H(U||\widetilde U||n_0)\)</span></p><p>验证 <span class="math display">\[T\leftarrow (A&#39;)^{\widetilde e}\Big(\prod_{j\in \mathcal A_{\overline r}}R_j^{\widetilde{m_j}}\Big)(S^{\widetilde v})\ (mod\ n)\]</span> 和 <span class="math display">\[\widehat T\leftarrow \Bigg(\cfrac{Z}{\big(\prod_{j\in \mathcal A_r}R_j^{m_j}\big)(A&#39;)^{2^{596}}} \Bigg)^{-c_H}(A&#39;)^{\widehat e}\Bigg(\prod_{j\in (\mathcal A_{\widetilde r})}R_j^{\widehat{m_j}} \Bigg)(S^{\widehat v})\ (mod\ n)\]</span> <span class="math inline">\(\widetilde e\)</span>为 456bit随机数</p><p><span class="math inline">\(\widetilde v\)</span>为 3060bit随机数</p><p>随机取随机数： <span class="math inline">\(\rho,\rho&#39;,r,r&#39;,r&#39;&#39;,r&#39;&#39;&#39;,o,o&#39;\ mod\ q\)</span> ；</p><p><span class="math inline">\(\widetilde{\rho},\widetilde{o},\widetilde{o&#39;},\widetilde{c},\widetilde{m},\widetilde{m&#39;},\widetilde{t},\widetilde{t&#39;},\widetilde{m_2},\widetilde{s},\widetilde{r},\widetilde{r&#39;},\widetilde{r&#39;&#39;},\widetilde{r&#39;&#39;&#39;},mod\ q\)</span>为随机数</p><p>随机素数<span class="math inline">\(e,\ where\ 2^{596}\leqslant e \leqslant 2^{596}+2^{119}\)</span></p><p><span class="math inline">\(e&#39; \gets e-2^{596}\)</span></p><p><span class="math inline">\(\widehat e\leftarrow \widetilde e+c_He&#39;\)</span></p><p><span class="math inline">\(v_1,v_2\)</span>为2128,673bit随机数</p><p><span class="math inline">\(v=v_1+v_2\)</span></p><p><span class="math inline">\(v&#39;\gets v-e\cdot r\)</span></p><p><span class="math inline">\(\widehat v\leftarrow \widetilde v+c_Hv&#39;\)</span></p><p><span class="math inline">\(\widehat{m_j} \leftarrow \widetilde{m_j} +c_Hm_j\ (mod\ q)\)</span> <span class="math display">\[T\leftarrow (A&#39;)^{\widetilde e}\Big(\prod_{j\in \mathcal A_{\overline r}}R_j^{\widetilde{m_j}}\Big)(S^{\widetilde v})\ (mod\ n)\]</span></p><p><span class="math display">\[\Bigg(\cfrac{Z}{\big(\prod_{j\in \mathcal A_r}R_j^{m_j}\big)(A&#39;)^{2^{596}}} \Bigg)^{-c_H}(A&#39;)^{\widehat e}\Bigg(\prod_{j\in (\mathcal A_{\widetilde r})}R_j^{\widehat{m_j}} \Bigg)(S^{\widehat v})\\= \Bigg(\cfrac{Z}{\big(\prod_{j\in \mathcal A_r}R_j^{m_j}\big)(A&#39;)^{2^{596}}} \Bigg)^{-c_H}(A&#39;)^{ \widetilde e+c_He&#39;}\Bigg(\prod_{j\in (\mathcal A_{\widetilde r})}R_j^{\widetilde{m_j} +c_Hm_j} \Bigg)(S^{\widetilde v+c_Hv&#39;})\]</span></p><p>除以<span class="math inline">\(T\)</span>, 得到 <span class="math display">\[\Bigg(\cfrac{Z}{\big(\prod_{j\in \mathcal A_r}R_j^{m_j}\big)(A&#39;)^{2^{596}}} \Bigg)^{-c_H}(A&#39;)^{c_He&#39;}\Bigg(\prod_{j\in (\mathcal A_{\widetilde r})}R_j^{c_H{m_j}} \Bigg)(S^{c_Hv&#39;})\\\]</span></p><p>提取A <span class="math display">\[\Bigg(\cfrac{Z}{\big(\prod_{j\in \mathcal A_r}R_j^{m_j}\big)(A&#39;)^{2^{596}}} \Bigg)^{-c_H}(A&#39;)^{c_He&#39;}\Bigg(\prod_{j\in (\mathcal A_{\widetilde r})}R_j^{c_H{m_j}} \Bigg)(S^{c_Hv&#39;})\\=\Bigg(\cfrac{Z}{\big(\prod_{j\in \mathcal A_r}R_j^{m_j}} \Bigg)^{-c_H}(A&#39;)^{c_H(e&#39;+2^{596})}\Bigg(\prod_{j\in (\mathcal A_{\widetilde r})}R_j^{c_H{m_j}} \Bigg)(S^{c_Hv&#39;})\\=\Bigg(\cfrac{Z}{\big(\prod_{j\in \mathcal A_r}R_j^{m_j}} \Bigg)^{-c_H}(A&#39;)^{c_He}\Bigg(\prod_{j\in (\mathcal A_{\widetilde r})}R_j^{c_H{m_j}} \Bigg)(S^{c_Hv&#39;})\]</span> 提取<span class="math inline">\(\prod\)</span> <span class="math display">\[Z^{-c_H}(A&#39;)^{c_He}(S^{c_Hv&#39;})\Bigg(\prod_{j\in (\mathcal A_{r})}R_j^{c_H{m_j}}\Bigg)\Bigg(\prod_{j\in (\mathcal A_{\widetilde r})}R_j^{c_Hm_j}\Bigg)\]</span> <span class="math display">\[= Z^{-c_H}(A&#39;)^{c_He}(S^{c_Hv&#39;})\Bigg(\prod_{j\in \mathcal A}R_j^{c_H{m_j}}\Bigg)\]</span> <span class="math display">\[=Z^{-c_H}(A&#39;)^{c_He}(S^{c_Hv&#39;})\Bigg(\prod_{j\in \mathcal A}R_j^{c_H{m_j}}\Bigg)\]</span> <span class="math inline">\(Z=S^{x_Z}\)</span></p><p><span class="math inline">\(A&#39;=AS^r\)</span></p><p><span class="math inline">\(A_c+A_k=A\)</span></p><p><span class="math inline">\(A_r+A_\widetilde {r} =A\)</span></p><p><span class="math inline">\(A\)</span>表示所有属性</p><p><span class="math inline">\(Q\leftarrow \cfrac{Z}{US^{v_2}\prod_{i\in A_k}R_i^{m_i}(mod\ n)}\\\)</span></p><p><span class="math inline">\(U=(S^{v_1})\prod_{i\in A_c}R_i^{m_i}\)</span></p><p><span class="math inline">\(A\leftarrow Q^{e^{-1} (mod\ p&#39;q&#39;)}(mod\ n)\)</span></p><p><span class="math display">\[Z^{-c_H}(A&#39;)^{c_He}(S^{c_Hv&#39;})\\=Z^{-c_H}S^{rc_He}(\cfrac{Z}{US^{v_2}\prod_{i\in A_k}R_i^{m_i}(mod\ n)})^{c_He\cdot e^{-1}}(S^{c_Hv&#39;})\\=S^{rc_He+c_Hv&#39;}((S^{v_1+v_2})\prod_{i\in A_c}R_i^{m_i}\prod_{i\in A_k}R_i^{m_i}(mod\ n))^{-c_H}\\=S^{rc_He+c_H(v-er)-c_Hv}\prod_{i\in A_c}R_i^{m_i}\prod_{i\in A_k}R_i^{m_i}(mod\ n))^{-c_H}\\= (\prod_{i\in A_c}R_i^{m_i}\prod_{i\in A_k}R_i^{m_i}(mod\ n)))^{-c_H}\\= \Bigg(\prod_{j\in \mathcal A}R_j^{-c_H{m_j}}\Bigg)\]</span> 连乘公式左右为披露属性和未披露属性：</p><p><span class="math inline">\(R_i= S^{x_{R_i}}\)</span></p><p>即： <span class="math display">\[\Bigg(\prod_{j\in \mathcal A}R_j^{-c_H{m_j}}\Bigg)\cdot \Bigg(\prod_{j\in \mathcal A}R_j^{c_H{m_j}}\Bigg) =1\]</span></p><p>证毕。</p><h4 id="证明-overlinet_deltawidehatt_delta">5.2 证明 <span class="math inline">\(\overline{T_\Delta}=\widehat{T_\Delta}\)</span></h4><p><span class="math display">\[\overline{T_\Delta}\leftarrow Z^{\widetilde{m_j}}S^{a\widetilde{r_\Delta}}\ (mod\ n);\\\widehat{T_\Delta}\leftarrow (T_{\Delta}^aZ^{\Delta&#39;})^{-c_H}Z^{\widehat{m_j}}S^{a\widehat{r_\Delta}}\ (mod\ n);\]</span></p><p>其中： <span class="math display">\[T_\Delta=Z^{\Delta}S^{r_\Delta}\\\widehat{m_j}=\widetilde{m_j}+c_Hm_j\\\widehat{r_\Delta}\leftarrow \widetilde{r_\Delta}+c_Hr_\Delta;\\\]</span> 所以有： <span class="math display">\[\Large\begin{aligned}\widehat{T_\Delta}&amp;=(Z^{\Delta a} S^{ar_\Delta}\cdot Z^{\Delta &#39;})^{-c_H}\cdot Z^{\widetilde{m_j}+c_H m_j}\cdot S^{a(\widetilde{r_\Delta}+c_H r_\Delta)}\\&amp;=Z^{-\Delta a c_H} S^{-c_Har_\Delta}\cdot Z^{-c_H\Delta &#39;}\cdot Z^{\widetilde{m_j}+c_H m_j}\cdot S^{a\widetilde{r_\Delta}+ac_H r_\Delta}\\&amp;=Z^{\widetilde{m_j}}Z^{c_H(m_j-a\Delta-\Delta&#39;)}\cdot S^{a\widetilde {r_\Delta}}\end{aligned}\]</span> 再根据： <span class="math display">\[\Delta \leftarrow \begin{cases}z_j-m_j; &amp;\text{if } * \equiv\ \leq\\z_j-m_j-1; &amp;\text{if } * \equiv\ &lt;\\m_j-z_j; &amp;\text{if } * \equiv\ \geq\\m_j-z_j-1; &amp;\text{if } * \equiv\ &gt;\end{cases}\\\Delta&#39; \leftarrow \begin{cases}z_j; &amp;\text{if } * \equiv\ \leq\\z_j-1; &amp;\text{if } * \equiv\ &lt;\\z_j; &amp;\text{if } * \equiv\ \geq\\z_j+1; &amp;\text{if } * \equiv\ &gt;\end{cases}\\a\leftarrow \begin{cases} -1 &amp;\text{if } * \equiv\ \leq\ or\ &lt;\\ 1 &amp;\text{if } * \equiv\ \geq\ or\ &gt; \end{cases}\]</span></p><p>假设这里的原属性值是 <code>20</code> ，待检测基准值 <code>18</code> ，那么 Verifier是检测 <span class="math inline">\(&gt;\)</span> 关系，检测原属性值是大于基准值的，所以有： <span class="math display">\[\begin{aligned}\Delta &amp;\leftarrow m_j-z_j-1\\&amp;\leftarrow 20-18-1\\&amp;\leftarrow 1\\a &amp;\leftarrow 1\\\Delta&#39;&amp;\leftarrow z_j+1\\&amp;\leftarrow 18+1\\&amp;\leftarrow 19\end{aligned}\]</span> 所以可得： <span class="math display">\[m_j-a\Delta-\Delta&#39;=20-1-19=0\]</span> 所以上式可得： <span class="math display">\[\begin{aligned}\widehat{T_\Delta}&amp;=Z^{\widetilde{m_j}}Z^{c_H(m_j-a\Delta-\Delta&#39;)}\cdot S^{a\widetilde {r_\Delta}}\\&amp;=Z^{\widetilde{m_j}}Z^{c_H(0)}\cdot S^{a\widetilde {r_\Delta}}\\&amp;=Z^{\widetilde{m_j}}S^{a\widetilde{r_\Delta}}\\&amp;=\overline{T_\Delta}\end{aligned}\]</span></p><p>证毕。</p>]]>
    </content>


    <categories>

      <category> 区块链项目 </category>

    </categories>


    <tags>

      <tag> Identity </tag>

      <tag> Hyperledger </tag>

      <tag> Zero-Knowledge Prove </tag>

    </tags>

  </entry>


  <entry>
    <title>Mathematics in Cryptography</title>
    <link href="/2019/08/11/Mathematics-in-Cryptography/" />
    <url>/2019/08/11/Mathematics-in-Cryptography/</url>

    <content type="html">
      <![CDATA[<p>原作时间：2018年3月31日</p><h2 id="密码学中的离散数学知识学习">密码学中的离散数学知识学习</h2><p>密码学中的近世代数实在是让人头疼,在实际阅读文章中很吃力,于是决心下点苦工补一补代数的知识。(本科有学习过离散数学，终于还是吃了数学的亏。谁要是再说学数学没用我就*@$%!)</p><p>首先是学习这篇<a href="https://blog.csdn.net/qmickecs/article/details/77281602" target="_blank" rel="noopener">文章</a>里的知识点,和之前学习过的离散数学无异，但是这篇文章好就好在了深度展开了许多知识点，并用较为简洁的例子讲解。但是呢，有点不足的是，因为代数系统他是一环扣一环的，有很强的迭代,往往会让人拎不清谁是谁。本文引用这篇文章就想能更加拎清楚概念。</p><a id="more"></a><h2 id="离散数学基础">离散数学基础</h2><h3 id="二次关系">二次关系</h3><p>一些其他的二次关系就暂且不提，只说一些与密码学相关的.</p><p>二次关系的一些性质:(其中，A是集合，R是集合中的关系)</p><table><colgroup><col style="width: 3%"><col style="width: 12%"><col style="width: 14%"><col style="width: 18%"><col style="width: 20%"><col style="width: 28%"></colgroup><thead><tr class="header"><th>-</th><th>自反性</th><th>反自反性</th><th>对称性</th><th>反对称性</th><th>传递性</th></tr></thead><tbody><tr class="odd"><td>定义</td><td>X∈A,有(x,x)∈R</td><td>x∈A,有(x,x)不∈R</td><td>若(x,y)∈R,则(y,x)∈R</td><td>若(x,y)∈R,则(y,x)不∈R</td><td>若(x,y)∈R,且(y,z)∈R,则(x,z)∈R</td></tr></tbody></table><p><strong>等价关系和偏序关系</strong></p><blockquote><p>等价关系: R是非空集A的关系,如果R是 <em>自反,对称,传递</em> 的,则称R为A上的等价关系. 举个栗子: 在实数集合中，等号'='就是一个等价关系.假设a=b=c=1; a,b,c都∈实数R;符合自反性:a=b; 符合对称性:a=b则b=a;符合传递性:a=b且b=c,则a=c;</p><p>偏序关系: R是非空集A的关系,如果R是 <em>自反,反对称,传递</em> 的,则称R为A上的偏序关系. 举个栗子: 在实数集合中，大等于号'≥'就是一个偏序关系。假设a≥b≥c; a,b,c都∈实数R; 符合自反性: a≥a; 符合反对称性: a≥b 则 b不≥a; 符合传递性: a≥b且b≥c,则a≥c; 若集合S上定义了一个偏序R,则S成为 <strong>偏序集</strong> (S,R) 设有偏序集(S,≤)，(note:偏序关系'≤'并非实数的小等于)</p><ol type="1"><li>若有任意x∈S,且b≤x,则称b为S的 <strong>下界</strong> ;</li><li>若有任意x∈S,且x≤b,则称b为S的 <strong>上界</strong> ;</li><li>若b是一个下界,且对于每一个S的下界b'都有b'≤b,则b是S的 <strong>最大下界或下确界</strong> .</li><li>若b是一个下界,且对于每一个S的下界b'都有b≤b',则b是S的 <strong>最小上界或上确界</strong> . (Note: 上界和下界有可能不唯一)</li></ol></blockquote><hr><h3 id="二元运算及其性质">二元运算及其性质</h3><p>代数中的二元运算的内容和小学学过的乘法结合律,交换了,幂等律差不多,所以不再详细说. 主要介绍幺元,零元,逆元的定义。(假设*是集合S中的二元运算)</p><ol type="1"><li><strong>幺元</strong> : 若存在元素e∈S,使任何x∈S,有 <code>e*x=x，x*e=x</code> 则,e是集合S中关于*运算的幺元。就像1在实数集合关于×运算的幺元。</li><li><strong>零元</strong> : 若存在元素θ∈S,使任何x∈S,有 <code>θ*x=θ，x*θ=θ</code> 则,θ是集合S中关于*运算的零元。就像0在实数集合关于+运算的零元。</li><li><strong>逆元</strong> : e∈S是运算*的幺元，对任意x∈S,若存在y∈S,且 <code>y*x=e，x*y=e</code> 则,y是x的逆元。就像所有实数(除0之外)在实数集合中的倒数,相乘都等于关于×运算幺元1,这些相应的倒数就是这些实数的逆元。</li></ol><hr><h3 id="典型代数系统">典型代数系统</h3><h4 id="半群">半群</h4><p>在一个集合S中定义了某种运算（记作加法“+”，但这个加法指代广泛意义上的运算，并不是指日常使用的加法），那么在这个集合上，如果这种运算满足以下性质，那么他和集合S共同组成一个半群，记作(S,+)：</p><blockquote><p>封闭性。也就是运算的结果始终在集合S内</p><p>结合律。也就是满足：<em>(a + b) + c= a + (b + c)</em></p></blockquote><p>举例: 在实数集合R中,加法'+'符合封闭性:加法运算的所有结果都是实数; 符合结合律; 所以(R,+)形成半群。</p><h4 id="幺半群">幺半群</h4><p>如果在一个半群(S,+)中存在一个幺元e,使得任意x∈S都有:</p><blockquote><p><em>x + e = e + x = x</em></p></blockquote><p>那么该半群就是一个幺半群.</p><p>举例: 在刚才例子中的半群(R,+)中,存在一个幺元0,使得任意x∈R都有 x + 0 = 0 + x = x.</p><h4 id="群">群</h4><p>如果在一个幺半群(S,+)中，任意元素x∈S,都存在唯一对应元素y使得:</p><blockquote><p><em>x + y = y + x = e</em> ， 其中e是幺元 即: 任意元素x∈S,都存在唯一逆元与之对应.</p><p>那么该幺半群就是一个 <strong>群</strong>。这样就在群中定义了减法.</p></blockquote><h4 id="交换群abel群">交换群(Abel群)</h4><p>如果一个群(S,+)符合交换律，即对于集合S中任意元素x,y∈S,有:</p><blockquote><p><em>x+y=y+x</em></p></blockquote><p>那么这个群就是交换群.</p><p>来总结一下刚才所提到的群概念的迭代:</p><table><thead><tr class="header"><th>-</th><th>半群</th><th>幺半群</th><th>群</th><th>交换群</th></tr></thead><tbody><tr class="odd"><td>性质</td><td>封闭性,结合律</td><td>封闭性,结合律,存在幺元</td><td>封闭性,结合律,存在幺元,存在逆元</td><td>封闭性,结合律,存在幺元,存在逆元,交换律</td></tr><tr class="even"><td>迭代</td><td>+封闭性,结合律</td><td>+存在幺元</td><td>+存在逆元</td><td>+交换律</td></tr></tbody></table><h4 id="环">环</h4><p>设 (S,+,<em>)是一个代数系统,其中S为集合，+,</em>是二元运算。若有:</p><blockquote><p>1。(S,+)是Abel群(交换群)。(结合律,交换律,存在幺元和逆元) 2。(S,<em>)是半群。 (结合律) 3。二元运算</em>对于+适合分配律.</p></blockquote><p>则(S,+,*)是一个 <strong>环</strong> .且群(S,+)中的 <strong>幺元</strong> 是环(S,+,*)的 <strong>零元</strong> . 举例:在实数集合中,(R,+)是个交换群,(R,×)是半群,且加法和乘法符合分配律,所以(R,+,×)是一个环.</p><p><em>零因子</em> : 若在环(S,+,*)中,且该环零元为θ,存在a,b∈S,且a!=θ,b!=θ,但有a*b=θ,则称a为S中的左零因子,b为S中的右零因子.</p><h4 id="整环">整环</h4><blockquote><p>若环(S,+,*)中(S,*)半群 符合交换律,且存在幺元,且无零因子,那么该环就称为整环.</p></blockquote><p>例如 整数环(R,+,×)就是整环.</p><h4 id="除环">除环</h4><blockquote><p>若环(S,+,*)中(S,*)半群存在幺元,无零因子,且对任意x∈S,都存在除 <em>零元</em> 以外的逆元,那么该环就成为除环</p></blockquote><p>除环定义了乘法逆元的存在,也就是除法.</p><h4 id="交换环">交换环</h4><blockquote><p>若环(S,+,*)中(S,*)满足交换律,那么环(S,+,*)是 <strong>交换环</strong>.</p></blockquote><p>来总结一下刚才所提到的环概念的迭代: (其中环都表示为(S,+,*))</p><table><colgroup><col style="width: 2%"><col style="width: 19%"><col style="width: 21%"><col style="width: 26%"><col style="width: 30%"></colgroup><thead><tr class="header"><th>-</th><th>环</th><th>交换环</th><th>整环</th><th>除环</th></tr></thead><tbody><tr class="odd"><td>定义</td><td>(S,+)是交换群,(S,*)是半群,符合分配律</td><td>(S,+)是交换群,(S,*)是交换半群,符合分配律</td><td>(S,+)是交换群,(S,*)是幺半群且符合交换律,符合分配律</td><td>(S,+)是交换群,(S,*)是幺半群且有逆元(<em>零元以外</em>),符合分配律</td></tr><tr class="even"><td>迭代</td><td>(S,+)交换群,(S,*)半群</td><td>(S,*)+交换律</td><td>(S,*) +有幺元,无零因子,符合交换律</td><td>(S,*)+有幺元,有逆元,无零因子</td></tr></tbody></table><h4 id="域">域</h4><blockquote><p>如果一个环(S,+,*),既是除环又是交换环,那么它就是一个域.</p></blockquote><p>例如:(R,+,*)既是除环又是交换环,所以它是一个域,成为 <strong>实数域</strong>.</p><h4 id="格">格</h4><blockquote><p>设(S,R)是 <strong>偏序集</strong> ,若有任意x,y∈S,{x,y}都有最小上界和最大下界,则称S关于偏序R构成一个格.</p></blockquote><hr><h3 id="有限域">有限域</h3><p>如果一个域的元素是有限的，那么就是一个有限域。相对地,无限域犹如实数域一样,元素个数是无限的.</p><p>有限域中的元素个数被称为有限域的 <strong>阶(Order)</strong>.有限域的阶一定是某个素数p的正整数次幂.</p><h4 id="模p的有限域-gfp">模p的有限域 GF(p)</h4><p>GF(p)是定义在整数集合{0,1,...,p-1}上的域。GF(p)上的加法和乘法分别是模加法和模乘法.</p><ol type="1"><li><strong>加法和乘法</strong> .(br) 模加法和模乘法和普通的整数加法和乘法有些不同.例如在GF(7)定义在{1,2,..6}上,加法和乘法如下:(br)</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 + 2 = 3 mod 7 = 3</span><br><span class="line">1 * 2 = 2 mod 7 = 2</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li><strong>减法</strong> (br) a减去b,其实就是加上b的加法逆元。已知GF(7)的加法幺元是0,于是x的加法逆元y就有:( x + y ) mod 7 = 0;</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 - 2 = 1 + ( -2 ) = 1 + 5 = 6 mod 7 = 6    or</span><br><span class="line">1 - 2 = -1 mod 7 = 6</span><br></pre></td></tr></table></figure><ol start="3" type="1"><li><strong>除法</strong> (br) a除以b,需要找到b的乘法逆元，已知GF(7)的乘法幺元是1,于是x的乘法逆元就有:</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x * y mod 7 = 1</span><br><span class="line">也就是解下面这个方程:</span><br><span class="line">b * x = 1 + 7*k ,其中k是正整数.</span><br></pre></td></tr></table></figure><p>实际求解过程并不简单,直接上实例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">3 ÷ 4</span><br><span class="line">= 3 * (1/4)</span><br><span class="line">= 3 * 2</span><br><span class="line">= 6 mod 7</span><br><span class="line">= 6;</span><br></pre></td></tr></table></figure><h4 id="有限域gf2m">有限域GF(2^m)</h4><p>在里德-所罗门编码(二维码使用的编码)以及椭圆曲线加密中都有使用。</p><p>GF(2<sup>m)包含了2</sup>m个元素。因为计算机的二进制所以选用2这个质数。2<sup>m个元素恰好是长度为m的二进制.具有更高的计算效率。 为了方便,之后都将GF(2</sup>m)中的元素表示成长度为m的二进制形式,以m=3为例。</p><ol type="1"><li><strong>加法和减法</strong> (br) GF(2<sup>m)上的加法减法都是异或运算。加法的幺元是0.(br) 010和110都是GF(2</sup>3)的元素,有:</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">010 + 110 = 010 ⊕ 110 = 100</span><br><span class="line">010 - 110 = 010 ⊕ 110 = 100</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li><strong>乘法</strong> (br)太繁琐了,就不认真写了.看这<a href="https://blog.csdn.net/qmickecs/article/details/77281602" target="_blank" rel="noopener">链接</a>.</li></ol><hr><p>因为之前学习ABE的构造加密策略的时候遇到了一些问题，例如LSSS的原理，拉格朗日多项式插值,双线性配对，DH密钥交换等问题。 需要进一步deep dive。</p><h2 id="lsss原理学习">LSSS原理学习</h2><p>这一篇<a href="https://zhuanlan.zhihu.com/p/21664741" target="_blank" rel="noopener">博客</a>从访问控制树开始说起，再到SSS密码分享方案，说得很详细。 所以我就以这篇博客为范本开始学习LSSS。</p><p>控制树就不说了，之前的学习有详细描述。</p><p>2008年RSA的S，Shamir提出来一种 <strong>秘密分享方案SSS(secret sharing scheme)</strong>。</p><blockquote><p>Shamir秘密分享方案利用了 <strong>拉格朗日多项式插值方法</strong>,其基本思想是:如果预先定义了一个t-1阶的多项式,那么如果知道这个多项式上的t个点,则一定能完整恢复出这个多项式.</p></blockquote><p>这个拉格朗日多项式插值法在之前的学习有学习到。在这个<a href="https://www.zhihu.com/question/58333118/answer/262507694" target="_blank" rel="noopener">知乎@马同学的回答</a>上有很详细很有趣的解说。 于是有拉格朗日多项式插值:</p><p><span class="math inline">\(\Large L(x):= \sum_{j=0}^{k}y_i\ell_j(x)\)</span></p><p>其中 <span class="math inline">\(\Large \ell_j(x):=\prod_{i=0,i\ne j}^{k}\frac{x-x_i}{x_j-x_i}\)</span></p><p>拉格朗日多项式插值法如何运用在秘密的分享上? 假设有t-1阶的多项式, 如果有t个线性无关的等式就肯定可以还原出这个多项式.</p><p>所以假设所要分享的秘密是S, 任取t-1个随机数 <span class="math inline">\(a_1,a_2,..,a_{t-1}\)</span> 构造一个t-1阶多项式: <span class="math inline">\(f(x)=a_{t-1}x^{t-1}+a_{t-2}x^{t-2}+...+a_1x+S\)</span>. 对于每个用户i, 所分享的结果为 <span class="math inline">\((i,f(i))\)</span> 所以当t个用户在场时,可以得到秘密S.</p><h3 id="线性秘密分享方案linear-secret-sharing-schemelsss">线性秘密分享方案(Linear Secret Sharing Scheme,LSSS)</h3><p>只要是线性的秘密分享方案, 都可以用LSSS来描述.</p><blockquote><p>A secret sharing scheme <span class="math inline">\(Π\)</span> over a set of parties <span class="math inline">\(P\)</span> is called linear (over <span class="math inline">\(\mathbb{Z}_p\)</span>) if</p><ol type="1"><li>the shares for each party form a vector over <span class="math inline">\(\mathbb{Z}_p\)</span>, and</li><li>there exists a matrix <span class="math inline">\(M\)</span> called the share-generating matrix for <span class="math inline">\(Π\)</span>. The matrix <span class="math inline">\(M\)</span> has <span class="math inline">\(m\)</span> rows and <span class="math inline">\(d\)</span> columns. For <span class="math inline">\(i = 1, . . . , m\)</span>, the <span class="math inline">\(i^{th}\)</span> row <span class="math inline">\(M_i\)</span> of <span class="math inline">\(M\)</span> is labeled by a party <span class="math inline">\(ρ(i)\)</span> where <span class="math inline">\(ρ\)</span> is a function from <span class="math inline">\(\{1, . . . , m\}\)</span> to <span class="math inline">\(P\)</span>. Given a column vector <span class="math inline">\(\vec{v} = (s, r_2, . . , r_d)\)</span>, where <span class="math inline">\(s ∈ \mathbb{Z}_p\)</span> is the secret to be shared and <span class="math inline">\(r_2, . . . , r_d ∈ \mathbb{Z}_p\)</span> are randomly chosen, <span class="math inline">\(M\vec v\)</span> is the vector of <span class="math inline">\(m\)</span> shares of the secret <span class="math inline">\(s\)</span> according to <span class="math inline">\(Π\)</span>. The share <span class="math inline">\(λ_i = (M\vec v)_i\)</span>, i.e., the inner product <span class="math inline">\(M_i · \vec v\)</span>, belongs to party <span class="math inline">\(ρ(i)\)</span>.</li></ol></blockquote><p>通过这个定义可以知道，一个秘密分享方案要被称作线性的需要符合如下:</p><ol type="1"><li>每一个成员的份额通过 <span class="math inline">\(\mathbb{Z}_p\)</span> 形成一个向量，且</li><li>存在一个分享生成矩阵 <span class="math inline">\(M\)</span>，矩阵的每一行都依次被一个成员所标记。 有一个向量 <span class="math inline">\(\vec{v} = (s, r_2, . . , r_d)\)</span>, s是需要分享的秘密, <span class="math inline">\(r_2, . . , r_d\)</span> 是在 <span class="math inline">\(\mathbb{Z}_p\)</span> 中随机选择的. 第i个成员所拥有的分享份额就是: <span class="math inline">\(M_i · \vec v\)</span>. M的第i行和这一列的积(结果还是一个向量).</li></ol><blockquote><p>Any LSSS defined as above enjoys the linear reconstruction property defined as follows. Suppose that <span class="math inline">\(\Pi\)</span> is an LSSS for access structure <span class="math inline">\(\mathbb{A}\)</span>. Let <span class="math inline">\(S \in \mathbb{A}\)</span> be an authorized set, and <span class="math inline">\(I \subset \{1, \ldots, m\}\)</span> be defined as <span class="math inline">\(I = \{i: \rho(i) \in S\}\)</span>. There exist constants <span class="math inline">\(\{\omega_i \in \mathbb{Z}_p\}_{i \in I}\)</span> satisfying <span class="math inline">\(\sum_{i \in I}{\omega_i M_i} = (1, 0, \ldots, 0)\)</span> , so that if <span class="math inline">\(\{\lambda_i\}\)</span> are valid shares of any secret s according to <span class="math inline">\(\Pi\)</span>, then <span class="math inline">\(\sum_{i \in I}{\omega_i \lambda_i} = s\)</span> . Furthermore, these constants <span class="math inline">\(\{\omega_i\}\)</span> can be found in time polynomial in the size of the share-generating matrix M. For any unauthorized set, no such constants exists. The LSSS is denoted by <span class="math inline">\((M, \rho)\)</span>.</p></blockquote><p>上面所定义的LSSS有如下定义的线性重建属性. 假设在一个访问结构A中, I为分享组的所有成员. 对于每个分享组成员 i 总在p阶整数域内存在一个常数 <span class="math inline">\(\omega_i\)</span> ,满足 <span class="math inline">\(\sum_{i \in I}{\omega_i M_i} = (1, 0, \ldots, 0)\)</span>, 即对于每个合法分享成员所持有的秘密 <span class="math inline">\(\lambda_i\)</span> 总有 <span class="math inline">\(\sum_{i \in I}{\omega_i \lambda_i} = s\)</span> 得出最终秘密s. 所以这个常数的求解就是LSSS的解密关键.</p><h4 id="求解常数-omega">求解常数 <span class="math inline">\(\omega\)</span></h4><ol type="1"><li>从定义可知 <span class="math inline">\(\vec \lambda = M \cdot \vec v\)</span> ,M为分享生成矩阵,向量 <span class="math inline">\(\vec{v} = (s, r_2, . . , r_d)\)</span>,恢复出向量v的第一项S,也就是所要求的秘密. 因为矩阵M并不是一个方阵, 不存在它的逆矩阵, 所以想到使用M的某个子阵求逆.(博客原话,需要进一步推敲为什么.)</li><li>矩阵M的列d代表着至少需要d方参与才能恢复. 但是并不是属性个数满足列数就能访问, 例如(A or B)and(C or D), 若属性集合是{A,B}也不能访问, 所以意味着,A和B在矩阵对应的行是重复的,可以删去. 所以我们需要在集合中找到一个子集,使得子集对应的矩阵M的行所组成的子阵满足满秩就行了.</li><li>如何找到这样的矩阵,就要用到单调访问政策的单调性了. 单调性意味着,一个属性是冗余的,那么去掉这个属性也能满足访问控制政策. 用遍历的方法,去除各个属性,就能得到一个子矩阵M',其对应的分享为 <span class="math inline">\(\vec \lambda&#39;\)</span> M'满足可逆性.</li><li><span class="math inline">\(s = (1, 0, \ldots, 0) \cdot \vec v = (1, 0, \ldots, 0) \cdot M&#39;^{-1} \vec \lambda&#39;\)</span> . 因为 <span class="math inline">\(\sum_{i \in I}{\omega_i \lambda_i} = s\)</span> 所以有 <span class="math inline">\(\vec \omega = (1, 0, \ldots, 0) \cdot \vec M&#39;^{-1}\)</span>. 这意味着不需要知道 <span class="math inline">\(\vec \lambda\)</span> 只需要知道LSSS的矩阵M,已经知道能够满足恢复S条件的属性集合就行了.</li></ol><h4 id="构造lsss矩阵">构造LSSS矩阵</h4><p>2010年, Lewko和Waters在论文<a href="https://eprint.iacr.org/2010/351" target="_blank" rel="noopener">5</a>中提到,只要是 AND和OR描述的都可以转换为LSSS方案.</p><blockquote><p>We now describe a general algorithm for converting a boolean formula into an equivalent LSSS matrix. We consider the boolean formula as an access tree, where interior nodes are AND and OR gates and the leaf nodes correspond to attributes. We will use <span class="math inline">\((1,0,\ldots,0)\)</span> as the sharing vector for the LSSS matrix. We begin by labeling the root node of the tree with the vector (1)(a vector of length 1). We then go down the levels of the tree, labeling each node with a vector determined by the vector assigned to its parent node. We maintain a global counter variable c which is initialized to 1.</p><p>If the parent node is an OR gate labeled by the vector v, then we also label its children by v (and the value of c stays the same). If the parent node is an AND gate labeled by the vector v, we pad v with 0’s at the end (if necessary) to make it of length c. Then we label one of its children with the vector <span class="math inline">\((v|1)\)</span> (where | denotes concatenation) and the other with the vector <span class="math inline">\((0,\dots, 0 | -1)\)</span>, where <span class="math inline">\((0, \ldots, 0)\)</span> denotes the zero vector of length c. Note that these two vectors sum to <span class="math inline">\((v|0)\)</span>. We now increment the value of c by 1. Once we have finished labeling the entire tree, the vectors labeling the leaf nodes form the rows of the LSSS matrix. If these vectors have different lengths, we pad the shorter ones with 0’s at the end to arrive at vectors of the same length.</p></blockquote><ol type="1"><li>将布尔表达式化为访问树, 其中内部节点是AND和OR门, 叶子节点表示为属性.</li><li>将树的根节点标记为 1,从上往下依次向每个节点根据父节点的向量添加向量.</li><li>维护一个全局变量 C ,C从1开始记.</li><li>若父节点是OR门, 且父节点被标记为v, 那么子节点也标记为v,且变量C保持不变.</li><li>若父节点是AND门,且父节点被标记为v, 那么将用'0'来填充v的尾部(如果需要的话)来保证最终长度为C.将其中一个子节点标记为向量 <span class="math inline">\(v|1\)</span> (其中'|'表示串联); 其他的子节点标记为 <span class="math inline">\((0,\dots, 0 | -1)\)</span>, 其中 <span class="math inline">\((0,\dots,0)\)</span> 表示长度为 C 的零向量. 且C+1. 这两个向量的和为 <span class="math inline">\(v|1 + (0,\dots,0)|-1=v|0\)</span>.</li><li>当我们完成了整个树的标记, 标记的叶节点就是LSSS矩阵的行. 如果这些向量有不同的长度,就在尾部用'0'来填充.</li></ol><p>不过不同的方案可以有不同的LSSS矩阵构造方案, 具体问题具体分析.</p><p>此外布尔表达式如何转化为访问树结构还需进一步学习. 这里有一些Parser源码,可以参考(<a href="https://github.com/liuweiran900217/CloudCrypto/tree/master/src/main/java/cn/edu/buaa/crypto/access/parser" target="_blank" rel="noopener">链接</a>).</p><hr><h2 id="diffie-hellman密钥交换学习">Diffie-Hellman密钥交换学习</h2><p>Diffie-Hellman密钥交换(简称DH密钥交换)是可以让对等的双方在完全缺乏对方信息的前提下, 通过不安全的信道达成一个共享的密钥.</p><p>DH密钥交换的方法是建立在计算离散对数(Discrete Logarithm Problem)的困难程度上的. 之前的学习(<a href="https://blog.csdn.net/kyon_ray/article/details/79818291" target="_blank" rel="noopener">链接</a>)有详细描述,在此就不展开探讨. 总而言之就是一个模p有限域的问题. 例如:</p><blockquote><p>若p是一个素数,g和x都是p阶域中的整数, 计算 <span class="math inline">\(y=g^x \bmod p\)</span> 很简单. 相反的, 若已知素数p,g和y,要求x满足等式 <span class="math inline">\(y=g^x \bmod p\)</span> 就是非常困难的.</p><p>当然, 基于安全性的考虑, 这里的 p通常都是很大的素数,通常取1024bit, 且(p-1)/2也是素数. G是素数p的原根(primitive root). 原根可以保证: <span class="math inline">\(g^i\bmod p\ne g^j\bmod p,\ where\ i\ne j\ and\ i,j\in (0,p-1)\)</span></p></blockquote><p>DH密钥交换具体算法如下:</p><blockquote><ul><li>Alice和Bob约定 <span class="math inline">\(p\)</span> 和 <span class="math inline">\(g\)</span> 的值</li><li>Alice生成私钥 <span class="math inline">\(x\)</span>，计算 <span class="math inline">\(g^x\bmod p\)</span> 作为公钥公布出去</li><li>Bob生成私钥 <span class="math inline">\(y\)</span>，计算 <span class="math inline">\(g^y\bmod p\)</span> 作为公钥公布出去</li><li>Alice得知 <span class="math inline">\(g^y\bmod p\)</span> 后，计算 <span class="math inline">\(s=(g^y\bmod p)^x\bmod p=(g^y)^x\bmod p=g^{xy}\bmod p\)</span></li><li>Bob得到 <span class="math inline">\(g^x\bmod p\)</span> 后，计算 <span class="math inline">\(s=(g^x\bmod p)^y\bmod p=(g^x)^y\bmod p=g^{xy}\bmod p\)</span></li><li>双方都得到了相同的密钥的 <span class="math inline">\(s\)</span>，交换完毕</li></ul></blockquote><p>在上面的流程中,私钥 <span class="math inline">\(x,y\)</span> 始终是Alice和Bob自己保管的, 窃听到的只有 <span class="math inline">\(p,g,g^x\bmod p,g^y\bmod p\)</span>. 可以保证安全性.</p><hr><h2 id="双线性配对学习">双线性配对学习</h2><p>双线性配对(Bilinear Pairing)最初在2001年由Boneh和Franklin利用它构造了第一个实用并且可证安全的基于身份的加密方案(IBE).</p><h3 id="素数阶双线性群prime-order-bilinear-groups">素数阶双线性群(Prime-Order Bilinear Groups)</h3><p>双线性配对定义了三个素数p阶群乘法循环群(有些方案是加法循环群, 例如椭圆曲线的双线性构造) <span class="math inline">\(G_1,G_2和G_T\)</span>. 并且定义了这三个群的一个配对(映射)关系 <span class="math inline">\(e:G_1×G_2→G_T\)</span> (这里的乘和矩阵的乘相似),并且满足如下性质:</p><ol type="1"><li>双线性: 对于任意 <span class="math inline">\(g_1\in G_1,g_2\in G_2,\ a,b\in Z_p\)</span> 均有 <span class="math inline">\(e(g_1^a,g_2^b)=e(g_1,g_2)^{ab}\)</span> 成立.</li><li>非退化性: <span class="math inline">\(\exists g_1 \in G_1, g_2 \in G_2\)</span>, 满足 <span class="math inline">\(e(g_1,g_2) \neq 1_{G_T}\)</span>.</li><li>可计算性: 存在有效的算法, 对于 <span class="math inline">\(\forall g_1 \in G_1, g_2 \in G_2\)</span>, 均可计算 <span class="math inline">\(e(g_1,g_2)\)</span>.</li></ol><p>若 <span class="math inline">\(G_1 = G_2\)</span> 则称上述双线性群是对称的.</p><h3 id="合数阶双线性群composite-order-bilinear-groups">合数阶双线性群(Composite-Order Bilinear Groups)</h3><p>与素数阶类似, 区别在于 <span class="math inline">\(G_1,G_2和G_T\)</span> 的介数是一个 <strong>合数</strong> ,该合数是一些很大的素数的乘积. 例如:<span class="math inline">\(N=p_1×p_2×\cdots×p_n\)</span></p><p>也满足素数阶双线性群的三个性质. 与之不同的是,合数阶双线性群中,有阶数分别为 <span class="math inline">\(p_1,p_2,\dots,p_n\)</span> 的子群 <span class="math inline">\(G_{p_1},G_{p_2},\dots,G_{p_n}\)</span>. 这些子群满足正交性. 也就是说: <span class="math inline">\(\forall g_i\in G_{p_i},\forall g_j\in G_{p_j},\ and\ i\ne j\ and\ e(g_i,g_j)=1\)</span></p><h2 id="参考文章">参考文章</h2><blockquote><ol type="1"><li><a href="https://zhuanlan.zhihu.com/p/21664741" target="_blank" rel="noopener">记线性秘密分享方案（Linear Secret Sharing Scheme，LSSS）的实现</a></li><li><a href="https://www.zhihu.com/question/58333118/answer/262507694" target="_blank" rel="noopener">如何直观地理解拉格朗日插值法？</a></li><li><a href="http://www.cnblogs.com/ECJTUACM-873284962/p/6833391.html" target="_blank" rel="noopener">拉格朗日插值法(图文详解)</a></li><li><a href="https://blog.csdn.net/ping802363/article/details/77900273" target="_blank" rel="noopener">线性秘密共享方案（LSSS）构造与解密</a></li><li>Lewko, A., Waters, B.: Decentralizing attribute-based encryption. IACR Cryptology ePrint Archive, (2010) 351. https://eprint.iacr.org/2010/351.</li><li><a href="https://blog.csdn.net/zzminer/article/details/8571289" target="_blank" rel="noopener">Diffie–Hellman 密钥交换协议简介</a></li><li><a href="https://blog.csdn.net/kyon_ray/article/details/79818291" target="_blank" rel="noopener">密码学中的离散数学知识学习</a></li><li><span class="citation" data-cites="SDKany的回答">[可以解释一下密码学中什么叫双线性配对吗？@SDKany的回答]</span><a href="https://www.zhihu.com/question/39641890/answer/82350855" target="_blank" rel="noopener">8</a></li><li><a href="https://blog.csdn.net/zhangwenjiezw886/article/details/51006774" target="_blank" rel="noopener">双线性映射（密码学常用算法）</a></li><li><a href="https://crypto.stanford.edu/pbc/" target="_blank" rel="noopener">斯坦福大学pbc库</a></li><li><a href="https://blog.csdn.net/qmickecs/article/details/77281602" target="_blank" rel="noopener">谈谈有限域那些事儿</a></li><li><a href="https://blog.csdn.net/qq_26816591/article/details/46873463" target="_blank" rel="noopener">离散数学偏序关系哈斯图上（下）确界极小（大）值最大（小）值</a></li><li><a href="http://www.wlxt.uestc.edu.cn/wlxt/ncourse/lsxx/web/lssx/end/imgs/18/ls18.1/18.1.htm" target="_blank" rel="noopener">第18章 格与布尔代数</a></li></ol></blockquote>]]>
    </content>


    <categories>

      <category> 补档 </category>

      <category> 密码学 </category>

    </categories>


    <tags>

      <tag> cryptography </tag>

      <tag> mathematics </tag>

    </tags>

  </entry>


  <entry>
    <title>IoT调研报告</title>
    <link href="/2019/07/31/IoT-research-report/" />
    <url>/2019/07/31/IoT-research-report/</url>

    <content type="html">
      <![CDATA[<h2 id="一简述">一、简述</h2><p>本文从物联网（IoT）技术的基础知识开始，主要介绍了物联网的基本定义、主要通信协议，并对现在物联网技术所面临的挑战进行了详细分析。在第三章，研究区块链与物联网结合的契合点，分析区块链是如何解决物联网现在面临的挑战，并提供一些物联网部署在区块链的方法。在第四章，从区块链在物联网中身份标识治理的角度切入，通过对比现有中心化身份管理方法，研究基于区块链的实体身份标识可以如何解决物联网相关的痛点，并给出现有案例（学术上、工业上）。</p><h2 id="二认识iot">二、认识IoT</h2><p>物联网是一个计算设备、电子器械、物体、动物或人相互关联的系统，具有唯一标识符（UID）和通过网络传输数据、交互的能力，而无需人与人或人与计算机的互动，终极梦想是万物互联的世界。</p><p>如下图所示是一个物联网系统的样例，物联网生态系统由支持Web的智能设备组成，这些设备使用嵌入式处理器，传感器和通信硬件来收集、发送和处理从环境中获取的数据。 物联网设备通过连接到物联网网关或其他边缘设备来共享它们收集的传感器数据，其中数据被发送到云以进行本地分析或分析。 尽管人们可以与设备进行交互，但设备可以完成大部分工作而无需人工干预。</p><a id="more"></a><p><img src="./example_of_iot.png"></p><h3 id="三个维度认识iot">1. “三个维度”认识IoT</h3><h4 id="横向维度---物联网产业图谱">1.1 横向维度 - 物联网产业图谱</h4><p>如下图所示，可以看到，身份管理以及安全控制贯穿整个生态架构。</p><p><img src="./iot_horrizon.png"></p><h4 id="纵向维度---物联网生态架构">1.2 纵向维度 - 物联网生态架构</h4><p>可以简单把IoT核心架构分为4层模型：</p><ul><li>应用程序层：对大量的数据进行处理、持久性存储、数据分析、数值预测；</li><li>平台服务层：主要包括数据管理、设备管理、应用集成、消息发布/订阅/传递、安全管理；</li><li>通信层：主要是支持数据的可靠传输，内置了感应层向管理控制层的通信机制，如Wifi、3G、LTE、 Ethernet等；</li><li>物理感应层：主要是设备、网关等硬件传感器和相应的传感网络；</li></ul><p><img src="./iot_arch.png"></p><h4 id="时间维度---物联网的前世今生与来世">1.3 时间维度 - 物联网的前世、今生与来世</h4><p>在过去的几年中，前物联网从封闭的集中式大型机架构逐渐向以开放接入云为中心的物联网的替代方案发展；下一步物联网将在部署在多节点的分布式云上，实现真正的万物互联，区块链技术在这里充当重要的角色。</p><p><img src="./image-20190712105542191.png"></p><p>在这里作者由于知识储备原因（<strong>学术不精</strong>），主要简单介绍通信层的内容，在本章后面的内容展开介绍物联网技术现有的挑战，并在后面的章节介绍平台服务层的相关内容。</p><h3 id="现有iot通信协议">2. 现有IoT通信协议</h3><p><img src="./protocol_for_iot.png"></p><p>如上图所示，</p><p>现有物联网中<strong>应用数据层的通信协议</strong>主要有以下几种：</p><ul><li><strong>HTTP</strong>：因为其广泛的应用，兼容稳定性都很好，开发也简单，但在物联网大规模使用的情况下，实时性和消息一致性都不如MQTT协议来的表现出色，而且耗电量更大；</li><li><strong>Message Queuing Telemetry Transport(MQTT)</strong>：MQTT协议开销较小（带宽和能耗），支持永久性连接，减少重连带来的开销，在物联网中大规模的并发连接场景具有优势；</li><li><strong>Constrained Application Protocol(CoAP)</strong>：CoAP是一种可用于资源受限的设备上的数据应用协议，支持多播和低开销在物联网小型设备使用场景较实用；</li><li><strong>Extensible Messaging and Presence Protocol (XMPP)</strong>：XMPP支持实时通讯、即时消息；</li></ul><p>在<strong>网络层的路由协议</strong>主要有 <code>6LoWPAN</code>与<code>RPL</code>，这两种协议都意在资源受限的设备上能轻松访问网络，但也将带来被攻击的可能，详情可见论文[8].</p><p>在 <strong>数据链路层的协议</strong> 一般就以频率、能耗、可用范围区分，以下图做对比总结：</p><p><img src="./IoT_Data_Layer_Protocol.png"></p><h3 id="现有iot方案存在的挑战">3. 现有IoT方案存在的挑战</h3><p>在过去的几年间，物联网垂直领域相关企业数量处于快速增长期，经过了幻想破灭期的洗礼，投资逐渐理性，技术逐渐成熟。虽然人们对于物联网可以推动许多商业机会、变革现有中心化体系有清楚的认识，但物联网还存在一系列的技术挑战，直接导致了全球物联网应用布局缓慢的局面。以下是对这些挑战的简述：</p><h4 id="网络安全问题">3.1 网络安全问题</h4><p>物联网中的网络安全问题是最关键也是最致命的应用落地门槛。对于传统的Web安全而言，物联网设备往往条件更加严苛：设备条件通常是隔离的硬件，根据其部署条件，所有者往往无法有效监测到设备数据篡改；设备往往是和其他设备进行互联，管理这些M2M的交互、保证两端数据一致性与传统的C/S交互相比更加复杂；此外，物联网设备往往处于资源受限的状态（硬件性能、网络连接、电量低等），使得更加复杂的场景不能得以应用。因此，这种系统更加容易被网络攻击，在以下列出了几种物联网攻击方法与其相应的防御手段。</p><h5 id="现存的iot攻击方法与防御手段">现存的IoT攻击方法与防御手段</h5><p>物联网涵盖了从小型嵌入式处理芯片到大型高端服务器各种设备，因此遇到的安全问题都可能在不同层次不同级别。下图给出了从OSI网络模型自下往上地分析了物联网安全威胁的分类。各个攻击方式的具体防御手段可借鉴论文[2]，在这里不赘述。</p><p><img src="./IoT%20Security%20Issues.png"></p><h4 id="访问控制与隐私保护">3.2 访问控制与隐私保护</h4><p>物联网设备每日生成大量的数据，可提供设备所有者或者用户所在的环境详细信息以及个人习惯、隐私数据。这些数据可以在没有任何明确的用户授权下收集，并有可能在某个支持IoT共享平台上暴露给第三方。更糟的情况制造商挂羊头卖狗肉，IoT设备主动收集与所提供服务无关的数据。</p><p>用户除了必须信任集中式服务提供商不会侵犯他们的隐私之外，还必须相信数据的传输具有保密性和完整性。任何不安全的数据传输都会使得恶人在未经授权的情况下窃听和收集数据。</p><h4 id="设备管理">3.3 设备管理</h4><p>“普通物联网设备管理包括设备的配置、管理、监控、对故障的诊断以及纠正措施。关键物联网设备管理主要包括设备的注册、配置、关联、软件更新、固件升级以及整体控制管理。”（<a href="https://www.i-scoop.eu/internet-of-things-guide/iot-device-management/" target="_blank" rel="noopener">链接</a>）</p><p>随着物联网的加速发展，服务提供商在满足管理要求方面遇到了一些挑战，主要包括以下两个方面：</p><ul><li>集中式设备管理的挑战：随着设备规模扩大到一定范围，当前的集中式网络管理会出现明显瓶颈，设备监控、固件升级等的维护成本大幅增加；</li><li><strong>事物身份(Identity of Things, IDoT)治理</strong>：<ul><li>物联网设备的所有权和身份关系：设备的所有权在设备的生命周期内，从制造商、供应商、零售商和消费者处发生变化；如果设备被转售、退役或销毁，需要更改或撤销消费者的IoT设备所有权；</li><li>物联网设备的属性与关系：设备的属性包括制造商、品牌、序列号等；设备关系还包括设备-人、设备-设备、设备-服务等；如何处理这些复杂的关系也是一种挑战；</li></ul></li><li>设备的访问控制：现有物联网设备访问控制都还是基于PKI体系，依赖于中心化PKI容易受到MITM（Man-In-The-Middle）攻击，CA单点故障也会带来系统加密体系全面崩盘的风险；</li><li>异构物联网设备的连通性：物联网范式需要数十亿异构设备的广泛连接，这种异构的连通性对于不同供应商开发的协议和解决方案的交互都是业界难题。</li></ul><p>论文[12]对于现有的物联网设备管理平台进行了Benchmark评估测试，并展望未来的物联网设备管理平台。</p><h4 id="规范化与协同操作">3.4 规范化与协同操作</h4><p>物联网标准由多个独立多国治理机构、联盟或组织提供支持（例如 IEEE、ETSI、IETF、W3C、OMG、OneM2M等）。这些标准涵盖了物联网产品与服务从通信技术到架构的多个方面，其中一些遵循中立的跨域方法，二其他一些仅适用于特定的垂直领域。各个标准组织还未形成统一的国际标准，各种设备编码之间相互孤立，有的甚至重复交叉。</p><p>要实现信息的互联互通和系统的有效协同，必须建立统一的物联网标识系统。建立统一的物联网标识还需兼容现有设备的异构编码标准。不同供应商设备的异构协同操作问题在2.3节已经提到。</p><h4 id="数据治理">3.5 数据治理</h4><p>物联网设备产生的巨大数据量，难以在通信/传输、存储方面进行精细的管理。可扩展的基础架构对于处理大量不断增长的数据是有必要的。</p><p>数据管理涉及在线数据的聚合，同时提供事件日志、审计和存储，从而进行查询处理和数据分析。且在数据聚合前都应该从应用中抽象出复杂的语义，未经处理的数据面临着非均匀性（non-uniformity）和弱语义。此外许多物联网应用领域对时间要求很高，因此在考虑物联网设备的受限资源能力的同时，及时处理物联网数据也非常重要。</p><p>现有的集中式方法确实效率较高，但这些方法不能同时为数据完整性提供保证，并且在处理异构数据方面存在数据孤岛等的信任问题。</p><h2 id="三iot-meets-blockchain">三、IoT Meets Blockchain</h2><p><strong>缘起</strong></p><p>物联网的目标是尽可能简化概念，使智能对象通过互联网进行通信，以收集全面的数据并提供个性化的自动化服务，几乎不需要人工干预。为此，目前的物联网平台已经建在集中式模型上，中央服务器或代理提供数据处理，设备协调和授权等服务。 这种方法需要高端服务器，并且这种方法不适用于物与物自主交换数据的场景。 在集中式模型中，集中式服务器授权对象相互通信，因此当越来越多的设备通过Internet相互通信，极大提高了服务器的门槛要求。</p><p>在认识到区块链提供的机会及其潜在影响之后，研究人员和开发人员已经开始为物联网设计分布式的解决方案。 区块链的固有特性使其天然地成为开发物联网和分布式云计算的安全分布式结构的首选。</p><h3 id="blockchain可以解决iot什么问题如何解决">1. Blockchain可以解决IoT什么问题？如何解决？</h3><h4 id="支持异构协同操作">1.1 支持异构协同操作</h4><p>目前，物联网设备和协议的异构性限制了它们的协同操作性，并且由于区块链是与语义无关的分布式数据库，因此使用区块链作为物联网的网络控制机制将为其增加更大程度的适应性。 事实证明，区块链可以在异构硬件平台上运行，基于区块链的物联网框架有望适应不同的环境和用例，以满足物联网用户不断增长的需求和需求。</p><p>此外，在区块链中可以使用智能合约、跨链等方法将不同厂商、不同协议的设备连接起来，对设备产生的事务交易等消息进行订阅/发布，并结果记录在区块链上[9]。</p><h4 id="安全与隐私保护">1.2 安全与隐私保护</h4><p>在物联网上确保隐私保密下和数据保护，大多数区块链网络都可以使用地址假名简单地保护用户隐私，且其链状结构按时间顺序连续地记录了数据，数据分布地在多个设备上记录，增加了篡改数据的成本，有效抵御DDoS等网络攻击方式。在未来的发展中，基于区块链的去中心化物联网网络消除了用户因为“互相不信任”而通过集中式的实体来处理的需要，从而防止恶意第三方实体收集用户的私人数据。</p><p><strong>如何隐私保护？</strong></p><p>通过区块链进行的所有交互都是公开可用且可验证的，因此存储在链上和链下的物联网数据通常保持加密，并且在区块链上强制执行授权访问的策略。但是由于区块链网络的可审计性需要通过公开数据访问，这也不符合隐私保护原则。所以，为了保持隐私，区块链技术本身并不充分，需要在可审计和隐私之间寻找有效的平衡。</p><p>现有在基于区块链的物联网框架中实现隐私保护的研究，包括利用智能合约执行访问策略的方案[15-16]、分层区块链架构[17]、通过假名地址更新在事务级别上提高区块链的隐私[18-19]；以及在密码学上做的改进，例如：将传感器数据通过属性加密保护隐私[20]，零知识证明[21]。</p><p><strong>如何保证安全？</strong></p><p>凭借decentralized public-key infrastructure（DPKI）、可容错设计、可审计以及内在的不受DDoS攻击等多个特性，区块链也可以保证交易网络传输安全的能力。相对于物联网现有的中心化的安全管理方法，区块链带来的技术革新会替代当前的安全方法，并为物联网提供改进的安全解决方案。</p><p>现有研究已经有一些方案，用于在不依赖第三方服务的情况下在物联网实施访问控制策略。</p><ul><li>针对PKI改进：论文[22]提出了一种基于区块链的PKI方案，相对于中心化的PKI更具有容错性；</li><li>针对架构改进：论文[23]提出了一种多层区块链框架，数据存储和数据访问在单独的层中执行：(i).分布式数据存储层，特定地址的用户可以存储物联网数据；(ii).消息层，供存储层和访问控制层进行协商访问；(iii).访问控制层，具有权限的参与者才可以解密密文；</li><li>使用Token方法：论文[24]在区块链链中存储加密数据，并使用Token和智能合约策略来允许和撤销对数据的访问。</li><li>链下存储方法：论文[25]将数据存储在链下，使用分布式哈希表进行索引，在链上存储不同角色的访问控制权限，从而达到实现访问控制的目的。</li></ul><h4 id="identity-of-things的管理">1.3 Identity of Things的管理</h4><p>区块链已被广泛用于身份授权、身份注册、所有权跟踪以及产品、商品和资产的监控。 像<a href="http://dx.doi.org/10.1016/j.future.2017.08.048" target="_blank" rel="noopener">TrustChain</a>这样的方法使用区块链来实现可信交易，同时保持分布式环境中的事务的完整性。 物联网设备也不例外。 区块链可用于物联网设备注册并提供身份，具有一组属性和复杂关系，可以上传并存储在区块链分布式分类账中。区块链还在物联网设备的供应链和生命周期的每个环节提供分布式管理、治理和追踪。</p><p>具体方案将会在第四章详细说明。</p><h4 id="提高可用性">1.4 提高可用性</h4><p>物联网代表了高可用的收集数据和提供自动功能智能设备。 物联网的网络控制机制需要高可用性，在涉及集中式服务器的体系结构中可能并非总是如此。 区块链的分布式架构，天然地容许部分节点/设备出错或掉线，也可以通过一些分布式共识协议识别故障。</p><h4 id="降低维护成本">1.5 降低维护成本</h4><p>实现物联网全球普及的一个重要步骤是找到有效且经济的方法来处理整个物联网中传感器产生的大量数据。集中式云服务因为其计算和存储的价格更低，所以替代了原有集中式服务器的模式。但是数据表明，使用基于区块链的数据存储平台（例如<a href="https://sia.tech/technology" target="_blank" rel="noopener">Sia</a>）证明了使用区块链存储数据的成本更低。Amazon S3服务器每个月存储1TB是25美元，Sia每月每TB是2美元。</p><h4 id="保证数据完整">1.6保证数据完整</h4><p>物联网应用程序要求传输和分析数据的完整性，因此物联网框架需要对数据泄漏和破坏具有弹性。 区块链网络在节点上存储冗余的副本，这有助于维护数据完整性。</p><p>在论文[5]中有张图，可以很全面的展示Blockchain-based IoT的应用。</p><p><img src="./BIoT.png"></p><h3 id="iot如何部署在blockchain上">2. IoT如何部署在Blockchain上？</h3><p>集中式的云服务在物联网的发展中作出了重要贡献，但在数据透明性方面，集中式云服务就像黑匣子一样，物联网用户无法控制和完全信任他们共享的数据。 物联网可以从区块链提供的分布式网络范例中受益，同时消除对集中式服务的信任需求。 然而，区块链仍处于研究和开发的早期阶段，集成物联网和区块链仍存在多项研究挑战。</p><p>物联网中涉及的各种各样的设备，这些设备都是资源限制的，无法托管区块链的整个副本或参与验证区块链的新块，使用区块链在物联网中实现绝对分布式是欠考虑的。 因此，重要的是决定物联网边缘中不同实体（设备，网关等）将扮演什么角色。</p><p>物联网边缘设备或网关作为简单的交易发起者（transaction-issuers）并具有可验证的区块链标识，而无需托管整个区块链副本，选取部分设备作为全节点参与共识和区块验证。以下是现研究关于如何集成区块链和物联网的一些方案：</p><ul><li><p>物联网网关设备作为区块链端点：</p><p>在这种方案中，所有通信都通过区块链，而IoT网关则作为区块链网络的端点。在这种情况下，IoT设备将注册到网关设备，并且网关向区块链发出交易。这种方法可以跟踪涉及特定物联网网关和物联网服务的所有通信。此集成方案还可用于验证连接到不同网关的设备之间的通信。在这种方法中，并非所有传输的数据都需要存储在区块链中。区块链本身可以用作控制机制，智能合约充当可编程逻辑，而数据传输可以通过P2P技术进行。</p></li></ul><p><img src="./scheme_a.png"></p><ul><li><p>设备作为区块链的交易发起者：</p><p>这种集成方案出自论文[26]，在上述的分析中，我们假设物联网设备实际上没有携带区块链的副本，而只是简单地向区块链发布交易。 与之前的方法类似，因安全考虑，所有IoT交互事件都会记录到区块链中。 在这种方法中，需要为IoT设备提供加密功能。 这种方法物联网设备和应用程序具有更高自治程度，而物联网硬件的计算复杂性增加。</p></li></ul><p><img src="./scheme_b.png"></p><ul><li><p>互联的边缘设备作为区块链的端点：</p><p>在这种方法中，物联网网关和设备向区块链发布交易，并且可以与另外的链外通信。 这种方法可确保物联网设备之间的低延迟以及在区块链上记录特定交互。 这种集成方案更适合于交互频繁且需要高吞吐量、低延迟、可靠的物联网数据的场景。</p></li></ul><p><img src="./scheme_c.png"></p><ul><li><p>基于云的区块链与物联网边缘混合：</p><p>这种方法是对先前集成方案的扩展，其中物联网用户可以选择将区块链用于记录某些物联网交互事件，其余事件直接发生在物联网设备之间。 这种方法利用区块链的分散记录保护以及实时物联网通信的优势。该方法的主要问题是如何优化实时发生的交互与通过区块链的交互之间的反应时差。</p></li></ul><p><img src="./scheme_d.png"></p><h2 id="四iot与blockchain-based-id-management">四、IoT与Blockchain-based ID Management</h2><p>在物联网中，IDM主要可以包括以下几个部分：</p><ul><li>身份验证（authentication）；</li><li>身份授权（authorization）；</li><li>访问控制管理；</li><li>设备所有权管理；</li><li>设备与人、设备与设备的关系管理；</li></ul><p>此外，在传统的IDM通信方法里，还是使用基于中心化PKI的方案，如下图所示，用户之间进行通信需要多次轮训，且对中心CA机构极为依赖。</p><p>但这种方法由于一些物联网的特性（如可扩展性、协同操作性和移动性）而无法直接移植到物联网环境。这些特性要求对于物联网身份管理系统设计来说很重要。</p><p><img src="./PKI体系.png"></p><h3 id="物联网身份管理系统应该有的特性">1. 物联网身份管理系统应该有的特性</h3><ul><li><p>可扩展性（Scalability）</p><p>物联网技术的愿景是万物互联，当网络物理世界的个数达到一定数量，使用传统的集中式IDM方案，所有物联网标识由一个通用第三方维护以构建高度可扩展的IDM解决方案变得极不现实。现有的联邦式身份管理解决方案（例如，<a href="https://www.oasis-open.org/committees/tc_home.php?wg_abbrev=security" target="_blank" rel="noopener">SAML</a>）还是无法绕过信任问题，不能解决在无信任网络中如何建立信任的问题。因此IDM应该在分布式无信任网络中可扩展可信，而无需对任何安全机构进行集中控制。</p></li><li><p>协同操作性（Interoperability）</p><p>根据物体的通信范围、信息处理能力的不同，使用的通信协议也往往不同，如本文第二章所述，通信协议分为很多种，多样性和异构性导致设备之间的协同操作存在问题。设备的身份标识根据不同的标准也全然不同，现在仍然没有一种综合的方案。</p></li><li><p>可移动性（Mobility）</p><p>一些物联网设备有强大的移动能力，可移动性确保用户即使在移动时也能连续地连接服务。无论设备在何处都需要进行身份验证，获得相应的设备服务的授权和访问控制权限。</p></li><li><p>安全与隐私性（Security &amp; Privacy）</p><p>安全与隐私是身份管理系统应该有的最基本特性，具体表现为数据安全、通信安全、隐私保护等。</p></li></ul><h3 id="iot传统身份管理方案">2. IoT传统身份管理方案</h3><h4 id="传统idm模型">2.1 传统IDM模型</h4><p>数字身份管理系统负责管理用户的身份信息，由标识符（UserID、电子邮件、URL等），凭证（证书、令牌、生物识别等）和属性（角色、职位、特权等）。下图描绘了传统IDM的示例实例系统，包括三个主要利益相关者：主体（也称为用户），依赖方（也是称为服务提供商）和身份提供商（IdP）。</p><p><img src="./traditional_IDMS.png"></p><p>由此可见，在传统的IDM模型中，身份提供者IdP作为依赖方发挥了核心的作用。这种强依赖关系直接导致了信任问题（在中国不会出现这种情况）。而且，随着提供在线身份服务的服务商增加，用户需要记忆的自己的身份标识变得更多了。</p><h4 id="联邦idm模型">2.2 联邦IDM模型</h4><p>联邦IDM模型是一种较新的IDM模型，这种模型尝试在各大IdP之间建立信任关系，一个安全域中的用户可以从另一个域访问服务。例如，<a href="https://www.oasis-open.org/committees/tc_home.php?wg_abbrev=security" target="_blank" rel="noopener">SAML</a>、OpenID[28]和Shibboleth，允许用户仅使用一个身份登录到多个安全域并授予对属于同一联盟的各种系统的访问权限，即无论在一个域中对哪个身份进行身份验证，同一联盟中的另一个域提供的服务都可以根据其域提供的凭据进行访问。</p><p>论文[29]给出了现有传统身份管理方案的比较，如下表所示（节选）：</p><table><thead><tr class="header"><th style="text-align: center;">方案</th><th style="text-align: center;">可扩展性</th><th style="text-align: center;">协同操作性</th><th style="text-align: center;">可移动性</th><th style="text-align: center;">安全与隐私性</th><th style="text-align: center;">以用户为中心</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">FIDIS</td><td style="text-align: center;"></td><td style="text-align: center;">√</td><td style="text-align: center;">√</td><td style="text-align: center;">√</td><td style="text-align: center;">√</td></tr><tr class="even"><td style="text-align: center;">SAML<a href="https://www.oasis-open.org/committees/tc_home.php?wg_abbrev=security" target="_blank" rel="noopener">27</a></td><td style="text-align: center;"></td><td style="text-align: center;">√</td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;">OpenID[28]</td><td style="text-align: center;">√</td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;">√</td></tr><tr class="even"><td style="text-align: center;">Shibboleth</td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;">√</td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;">STORK</td><td style="text-align: center;"></td><td style="text-align: center;">√</td><td style="text-align: center;"></td><td style="text-align: center;">√</td><td style="text-align: center;">√</td></tr><tr class="even"><td style="text-align: center;"><a href="http://www.picosproject.eu" target="_blank" rel="noopener">PICOS</a></td><td style="text-align: center;">√</td><td style="text-align: center;">√</td><td style="text-align: center;">√</td><td style="text-align: center;">√</td><td style="text-align: center;">√</td></tr><tr class="odd"><td style="text-align: center;">Cardspace</td><td style="text-align: center;"></td><td style="text-align: center;">√</td><td style="text-align: center;">√</td><td style="text-align: center;">√</td><td style="text-align: center;">√</td></tr></tbody></table><p>用户必须考虑来自物联网的所有实体，并协调不同安全域的应用加入IDMS，在异构环境中构建可协同操作性系统。但从上表可以看到，大多数的身份管理方案都无法处理可扩展性。虽然OpenID和PICOS等方法可以某种程度上具有可扩展性，但IoT需要更强大的分布式可扩展的底层对上层所有物联网实体的管理支撑。此外，现有的安全与隐私都建立在“用户都信任他们的IdP”的假设上，IdP的安全事故将会导致大批量用户数据泄露（Facebook账号泄露事件），并不能真正消除隐私问题。</p><p><strong>总而言之</strong>，互联网上的当前身份管理系统已经从孤立模型演变为去中心化的、联邦制的和以用户为中心的身份管理解决方案。通常，一些大型在线服务提供商的IdMS成为其联合域中的通用身份提供商，例如：微信登录、Facebook登录、Google登录等登录方式。不可否认，以用户为中心的联邦式IDMS确实减轻了用户管理身份标识的复杂性。然而，安全性和隐私性尚未得到完美解决，因为用户必须完全信任他们身处中间的身份提供者，这些身份提供者看到每个用户与其在线服务提供商之间的所有活动，“Facebook用户账号泄露事件”就给我们敲响了警钟。因此，消除不必要的第三方并在无信任网络中构建可信身份提供商对于物联网环境至关重要。</p><h3 id="现有方案举例">3. 现有方案举例</h3><p>本节先从学术界和工业界对Blockchain-based IDM与物联网的现状进行简单阐述，并提出个人观点；再进行实际举例，举出实际应用结合点，并附上现有方案。</p><h4 id="相关综述">3.1 相关综述</h4><h5 id="学术界综述">3.1.1 学术界综述</h5><p>从学术研究的角度来看，基于区块链的IDM系统正在引起很多的关注，为数字身份提出新的解决方案：</p><ul><li>Hardjono[33]在准入式区块链环境中使用零知识证明引入了一种基于区块链的隐私保护身份解决方案，称为ChainAnchor。在ChainAnchor中，验证节点具有编写或处理事务的权限，而其他节点只能读取和验证事务。所有经过验证的节点都建立在防篡改硬件上，形成隐私保护层，为用户提供隐私保护服务；</li><li>Lee[34]为物联网设备提出了基于区块链的身份和认证管理系统。 他们提出的解决方案将身份标识的生成和维护放在区块链上，作为一种即时服务，而不考虑通过设备使用区块链的交互或通信。 在这种情况下，基于区块链的身份标识仅用于去中心的身份验证目的；</li><li>Kravitz[6]提出基于准入式区块链网络的解决方案，由于准入式的区块链网络里的用户可知，参与者之间物联网的接入更可信。此外，该方法利用设备组成员（DGM）机制，将多个设备和用户绑定，并且在执行事务时，在区块链中可以体现出所属成员。</li></ul><h5 id="工业界综述">3.1.2 工业界综述</h5><p>在工业界有很多新兴的创业公司以及企业联盟，意图在区块链与物联网结合的大生态市场上分一杯羹：</p><ul><li><a href="https://www.trusted-iot.org/" target="_blank" rel="noopener">Trusted IoT Alliance</a>：一个物联网开源软件基金会，其使命是利用区块链技术解决物联网去中心、异构等技术难点。其中不泛有IOTA等的区块链公司，纽约梅隆银行、西门子、思科等合作企业，以及几个物联网企业（区块链公司成员比物联网的还多）；</li><li><a href="https://www.iota.org/" target="_blank" rel="noopener">IOTA</a>：以Tangle闻名，将基于DAG区块链做大做强的方案。使用独特的方法来验证交易，使其成为物联网所需的大量数据交换的理想选择；</li><li><a href="https://slock.it/" target="_blank" rel="noopener">slock.it</a></li><li><a href="https://www.blockpass.org/" target="_blank" rel="noopener">blockpass</a></li></ul><p><strong>综上所述</strong>，实际上基于区块链的身份标识产品已经很多，相关学术论文也不少，但是实际上用在物联网领域的还真不多，个人认为主要原因有以下几点：</p><ul><li><p>离不开PKI体系：不使用公钥体系，建起来的城堡就如同沙雕。PKI在物联网中并不能很好适配的主要原因就是其过度中心化的设计，常常容易带来性能瓶颈、单节点故障等问题。现有解决方案DPKI可以有效解决过度中心化的缺点，但其落地为时尚早， 真正的去中心化不切实际；</p></li><li><p>加密成本太高：物联网设备根据设备不同的职能有不一样的硬件情况，但普遍是资源限制的，运算能力弱，存储能力差，蓄电量低，这样就对安全通信、安全存储带来了一系列的挑战；同时，由于成本的关系，不可能给设备都配备上性能高的硬件条件，所以如何平衡安全和成本是一个主要问题：</p><p><img src="./security_balance.jpg"></p><p>再上图可以看到，在通信层使用TLS或轻量级DTLS可以抵抗中间人攻击等通信攻击方式；在针对软件或硬件攻击其密钥，可以使用ARM基于TEE(Trusted Execution Enviroment)/PSA(Platform Security Architecture)进行硬件隔离，存储密钥相关的数据；更深层次的硬件攻击可以使用SE(Secure Element)芯片级的安全保护，但是成本也会大大增加；</p></li><li><p>不能完全实现去中心化：如今DPKI等对中心化体系替换的方案还未成熟，完全去中心化不切实际，所以现在多是从单中心化转变为多中心化，在企业业务层面进行合作；</p></li></ul><h4 id="物联网身份管理与属性管理">3.2 物联网身份管理与属性管理</h4><p>分布式身份管理与属性管理是分布式经济的基础。在物联网中，设备与人与其他设备的关系，以及其所有权的变更，在不同时间不同地点的访问控制权限，都与分布式身份管理息息相关。如下图所示，是一个基于区块链的分布式身份标识系统的样例。</p><p><img src="./overview_of_bid.png"></p><h5 id="securing-user-identity-and-transactions-symbiotically-iot-meets-blockchain6">3.2.1 Securing User Identity and Transactions Symbiotically: IoT Meets Blockchain[6]</h5><p>论文[6]基于传统PKI与联邦式IDM，提出了一种使用联盟链保护和管理多个物联网设备的分布式身份管理解决方案。该解决方案通过对非对称密钥的重发(rorating key)增加安全性并防止攻击，并提供设备成员DGM机制，可以保证成员内的设备发出Transaction时，区块链内可以认定是从属于哪个DGM发出的Transaction。并且可以调节设备存储量，对存储空间很小的物联网设备很友好。</p><p><strong>1). 定义声明</strong></p><ul><li>Enrollment Cert：长期存储固有属性，用于证明身份；</li><li>Transaction Cert（TCert）：记录动态的属性，用于区块链交易；</li><li>Transaction Cert Authority（TCA）：颁发TCert；</li><li>Attribute CA（ACA）</li><li>Kown Your Machine（KYM）</li></ul><p><strong>2). 授权密钥管理</strong></p><p><img src="./auth_key_manage.png"></p><ul><li><p>生成TCA CA RootKey与Primary TCA的ID；</p></li><li><p>生成Primary TCA RootKey： <span class="math inline">\(TCA\_RootKey_{384bit}=HMAC(TCA\_CARootKey,TCA\_ID)\)</span> ；</p></li><li><p>Primary TCA分发Template TCert给从属TCA，从属TCA负责颁发相应TCert： <span class="math inline">\(TCertsRoot_{384bit}=HMAC(TCA\_RootKey,&#39;&#39;1&#39;&#39;||KeyVersion)\)</span> ；</p></li><li><p>从属TCA实例化TCert，对某个设备/人进行注册，生成Enrollment Cert与TCert，生成TCertOwnerRootKey：<span class="math inline">\(TCertOwnerRootKey_{384bit}=HMAC(TCertsRoot,EnrollmentPublicKey)\)</span> ；</p></li><li><p>从属TCA派生出拓展密钥TCertOwnerExpansionKey与加密密钥TCertOwnerEncryptionKey：</p><p><span class="math inline">\(TCertOwnerEncryptionKey\_{256bit}=HMAC(TCertOwnerRootKey,&#39;&#39;1&#39;&#39;)\ (256bit truncation)\)</span></p><p><span class="math inline">\(TCertOwnerExpansionKey_{384bit}=HMAC(TCertOwnerRootKey,&#39;&#39;2&#39;&#39;)\)</span></p></li><li><p>生成TCertIndex，ConstantPad代表着在审计中的所属DGM设备： <span class="math inline">\(EncryptedTCertIndex=AES\_CBC\_Encrypt(TCertOwnerEncryptionKey,TCertIndex||ConstantPad)\)</span></p></li><li><p>生成TCert-specific拓展值： <span class="math display">\[\begin{align}TCertSpecificExpansionValu_{384bit}\\&amp; = \{HMAC(TCertOwnerExpansionKey,TCertIndex)\\&amp;||HMAC(TCertOwnerExpansionKey,TCertIndex+1)\}\end{align}\]</span></p></li></ul><p><strong>3). 密钥拓展</strong></p><p>TCA可以将TCert的公钥和私钥进行派生，以符合一个群组多个设备的设计（和ID Mixer有区别），而且派生的过程中是与当前属性无关的，这个和面向对象的基类继承派生很相似，可以在继承属性的基础上添加资质证明等属性值，更有利于审计与分析。 <span class="math display">\[\begin{align}TCertPublicKey\\&amp;=EnrollmentPublicKey+TCertSpecificExpansionValue*G \\TCertPrivateKey\\&amp;=(EnrollmentPrivateKey+TCertSpecificExpansionValue)\ (mod\ n)\end{align}\]</span> <span class="math inline">\(G\)</span> 是ECDSA中的系数。</p><p><strong>4). 属性管理</strong></p><p><img src="./TCA_key_manage.png"></p><ul><li><p>生成TCA CA RootKey与Primary TCA的ID；</p></li><li><p>生成Primary TCA RootKey： <span class="math inline">\(TCA\_RootKey_{384bit}=HMAC(TCA\_CARootKey,TCA\_ID)\)</span> ；</p></li><li><p>生成审计/从属TCA树根节点密钥：<span class="math inline">\(PreK\_Root=HMAC(TCA\_RootKey,&#39;&#39;2&#39;&#39;||KeyVersion)\)</span> ；</p></li><li><p><span class="math inline">\(K\_TCert=HMAC(PreK\_xyz,TCertID),\ where\ PreK\_xyz=HMAC(PreK\_Root,&#39;&#39;xyzx&#39;&#39;)\)</span> ；</p></li><li><p>属性的加密密钥 <span class="math inline">\(Attribute\_EncryptionKey[i]\)</span> 是由 <span class="math inline">\(K\_TCert\)</span> 派生而成的，即 : <span class="math display">\[\begin{align}Attribute\_EncryptionKey[i]&amp;=HMAC(K\_TCert,i)\\Encrypted_Attribute[i]&amp;=AES\_CBC\_Encrypt(Attribute\_EncryptionKey[i],Attribur[i])\end{align}\]</span></p></li><li><p>被认证的属性为 <span class="math inline">\(Authenticated\_Attribute\)</span> ： <span class="math display">\[\begin{align}Attribute\_HMACKey[i]&amp;=HMAC(Attribute\_EncryptionKey[i],i)\\Authenticated\_Attribute[i]&amp;=HMAC(Attribute\_HMACKey[i],Attribute[i])\end{align}\]</span></p></li></ul><h4 id="物联网密钥管理">3.3 物联网密钥管理</h4><p>在物联网场景中，设备与设备之间通信，更多的是通过多播/广播进行的群组通信可以与整个群组进行直接通信，这种方式更加高效。在物联网中的所有安全问题中，群组密钥管理是保护群组通信的基础之一。群组密钥本质上是由群组的所有成员共享的密钥，以便在使用该组密钥传输之前对所有组通信包进行加密。未授权用户可能由于网络错误或故意拦截而接收群组通信包，但是，如果没有正确的群组密钥，则非法用户无法解密所接收的包。</p><p>因为物联网设备资源的限制，现有的IP网络中的群组密钥管理方案不能直接用于物联网中。这意味着每个节点都无法存储大型密钥数据库或进行繁重的加密计算。</p><p>在3.3.1节介绍一种基于PUF的物联网密钥管理方法，虽然<strong>不是基于区块链的解决方案</strong>，但是或许可以从中寻找更加深入的结合点。</p><h5 id="efﬁcient-and-secure-group-key-management-in-iot-using-multistage-interconnected-puf31">3.3.1 Efﬁcient and Secure Group Key Management in IoT using Multistage Interconnected PUF[31]</h5><p>论文[31]提出了一种基于物理上不可克隆方程(Physically Unclonable Function, PUF)设计的组密钥管理方案：多级互联PUF（Multistage Interconnected PUF, MIPUF），该方法可以在能量资源受限的环境中保护设备进行组通信。这种设计能够安全、高效地执行密钥管理任务：密钥分发、密钥存储和密钥更新。在最后的实验表明，与现有的基于ECC的密钥管理方案相比，可以节省47.33%的电源。</p><p>暂且跳过MIPUF的部分，假设作者提出的MIPUF嵌入芯片在计算效果上是正确的、有效的、节能的、安全的。我们主要看它的密钥管理部分。</p><ul><li><p>密钥分发</p><p>密钥分发遵循着群组密钥分发协议，请看下图，不再赘述：</p><p><img src="./group_key_protocol.png"></p></li><li><p>密钥存储</p><p>在密钥分发之后，当提供正确的配置参数时，可以从MIPUF中提取群组密钥。 与其他基于加密的密钥管理系统不同，这个方法不直接将群组密钥存储在内存中， 而是从密钥提示(hint) <span class="math inline">\(p_i\)</span> 中提取群组密钥。因为只有当攻击者可以同时访问存储（包含 <span class="math inline">\(p_i,f_i,c_i^{\gamma_i}\)</span> ）和MIPUF（<span class="math inline">\(\Bbb{F}^{\gamma_i}\)</span>），才能获得真实的群组密钥。 只篡改其中一个不损害整个设计的安全性。此外，群组密钥仅用于接收或发送组消息，因此使用低功率MIPUF存储真实密钥也是高能效的。</p></li><li><p>密钥更新</p><p>只要群组成员进行动态更改，就需要重新生成，重新分发或更新群组密钥。当一个成员离开该组时，它应该无法解密未来的群组通信（forward security）; 当一个新成员加入时，它不应该能够解密过去的群组通信（backward security）。 出于安全考虑，在检测到潜在泄漏时，还应完全重新组密钥组密钥。 这里讨论所有三种可能的情况：</p><ul><li><p>新成员加入</p><p>假设新的IoT节点<span class="math inline">\(N_{\alpha}\)</span>意图加入组<span class="math inline">\(G\)</span>，<span class="math inline">\(N_{\alpha} \notin G\)</span>。在这种情况下，将新密钥重新分配给所有组成员是昂贵且低效的。 因此，控制单元向所有设备 <span class="math inline">\(\forall N_i \in G\)</span> 发出消息 <span class="math inline">\(msg^{join}={E_{key_g}(key&#39;_g)}\)</span> 。现有的组成员计算并存储新的密钥提示 <span class="math inline">\(p&#39;_i=r_i^{\gamma_i}\otimes key&#39;_g\)</span> 并在接收和解密<span class="math inline">\(msg^{join}\)</span>时删除 <span class="math inline">\(key&#39;_g\)</span>。 新成员必须完成整个密钥分发过程。 使用此方法可以保留向后安全性，因为新成员没有关于旧组密钥的信息。</p></li><li><p>成员退出</p><p>从组中删除现有成员比添加新成员更复杂。假设将<span class="math inline">\(G\)</span>群组分成m个子群 <span class="math inline">\(g_j\subset G =\{g_1,…,g_m\},1\leq j\leq m\)</span> 。同一子群中的所有节点共享相同的配置参数<span class="math inline">\(\gamma_{g_j}\)</span>。</p><p>假设IoT节点 <span class="math inline">\(N_{\beta}\in g_j \subset G\)</span> 意图离开子群，其中子群中的所有成员使用相同的MIPUF配置参数<span class="math inline">\(\gamma_j\)</span>。控制节点首先多播/广播m-1包含新密钥的消息<span class="math inline">\(msg_j^{leave}=\{E_{\gamma_i}(key&#39;_g||H(\gamma_i))\}\)</span> 发送给所有使用配置参数<span class="math inline">\(\gamma_i,i\neq j,1\leq i\leq m\)</span>加密的子群。收到消息后，每个节点首先使用自己的配置参数 <span class="math inline">\(\gamma_i\)</span> 对消息进行解密，并检查 <span class="math inline">\(H(\gamma_i)\)</span> 是否与解密的消息中匹配。如果为正确，那么解密的新群密钥 <span class="math inline">\(key&#39;_g\)</span> 有效，否则，丢弃该消息。包括离开节点在内的<span class="math inline">\(g_j\)</span>成员都不知道其他子组的配置参数，因此无法正确解密消息。控制单元应该通过以下方式对<span class="math inline">\(g_j\)</span>的所有成员进行单播通信。分配新的群组密钥<span class="math inline">\(key&#39;_g\)</span>和新的配置<span class="math inline">\(\gamma&#39;_j\)</span>以替换<span class="math inline">\(\gamma_j\)</span> 。</p></li><li><p>所有密钥更新</p><p>但是，可以通过完全重新映射输入 - 输出映射来重新调整MIPUF以解决建模攻击（modeling attacks）。 一旦生成的CRP总数超过计算的样本复杂度下限，我们建议执行完全更新。该下限等于打破MIPUF的训练集大小。 下面的等式描述了根据IPN模型参数的下限的样本大小，其中<span class="math inline">\(m\)</span>是MIPUF中的节点的数量，并且<span class="math inline">\(n\)</span>是MIPUF节点中的PUF的最大数量。 <span class="math inline">\(k=VC(\Bbb F)\)</span>其中<span class="math inline">\(VC\)</span>是Vapnik-Chervonenkis维度，<span class="math inline">\(\Bbb F\)</span>是MIPUF中最大的单个PUF。 <span class="math inline">\(\delta\)</span>是失败概率，<span class="math inline">\(\epsilon\)</span> 是学习的错误。 <span class="math display">\[Sample\ complexity = \frac{(m\cdot k+m)\cdot n+lb(\frac{1}{\delta})}{\epsilon}\]</span></p></li></ul></li></ul><h4 id="物联网权限管理">3.4 物联网权限管理</h4><p>物联网场景比传统的C/S场景更加动态，设备状态、管理权、所有权变化更加频繁。当访问控制查询和更新变得更加频繁时，单个集中式访问控制服务器会存在明显的性能瓶颈。基于区块链技术的分布身份识别，具有可追溯、不可抵赖等特点更加适合物联网的场景。<strong>然而现有的方法还处在验证阶段，离不开中心化的PKI是不能从根本上改变现状的。</strong></p><h5 id="blockchain-meets-iot-an-architecture-for-scalable-access-management-in-iot32">3.4.1 Blockchain Meets IoT: an Architecture for Scalable Access Management in IoT[32]</h5><p>论文[31]提出了一种可用于仲裁物联网中的角色和权限的体系结构。该体系结构是基于区块链技术的物联网分布式访问控制系统，这种架构由概念验证实验支持，并在实际的物联网场景中进行了评估。</p><p><img src="./access_control.png"></p><p>所提出的方法定义一个Management Hub代表物联网设备从区块链请求访问控制信息，其余所有设备都在区块链网络中具有唯一标识。设备在注册时，必须在管理员的控制下注册，并且一定要注册在一个Management Hub下，注册之后管理员便可以对该设备的访问控制权限进行设定。</p><p>在区块链中部署智能合约用于定义访问控制系统中所有的操作。管理者可以和智能合约交互，便于定义系统的访问控制策略。</p><p><img src="./BIoT_IDM_workflow.png"></p><p>上图显示了各个部件的交互情况。</p><h4 id="设备生命周期的安全管理">3.5 设备生命周期的安全管理</h4><p>区块链还可以在物联网设备的供应链和生命周期的每个环节提供可信赖的分布式管理，如下图所示，可以记录设备的所有权（ownership）。</p><p><img src="./IoT%20security%20management.png"></p><ol type="1"><li>在开发商处建立设备的Identity；</li><li>在交付时建立所有权(Ownership)，分发密钥对；</li><li>在部署时对设备参数化，建立访问控制以及配置设备 ；</li><li>在维护时，定期重新分发密钥，恢复、升级、重配置；</li><li>若存在更改所有权，需要在新的持有者重新分配密钥对、重新部署；</li><li>设备报废/退休，需要删除所有权。</li></ol><h3 id="idm-for-iot的挑战">4. IDM for IoT的挑战</h3><h4 id="访问控制">4.1 访问控制</h4><p>身份标识和访问控制始终是紧密相连的。在物联网中建立身份系统的目标是实现通信并规范设备和资源的授权过程。尽管基于区块链的访问控制在物联网领域是重要结合点，然而现存的方案中没有很好地解决物联网的访问控制。</p><p>传统的访问控制模型访问控制列表（ACLs）和基于角色的访问控制（RAC）模型由于其中心化的设计和扩展性差，早已落入历史洪流；传统方案的共同缺点都是其中心化管理（Admin，IdP等），中心化管理者为设备设定其访问权、角色与属性。因此，这些解决方案不适用于去中心化的可扩展的物联网系统。因此，物联网访问控制的主要挑战可以归结为两点（可扩展性和去中心化）：</p><ul><li><strong>可扩展性</strong>：如何设计有效的访问控制机制，以便于对多种多样的物联网实体（人、物、服务等）的访问权限进行管理，而无需担心用户、角色以及访问策略的快速增长；</li><li><strong>去中心化</strong>：如果使用区块链技术去除“可信”第三方的IdP，如何在无信任的物联网环境构建访问控制机制？</li></ul><h4 id="隐私保护">4.2 隐私保护</h4><p>基于身份标识的隐私保护也需要从重考虑。如本章第2节中所述，在传统的身份认证中，验证者从服务商或IdP中取得被验证者的信息，在这一步用户的信息往往被多次披露，并且中心化的IdP可以看到服务访问者和提供者之间的交互，存在个人隐私泄露的风险。从用户的角度来看，隐私保护包括两个方面：</p><ul><li>来自IdP的身份信息保护；</li><li>来自服务提供商的敏感应用数据保护；</li></ul><p>在基于区块链的分布式身份标识中，更改了以往的身份验证范式，由用户决定向谁现实敏感信息，而不是托管给IdP。当然，单纯依靠区块链技术还远远不够，还需要额外的隐私保护方案，例如将多方计算（MPC）和零知识证明（ZKP）引入区块链，可实现敏感信息的选择性披露，可实现真正的隐私。但是现今的学术界和工业界都由于方案的复杂性、性能瓶颈等问题，真正落地的不多。</p><h4 id="性能成本">4.3 性能/成本</h4><p>性能其实与底层区块链的性能有关，能够承受数量众多的物联网设备进行信息交互的底层区块链平台的开发也具有一定的挑战性。其次，成本、安全、性能这三者如何平衡，仍然是产品能不能落地的重要因素，值得研究。</p><h2 id="参考文献链接">参考文献/链接</h2><ol type="1"><li><a href="https://internetofthingsagenda.techtarget.com/definition/Internet-of-Things-IoT" target="_blank" rel="noopener">What is internet of things (IoT)? - Definition from WhatIs.com</a></li><li>Khan M A, Salah K. IoT security: Review, blockchain solutions, and open challenges[J]. Future Generation Computer Systems, 2018, 82: 395-411.</li><li>M. Conoscenti, A. Vetro, J.C.D. Martin, Blockchain for the Internet of Things: A systematic literature Review, in: The 3rd International Symposium on Internet of Things: Systems, Management, and Security, IOTSMS-2016, 2016.</li><li>Lo S K, Liu Y, Chia S Y, et al. Analysis of Blockchain Solutions for IoT: A Systematic Literature Review[J]. IEEE Access, 2019, 7: 58822-58835.</li><li>Fernández-Caramés T M, Fraga-Lamas P. A Review on the Use of Blockchain for the Internet of Things[J]. IEEE Access, 2018, 6: 32979-33001.</li><li>Kravitz D W, Cooper J. Securing user identity and transactions symbiotically: IoT meets blockchain[C]//2017 Global Internet of Things Summit (GIoTS). IEEE, 2017: 1-6.</li><li><a href="https://www.cse.wustl.edu/~jain/cse570-15/ftp/iot_prot/#chal4" target="_blank" rel="noopener">Internet of Things Protocols and Standards</a></li><li>Pongle P, Chavan G. A survey: Attacks on RPL and 6LoWPAN in IoT[C]//2015 International conference on pervasive computing (ICPC). IEEE, 2015: 1-6.</li><li>Ali M S, Vecchio M, Pincheira M, et al. Applications of blockchains in the Internet of Things: A comprehensive survey[J]. IEEE Communications Surveys &amp; Tutorials, 2018, 21(2): 1676-1717.</li><li>Gu H, Potkonjak M. Efficient and Secure Group Key Management in IoT using Multistage Interconnected PUF[C]//Proceedings of the International Symposium on Low Power Electronics and Design. ACM, 2018: 8.</li><li><a href="https://www.i-scoop.eu/internet-of-things-guide/iot-device-management/" target="_blank" rel="noopener">IoT device management: challenges, solutions, platforms, choices, market and future</a></li><li>Biliyaminu U, Hamdan H, Lengyel L, Farkas K. Evaluation of IoT Device Management Tools, in: ACCSE 2018: The Third International Conference on Advances in Computation, Communications and Services, 2018.07.22-26, Barcelona, Spain.</li><li><a href="https://sia.tech/technology" target="_blank" rel="noopener">Sia combines a peer-to-peer network with blockchain technology to create the world's first decentralized storage platform.</a></li><li>P. Otte, M. de Vos, J. Pouwelse, TrustChain: A Sybil-resistant scalable blockchain, Future Gener. Comput. Syst. (2017). http://dx.doi.org/10.1016/j.future.2017.08.048.</li><li>A. Ouaddah, A. A. Elkalam, and A. A. Ouahman, “Towards a novel privacy-preserving access control model based on blockchain technology in iot,” in Europe and MENA Cooperation Advances in Information and Communication Technologies, 2017, pp. 523–533.</li><li>A. Kosba, A. Miller, E. Shi, Z. Wen, and C. Papamanthou, “Hawk: The blockchain model of cryptography and privacy-preserving smart contracts,” in IEEE Symposium on Security and Privacy, 2016, pp. 839–858.</li><li>M. S. Ali, K. Dolui, and F. Antonelli, “Iot data privacy via blockchains and ipfs,” in 7 th International Conference for the Internet of Things, 2017.</li><li>J. Kang, R. Yu, X. Huang, M. Wu, S. Maharjan, S. Xie, and Y. Zhang, “Blockchain for secure and efﬁcient data sharing in vehicular edge computing and networks,” IEEE Internet of Things Journal, pp. 1–1, 2018.</li><li>Z. Li, J. Kang, R. Yu, D. Ye, Q. Deng, and Y. Zhang, “Consortium blockchain for secure energy trading in industrial internet of things,” IEEE Transactions on Industrial Informatics, vol. 14, no. 8, pp. 36903700, Aug 2018.</li><li>Y. Rahulamathavan, R. C.-W. Phan, S. Misra, and M. Rajarajan, “Privacy-preserving blockchain based iot ecosystem using attributebased encryption,” 2017.</li><li>A. Alcaide, E. Palomar, J. Montero-Castillo, and A. Ribagorda, “Anonymous authentication for privacy-preserving iot target-driven applications,” computers &amp; security, vol. 37, pp. 111–123, 2013.</li><li>L. Axon and M. Goldsmith, “Pb-pki: a privacy-aware blockchain-based pki,” 2016.</li><li>S. H. Hashemi, F. Faghri, P. Rausch, and R. H. Campbell, “World of empowered iot users,” in Internet-of-Things Design and Implementation (IoTDI), 2016 IEEE First International Conference on. IEEE, 2016, pp. 13–24.</li><li>O. Novo, “Blockchain meets iot: an architecture for scalable access management in iot,” IEEE Internet of Things Journal, 2018.</li><li>H. Shafagh, L. Burkhalter, A. Hithnawi, and S. Duquennoy, “Towards blockchain-based auditable storage and sharing of iot data,” in Proc. of the Cloud Computing Security Workshop, 2017, pp. 45–50.</li><li>A. Reyna, C. Martín, J. Chen, E. Soler, and M. Díaz, “On blockchain and its integration with iot. challenges and opportunities,” Future Generation Computer Systems, 2018.</li><li><a href="https://www.oasis-open.org/committees/tc_home.php?wg_abbrev=security" target="_blank" rel="noopener">Security Services Technical Committee of OASIS—Security Assertion Markup Language (SAML) v2.0</a></li><li>Recordon, D.; Reed, D. OpenID 2.0: A Platform for User-centric Identity Management. In Proceedings of the Second ACM Workshop on Digital Identity Management, Alexandria, VA, USA, 3 November 2006.</li><li>Zhu X, Badr Y. Identity Management Systems for the Internet of Things: A Survey Towards Blockchain Solutions[J]. Sensors, 2018, 18(12): 4215.</li><li><a href="http://www.picosproject.eu" target="_blank" rel="noopener">PICOS—Privacy and Identity Management for Community Services.</a></li><li>Gu H, Potkonjak M. Efficient and Secure Group Key Management in IoT using Multistage Interconnected PUF[C]//Proceedings of the International Symposium on Low Power Electronics and Design. ACM, 2018: 8.</li><li>Novo O. Blockchain meets IoT: An architecture for scalable access management in IoT[J]. IEEE Internet of Things Journal, 2018, 5(2): 1184-1195.</li><li>Hardjono, T.; Pentland, A. Veriﬁable Anonymous Identities and Access Control in Permissioned Blockchains. 2016. Available online: http://connection.mit.edu/wp-content/uploads/sites/29/2014/12/ChainAnch or-Identities-04172016.pdf (accessed on 31 August 2018).</li><li>J.-H. Lee, “Bidaas: blockchain based id as a service,” IEEE Access, vol. 6, pp. 2274–2278, 2018.</li><li><a href="https://www.trusted-iot.org/" target="_blank" rel="noopener">Trust IoT Alliance</a></li><li><a href="https://www.iota.org/" target="_blank" rel="noopener">The Next Generation of Distributed Ledger Technology | IOTA</a></li><li><a href="https://slock.it/" target="_blank" rel="noopener"><strong>slock.it</strong> connects devices to the <strong>blockchain</strong>, enabling the <strong>economy of things</strong></a></li><li><a href="https://www.blockpass.org/" target="_blank" rel="noopener">KYC-as-a-Service for Regulated Industries</a></li></ol>]]>
    </content>


    <categories>

      <category> 物联网 </category>

      <category> Research </category>

    </categories>


    <tags>

      <tag> blockchain </tag>

      <tag> Identity </tag>

      <tag> IoT </tag>

      <tag> Security </tag>

    </tags>

  </entry>


  <entry>
    <title>Hyperledger Indy分析报告</title>
    <link href="/2019/07/16/Hyperledger-Indy-Research/" />
    <url>/2019/07/16/Hyperledger-Indy-Research/</url>

    <content type="html">
      <![CDATA[<p>Hyperledger Indy提供了一种基于区块链或其他分布式账本的分布式数字身份（DID）方案，这种方案中包含了各种工具、库和可重用工具，以便于这些数字身份可在多个管理域、应用程序以及其他任何数据孤岛上互通。</p><a id="more"></a><h2 id="一indy架构综述">一、Indy架构综述</h2><p>从横向看，Indy主要分为项目分布、生态系统架构、数据模型(DID、DID Document、Verified Credentials)；从纵向看，Indy主要分为业务层(Business Layer)、应用层(Applications Layer)和技术层(Technology Layer)。</p><p>总体架构如下图所示：</p><figure><img src="./HBB-Indy-Sovrin_ARM_v0.27.png" alt="HBB-Indy-Sovrin ARM v0.27"><figcaption>HBB-Indy-Sovrin ARM v0.27</figcaption></figure><h3 id="业务层">1. 业务层</h3><figure><img src="./image-20190704181446731.png" alt="image-20190704181446731"><figcaption>image-20190704181446731</figcaption></figure><p>业务层主要使用以下几个应用层提供的功能服务：凭证发行（Issue）、凭证存储（Local Store）、数据请求（Request）、凭证披露（Present）、凭证验证（Verify）、凭证撤销（Revocate）用户注册登录等。</p><h3 id="应用层">2. 应用层</h3><p>应用层主要功能：提供DID服务、提供凭证服务、提供特定业务服务。</p><figure><img src="./image-20190704181354240.png" alt="image-20190704181354240"><figcaption>image-20190704181354240</figcaption></figure><p>应用层由Indy底下 <a href="https://github.com/hyperledger/indy-agent" target="_blank" rel="noopener">Indy-Agent</a> 和 <a href="https://github.com/hyperledger/indy-sdk" target="_blank" rel="noopener">Indy-SDK</a> 两个项目支撑。Indy-SDK项目提供钱包功能组件（Wallet Component）支撑数据存储与开发，使用技术层Agent API提供的服务；Indy-Agent项目提供代理功能组件（Agent Component）支撑业务开发。</p><h3 id="技术层">3. 技术层</h3><figure><img src="./image-20190704181540967.png" alt="image-20190704181540967"><figcaption>image-20190704181540967</figcaption></figure><p>技术层也可再分为<strong>Cloud Agent</strong>层和<strong>Ledger</strong>层。</p><p><strong>Cloud Agent</strong>层由Indy-Agent项目、Indy-SDK项目和 <a href="https://github.com/decentralized-identity/universal-resolver" target="_blank" rel="noopener">DIF Universal-Resolver</a> 项目作支撑，主要功能是提供对Edge Agent的服务，直接与Ledger层进行交互，将请求结果返回到应用层。Indy-SDK项目调用Ledger层的API，实现直接与区块链进行交互；Indy-Agent项目调用Indy-SDK的钱包API，提供代理功能组件，并提供凭证注册组件（Credential Registry Node Component）实现凭证的注册；DIF Universal-Resolver项目提供DID的解析器组件，直接与Ledger层交互，解析出DID。</p><p><strong>Ledger</strong>层由 <a href="https://github.com/hyperledger/indy-node" target="_blank" rel="noopener">Indy-Node</a> 和 <a href="https://github.com/hyperledger/indy-plenum" target="_blank" rel="noopener">Indy-Plenum</a> 两个项目实现，主要功能是实现Indy区块链的功能。Indy-Plenum</p><p>项目主要实现的是Plenum BFT共识协议，是Fabric for Identity的定制版，是整个Indy项目的核心部分；Indy-Node是在Indy-Plenum区块链之上的服务器，直接与区块链层进行交互，实现节点功能。</p><h3 id="数据模型">4. 数据模型</h3><p>DID、DID Document都是按照W3C所定的<a href="https://w3c-ccg.github.io/did-spec/" target="_blank" rel="noopener">数据标准</a>建立的，主要关系如下图所示：</p><figure><img src="./image-20190704171205582.png" alt="image-20190704171205582"><figcaption>image-20190704171205582</figcaption></figure><h2 id="二hyperledger-indy工作流">二、Hyperledger Indy工作流</h2><p>以一个Alice从Faber大学毕业找工作的场景简单介绍Hyperledger Indy的工作流。（<a href="https://medium.com/@kctheservant/exploring-hyperledger-indy-through-indy-dev-example-10075d2547ae" target="_blank" rel="noopener">链接</a>）</p><p><strong>Step 1:</strong> 政府生成凭证模板(Schema)</p><figure><img src="./Step1.png" alt="img"><figcaption>img</figcaption></figure><p>政府颁发Transcript Schema和Job-Certificate Schema，并将其记录到分布式账本中。每个人都可以访问这些模板。</p><p><strong>Step 2：</strong> Faber大学和Acme公司生成他们自己的凭证定义(Credential definition)</p><p>Faber大学和Acme公司根据政府发布的模板创建自己的凭证的定义，并将定义上传到链上。</p><figure><img src="./step2_1.png" alt="img"><figcaption>img</figcaption></figure><figure><img src="./step2_2.png" alt="img"><figcaption>img</figcaption></figure><p>Alice从Faber大学获得成绩单(凭证)，然后再申请工作时想Acme公司提供证书作为教育资格证明。</p><p><strong>Step 3：</strong> Alice从Faber大学获得成绩单凭证</p><figure><img src="./step3.png" alt="img"><figcaption>img</figcaption></figure><p>具体子步骤如下：</p><ul><li>Alice与Faber大学建立连接；</li><li>Faber 大学生成Credential offer给Alice；</li><li>Alice从分布式账本中查询Faber大学对成绩单的定义，生成Credential request发送给Faber大学；</li><li>Faber大学生成一个Credential给Alice，这个Credential内含了足够的proof证明凭证的有效性；</li><li>Alice收到Credential，保存到自己的钱包（wallet）。</li></ul><p><strong>Step 4：</strong> Acme公司请求Alice的教育证明</p><figure><img src="./step4.png" alt="img"><figcaption>img</figcaption></figure><p>具体子步骤如下：</p><ul><li>Acme公司与Alice建立连接；</li><li>Acme生成proof request发送给Alice，这个请求中包含了应该符合的条件；</li><li>Alice收到了proof request，基于Credential生成对应的proof，发送给Acme公司；</li><li>Acme公司收到了proof，并验证其有效性；</li><li>Acme公司确认了proof。</li></ul><p>之后Alice获得了Acme的工作凭证（job-certificate），并将该凭证发送给Thrift银行以证明聘期，便可申请贷款。（Alice使用Faber大学给的教育凭证完成了KYC过程）</p><p><strong>Step5：</strong> Alice获得了Acme公司给的工作证明</p><figure><img src="./step5.png" alt="img"><figcaption>img</figcaption></figure><p>具体子步骤如下：</p><ul><li>Acme公司发送Credential Offer给Alice；</li><li>Alice从分布式账本获取Acme Credential的定义，生成Credential request发送给Acme公司；</li><li>Acme公司生成Credential发送给Alice，该凭证中包含了足够多的证明以证明Alice的聘期；</li><li>Alice收到Credential并保存到钱包（wallet）里。</li></ul><p><strong>Step 6 ：</strong> Thrift银行请求Alice的聘期证明，以及Alice 的KYC</p><figure><img src="./step6.png" alt="img"><figcaption>img</figcaption></figure><p>具体子步骤如下：</p><ul><li>Thrift银行与Alice建立连接；</li><li>Thrift银行生成两个proof request，发送给Alice；在这里的例子中，银行要求工资大于2000，工作经验大于1年，以及KYC流程；</li><li>Alice收到两个proof request，基于Faber大学的凭证以及Acme公司的凭证收成两个proof，发送给Thrift银行；</li><li>Thrift银行收到了证明，并确认其有效性；</li><li>Thrift银行确认了Alice的proof。</li></ul><h2 id="三关键技术点">三、关键技术点</h2><p>Indy整个项目的文件分布如下：</p><ul><li><p>分布式账本</p><ul><li><a href="https://github.com/hyperledger/indy-node" target="_blank" rel="noopener"><strong>Indy-Node</strong></a>：实现在基于Plenum BFT的分布式账本功能与节点功能，；</li><li><a href="https://github.com/hyperledger/indy-plenum" target="_blank" rel="noopener"><strong>Indy-Plenum</strong></a>：实现基于Plenum BFT共识机制，定义wallet基类；</li></ul></li><li><p>客户端工具</p><ul><li><a href="https://github.com/hyperledger/indy-sdk" target="_blank" rel="noopener"><strong>Indy-SDK</strong></a>：由两个主要组件构成：libindy(底层)，libVCX(实现层)；</li><li><a href="https://github.com/hyperledger/indy-agent" target="_blank" rel="noopener"><strong>Indy-Agent</strong></a>：项目实现Agent Client，有以下几种功能方向的App：<ul><li>Edge Agent App；</li><li>Edge Agent Web App；</li><li>Edge Agent Lightweight App；</li><li>Cloud Agent Node；</li><li>Ledger Node；</li><li>Credential Registry Agent Mode；</li></ul></li></ul></li><li><p>通用组件：</p><p><a href="https://github.com/hyperledger/indy-crypto" target="_blank" rel="noopener"><strong>Indy-Crypto</strong></a>：承用了Hyperledger URSA，作为Indy的密码学代码库；</p><p><a href="https://github.com/hyperledger/indy-hipe" target="_blank" rel="noopener"><strong>Indy-HIPE(Hyperledger Indy Project Enhancements)</strong></a>：实现了Indy的功能增强组件。</p></li></ul><p>接下来将按照项目文件的主体部分进行逐层解析。</p><h3 id="indy-plenum">1. Indy-Plenum</h3><figure><img src="./Indy-Plenum.png" alt="Indy-Plenum.png"><figcaption>Indy-Plenum.png</figcaption></figure><p>从内容上看，Plenum项目主要实现了基于RBFT改进的共识机制以及共识操作方法，定义了四种链分别存储整个Indy的配置、事务等信息，定义了DID的wallet以及DID签名验证方法。项目主要分为以下几个部分：</p><h4 id="plenum包">1.1 plenum包</h4><p>plenum包实现了基于 <a href="http://lig-membres.imag.fr/aublin/rbft/report.pdf" target="_blank" rel="noopener"><strong>RBFT</strong></a> 改进的Plenum BFT共识算法，在Commit阶段手机n-of-l个的BLS签名，在共识Order阶段，对多个BLS签名进行聚合。（<strong>注</strong>：BLS签名算法在Indy-Crypto中详细说明）</p><p>Plenum共识改进部分大致在以下三点体现：</p><ul><li>RBFT每个请求都会发起三段commit，Plenum是一堆请求才发起三段commit；</li><li>Plenum在PRE-PREPARE和PREPARE阶段都保存了默克尔树根与state树根；</li><li>三段commit都是用了BLS多签名聚合方法，客户端不需要其他节点响应。</li></ul><p>可以通过这个链接看到Plenum共识协议流程图：<a href="https://hyperledger-indy.readthedocs.io/projects/plenum/en/latest/diagrams/index.html" target="_blank" rel="noopener">Plenum Diagrams</a></p><p><strong>此外</strong>，plenum包定义了DID的钱包（wallet）基类，以及DID对消息签名、签名验证的方法。</p><p>钱包类主要数据结构如下：</p><ul><li>name -&gt; str：id名；</li><li>ids -&gt; Dict[Identifier, IdData]：DID到IdData的映射，一个DID一个IdData；</li><li>idsToSigners -&gt; Dict[Identifier, Signer]：DID到Signer的映射，一个DID一个Signer；</li><li>aliasesToIds -&gt; Dict[Alias, Identifier]：(别名)Alias到DID的映射，一个DID对应多个Alias。</li></ul><p>钱包类主要方法：</p><ul><li>Encrypt/Decrypt：均使用 <a href="https://download.libsodium.org/doc/" target="_blank" rel="noopener">libsodium</a>密码库的python封装进行加解密；</li><li>sign/verify：签名和签名验证方法都是基于<a href="https://download.libsodium.org/doc/" target="_blank" rel="noopener">libsodium</a>的sign方法进行的，使用signKey签名，使用veryKey+DID进行验证；</li><li><strong>DID Create</strong>：<ul><li>指定或产生Seed，32byte；</li><li>根据Ed25519算法产生公私钥对 MSK,MPK；</li><li>再将产生的私钥作为种子Seed，使用Ed25519，生成新的公钥VerkeyRaw，新的签名私钥signKey；</li><li>将verKeyRaw的前16字节进行base58解码，成为DID，后16字节为verKey。</li><li>当signKey、verKey丢失时，将可以使用MSK再次重新生成。</li></ul></li><li><strong>Wallet storage</strong>：使用 <a href="https://github.com/jsonpickle/jsonpickle" target="_blank" rel="noopener">jsonpickle</a> 进行JSON序列化和反序列化，保存在本地。</li></ul><h4 id="ledger包">1.2 ledger包</h4><p>ledger包定义了整个区块链结构、创世块、Merkle tree结构以及实现了Merkle tree快速验证方法。</p><h4 id="crypto包">1.3 crypto包</h4><p>crypto包是对Indy-Crypto项目部分功能的封装，主要实现了BLS多重签名。（<strong>注：</strong>BLS多重签名将在Indy-Crypto项目中详细说明）</p><h4 id="存储组件">1.4 存储组件</h4><figure><img src="./storages.png" alt="img"><figcaption>img</figcaption></figure><p>在Ledger组件中默认使用RocksDB和LevelDB进行KV存储，且使用<a href="https://blog.ethereum.org/2015/11/15/merkling-in-ethereum/" target="_blank" rel="noopener"><strong>Merkle Patricia Trie</strong></a> 存储账本状态。每个节点均维护四个账本：</p><ul><li>Audit Ledger：主要负责与其他三个Ledger同步，为失败节点恢复数据，并对账本正确性进行审计；</li><li>Pool Ledger：主要维护池中节点的信息（Membership）；</li><li>Domain Ledger：为主要账本，记录交易；</li><li>Config Ledger：是Pool节点的配置账本。</li></ul><h4 id="底层性能">1.5 底层性能</h4><p>目前暂未有数据文件表明Plenum的性能指标，还需进一步实际测试。</p><p>TODO: 测试Plenum性能指标。</p><h3 id="indy-node">2. Indy-Node</h3><figure><img src="./Indy-Node.png" alt="Indy-Node.png"><figcaption>Indy-Node.png</figcaption></figure><p>Indy-Node项目主要实现了基于Plenum BFT共识协议的分布式账本，以及节点的功能。主要包括：处理读写请求、定义交易类型以及交易分类存储。</p><p>接下来将按照项目文件的主体部分进行逐层解析。</p><h4 id="indy-node-1">2.1 indy-node</h4><p>Indy-node包主要实现基于Plenum BFT共识协议的分布式账本、对交易读写请求的处理以及提供了对特定交易的支持，各类交易都会记录到不同种类的Ledger中：</p><ul><li>存储到Domain Ledger的交易：<ul><li><strong>NYM</strong>：NYM交易主要实现创建新DID、对已存在的DID用户进行角色变更（<strong>注：</strong>角色变更涉及到权限管理，可查看<code>交易权限管理</code>部分的详情）<strong>DID Document</strong>就是对NYM交易进行溯源，即可得到一份完整的DID Document；</li><li>ATTRIB：主要实现对已有NYM添加一个属性；</li><li>SCHEMA：增加一个声明模板，模板主要包含：<code>属性名</code>、<code>模板名</code>、<code>模板版本号</code>；</li><li>CLAIM_DEF：对一个声明进行定义，由<code>Issuer</code>创建并公开，若要对一个声明进行升级，需要用新的Issuer DID进行新的声明，主要包含：<code>声明公钥</code>、<code>声明撤销公钥</code>、<code>签名类型（只支持CL签名算法）</code>；</li></ul></li><li>存储到Pool Ledger的交易：<ul><li>NODE：在池中添加一个节点，或更新一个池中的节点；</li></ul></li><li>存储到Config Ledger的交易：<ul><li>POOL_UPGRADE：由Trustee发起，升级Pool中的配置，也可更新池中特定的节点设置；</li><li>NODE_UPGRADE：记录节点升级后的节点状态，由升级的节点发出；</li><li>POOL_CONFIG：更改池中的配置。</li></ul></li></ul><h4 id="indy-common">2.2 indy-common</h4><p>indy-common包主要定义了角色权限，以及一些对Indy-Plenum项目方法的封装。</p><h4 id="dev-setupevironment">2.3 dev-setup/evironment</h4><p>dev-setup包和evironment包提供了节点部署方案，可以在本机部署（目前只支持Ubuntu、macOS），也可以部署在容器Docker上，可以部署在云端。</p><h4 id="交易权限管理">2.4 交易权限管理</h4><p>Indy中节点可分为<code>common user</code>，<code>trust anchor</code>，<code>steward</code>，<code>trustee</code> 四类，每种特殊交易都有特定的角色权限才可以进行。具体可看<a href="https://hyperledger-indy.readthedocs.io/projects/node/en/latest/auth_rules.html" target="_blank" rel="noopener">链接</a>。</p><h3 id="indy-sdk">3. Indy-SDK</h3><figure><img src="./Indy-SDK.png" alt="Indy-SDK.png"><figcaption>Indy-SDK.png</figcaption></figure><p>Indy-SDK作为Plenum分布式账本的SDK，主要是实现了代理端软件Agent可以与分布式账本、DID钱包以及DID doc进行互通，实现凭证Credential，为不同编程语言封装了主要功能。</p><h4 id="libindy">3.1 libindy</h4><p>如上图所示，libindy包主要面向应用提供了基础的区块构建方法，实现了对钱包Wallet、凭证Credential以及DID的操作，且提供不同编程语言调用的封装。并基于SDK提供了命令行工具CLI。</p><h5 id="credential">Credential</h5><p>Indy Credential工作流图如下图所示： <img src="./工作流图.svg" alt="工作流图"></p><ol type="1"><li><strong>Issuer生成凭证模板(Create Credential Schema)</strong>: Issuer创建某个凭证Schema，并将Schema交易发送给Ledger；</li><li><strong>Issuer生成凭证定义(Create Credential Definition)</strong>: Issuer想Ledger发送获取某个凭证Schema请求，得到Schema后创建凭证定义，存储公私钥对和正确性证明在本地，将该种凭证定义发送给Ledger；</li><li><strong>Issuer生成凭证撤销表(Create Revocation Registry)</strong>: Issuer生成凭证撤销表，并将撤销表入口、撤销表定义发送到Ledger；</li><li><strong>Prover生成主密钥(Create Master secret)</strong>: Prover生成主密钥，并保存在本地；</li><li><strong>Issuer生成凭证提议(Create Credential Offer)</strong>: Issuer想要发行凭证给Prover，向wallet请求，wallet获取对应的正确性证明，再讲cred_offer消息发送给Prover；</li><li><strong>Prover请求，Issuer发行凭证(Request and Issue Credential)</strong>: Prover收到cred_offer消息，向Ledger发送GET_CRED_DEF请求，填写好相应的表单之后生成凭证请求发送给Issuer；Issuer正式发行凭证给Prover，并向Ledger更新凭证撤销表入口；Prover获得凭证后向Ledger验证凭证有效，保存在本地；</li><li><strong>Prover展示凭证(Show Credential on UI)</strong>: Prover向wallet请求，wallet返回对应Credential；</li><li><strong>Prover向Verifier展示凭证(Present Credential to 3rd Party(proof request))</strong>: Verifier发起证明请求，Prover给出相应的凭证，并向Ledger核实该凭证的撤消状态，确认之后便将凭证发送给Verifier；Verifier拿到凭证向Ledger核实；</li><li><strong>Issuer撤销凭证(Revoke Credential)</strong>： Issuer获取密钥和撤销注册表，并向Ledger同步撤销注册表的入口。</li></ol><p>(<strong>注</strong>：Credential相关密码学部分将会在Indy-Crypto部分详细说明)</p><h5 id="command-line-interface">Command Line Interface</h5><p>CLI组件设计如下图所示：</p><figure><img src="./cli-components.svg" alt="cli-components"><figcaption>cli-components</figcaption></figure><h5 id="wallet">Wallet</h5><p>Wallet组件设计如下图所示：</p><figure><img src="./wallet-components.svg" alt="Wallet Components"><figcaption>Wallet Components</figcaption></figure><p>在Secrets API，允许调用密钥生成、DID生成等需要访问加密实体的方法；在Non-secrets API只允许访问存取wallet中特定的DID数据。Wallet API提供方法将钱包记录在本地SQL数据库中存取。</p><h5 id="decentrailized-key-management">Decentrailized Key Management</h5><p>相关文档并不多，只介绍了当密钥丢失时的措施：</p><ul><li>离线物理恢复密钥；</li><li>需要trustee级别的用户进行恢复；</li><li>考虑到安全性，恢复往往需要与密钥轮换和撤销相结合。</li></ul><p>此外，在官方文档中提到了使用Shamir Secret Sharing Scheme是通过分布式密钥碎片存储，在密钥丢失时，只需要将碎片重新整合起来即可恢复。（<strong>注</strong>：Shamir Secret Sharing Scheme会在Indy-Crypto中简单介绍）</p><h4 id="libvcx">3.2 libvcx</h4><p>libvcx包实现了一种Agent-2-Agent的通信协议，用于credentials的交换。主要还是使用JSON进行通信，通信时使用SSL证书进行加密通信。（<strong>注</strong>：Credential的选择性披露将在Indy-Crypto中详细说明）</p><h3 id="indy-agent">4. Indy-Agent</h3><p>Indy-Agent项目是一个基于Indy-SDK实现的代理客户端的合集，目前已有多种语言的客户端实现。</p><h3 id="indy-crypto">5. Indy-Crypto</h3><p>Indy-Crypto项目是Hyperledger URSA密码库的一部分，主要在Indy项目使用的密码学方法有： <code>BLS多签算法</code> ， <code>CL群签名算法</code> 。其中，Indy使用BLS多签算法，减少Plenum共识算法的轮训，减少签名长度；Indy使用CL群签名算法对Credential进行选择性披露，实现零知识证明。</p><h4 id="bls-multi-sign16">5.1 <a href="https://eprint.iacr.org/2018/483" target="_blank" rel="noopener">BLS multi-sign</a></h4><h5 id="准备阶段">1). 准备阶段</h5><p>有两个哈希方程 <span class="math inline">\(H_0: \{ 0, 1 \} ^* \rightarrow \Bbb{G}_2\)</span> ， <span class="math inline">\(H_1: \{ 0, 1 \}^* \rightarrow \Bbb{Z}_q\)</span></p><p>$ H_0$是将元素哈希到 <span class="math inline">\(\Bbb{G}_2\)</span> 群，<span class="math inline">\(H_1\)</span>是将元素哈希到q阶整数群。</p><h5 id="参数生成">2). 参数生成</h5><p><span class="math inline">\(Pg(k): par \leftarrow (q, \Bbb{G}_1,\Bbb{G}_2, \Bbb{G}_t,e,g_1,g_2) \leftarrow G(k)\)</span></p><p>生成一个双线性配对群，其中q是阶数，$ _1, _2$ 是q阶群，<span class="math inline">\(e : \Bbb{G}_t \leftarrow \Bbb{G}_1 × \Bbb{G}_2\)</span> 是一种映射关系，<span class="math inline">\(g_1,g_2\)</span> 分别是 $ _1, _2$ 的生成子。</p><h5 id="密钥生成">3). 密钥生成</h5><p><span class="math inline">\(Kg(par) : sk \xleftarrow{random} \Bbb{Z}_q ; pk \leftarrow g_2^{sk}\)</span></p><p>在整数群众随机抽取得出私钥 <span class="math inline">\(sk\)</span> ，公钥 <span class="math inline">\(pk\)</span> 由私钥计算得出。</p><h5 id="公钥聚合">4). 公钥聚合</h5><p><span class="math inline">\(KAg({pk_1,…,pk_n}) : apk \leftarrow \prod_{i=1}^n{pk_i^{H_1(pk_i, \{ pk_1,…,pk_n \} )}}\)</span></p><p>将所有的用户公钥都聚合起来，最终形成一个聚合公钥 <span class="math inline">\(apk\)</span> 。</p><h5 id="签名">5). 签名</h5><p><span class="math inline">\(Sign(par, \{ pk_1,…,pk_n \} ,sk,m) : s_i \leftarrow H_0(m)^{a_i \cdot sk_i} , where\ a_i \leftarrow H_1(pk_i, \{ pk_1,…,pk_n \} )\)</span></p><p>每个用户 <span class="math inline">\(i\)</span> 对消息 <span class="math inline">\(m\)</span> 用私钥签名，得出签名 <span class="math inline">\(s_i\)</span></p><p><span class="math inline">\(\sigma \leftarrow \prod_{j=1}^n s_j\)</span></p><p>再将签名发给一个节点，节点进行聚合计算，生成聚合签名 <span class="math inline">\(\sigma\)</span></p><h5 id="验证">6). 验证</h5><p><span class="math inline">\(Vf(par,apk,m, \sigma ) : \ e( \sigma , g_2^{-1}) \cdot e(H_0(m),apk) = 1_{ \Bbb{G}_t}\)</span></p><p>将聚合公钥和聚合签名输入，进行两次双线性配对，若上面的式子成立，则说明验证成功；否则失败。</p><h4 id="camenisch-lysyanskaya-sign17">5.2 <a href="https://link.springer.com/chapter/10.1007%2F3-540-36413-7_20" target="_blank" rel="noopener">Camenisch-Lysyanskaya Sign</a></h4><h5 id="准备阶段-1">1). 准备阶段</h5><p>有一个哈希方程 <span class="math inline">\(Hash: \{ 0, 1 \} ^* \rightarrow \Bbb{Z}_q\)</span></p><p><span class="math inline">\(Hash\)</span> 函数是将元素哈希到q阶整数群。</p><h5 id="参数生成-1">2). 参数生成</h5><p><span class="math inline">\(Pg(k): par \leftarrow (q,\Bbb{G}, \Bbb{G}_t,e,g) \leftarrow G(k)\)</span></p><p>生成一个双线性配对群，其中q是阶数，$ $ 是q阶群，<span class="math inline">\(e : \Bbb{G}_t \leftarrow \Bbb{G} × \Bbb{G}\)</span> 是一种映射关系，<span class="math inline">\(g\)</span> 是 <span class="math inline">\(\Bbb{G}\)</span> 的生成子。</p><h5 id="密钥生成-1">3). 密钥生成</h5><p><span class="math inline">\(Kg(par) : sk_1,sk_2 \xleftarrow{random} \Bbb{Z}_q ; pk_1 \leftarrow g^{sk_1}; \ pk_2 \leftarrow g^{sk_2}\)</span></p><p>在整数群众随机抽取得出子私钥 <span class="math inline">\(sk_1,sk_2\)</span> ，子公钥 <span class="math inline">\(pk_1,pk_2\)</span> 由私钥计算得出。</p><p>最终输出私钥： <span class="math inline">\(SK=(sk_1,sk_2)\)</span> ， 公钥： <span class="math inline">\(PK=(par,pk_1,pk_2)\)</span> 。</p><h5 id="签名-1">4). 签名</h5><p>输入 <span class="math inline">\(message\)</span> ，生成消息 <span class="math inline">\(M \leftarrow Hash(message)\)</span> ，在群 $  $ 随机选取随机数 <span class="math inline">\(A \in \Bbb{G}\)</span> , 计算 <span class="math inline">\(B \leftarrow A^{sk_2}, \ C \leftarrow A^{sk_1}B^{sk_1 \cdot M}\)</span> ，最终输出对消息 <span class="math inline">\(M\)</span> 的签名：$ (A,B,C)$ 。</p><h5 id="验证-1">5). 验证</h5><p>输入对消息 <span class="math inline">\(M\)</span> 的签名 $ (A,B,C)$ ，使用公钥 <span class="math inline">\(PK\)</span> 验证，若</p><p><span class="math inline">\(e(A,pk_2)=e(B,g)\)</span> 且 <span class="math inline">\(e(C,g)=e(A,pk_1) \cdot e(B,pk_1)^M\)</span> 则验证成功。</p><h4 id="anonymous-credentials-with-type-3-revocation">5.3 Anonymous credentials with type-3 revocation</h4><p>这是Indy项目中Credential（凭证）的整体方案，包括<strong>凭证颁发</strong>、<strong>凭证存储</strong>、<strong>凭证选择性披露与验证</strong>、<strong>凭证撤销</strong>。</p><p>在整个Credential的方案中有三种角色：issuer（凭证发行人）、holder（凭证持有人）、verifier（验证者）。这种方案是基于Camenisch-Lysyanskaya Sign方案改进的，可实现选择性披露、“一次性”凭证的功能。</p><p>详情可看这个<a href="https://github.com/hyperledger/indy-crypto/blob/master/libindy-crypto/docs/AnonCred.pdf" target="_blank" rel="noopener">PDF文档</a> （建议由密码学功底的人看）</p><h4 id="shamir-secret-sharing-scheme">5.4 Shamir Secret Sharing Scheme</h4><p>TODO</p><h2 id="四hyperledger-aries">四、Hyperledger Aries</h2><p><a href="https://github.com/hyperledger/aries" target="_blank" rel="noopener"><strong>Hyperledger Aries</strong></a> 是今年5月Hyperledger宣布开源的项目，目前该项目还处于初始阶段，Aires 的产品包括:</p><ul><li>用于创建和签名区块链事务的区块链接口层（称为解析器）</li><li>安全存储（安全存储技术）用于构建区块链客户机加密信息和其他信息的加密钱包</li><li>一种加密的消息传递系统，用于使用多种传输协议在客户端之间进行账外交互</li><li>使用 Ursa 中的 ZKP 原语实现支持 ZKP 的 W3C 可验证凭证</li><li>一种去中心化密钥管理系统（DKMS）规范</li><li>一种基于安全消息传递功能构建的高级协议和类API用例的机制</li></ul><p>我个人认为这是Hyperledger Indy项目的一种扩展延伸，实现功能点几乎一样；</p><p><strong>但是</strong>，Indy是专注于为身份认证而建立的特定区块链，Aries是不适用区块链的项目，项目组期望能在Aries成熟之后融入Indy项目。Hyperledger之后会将Indy项目中与区块链无关的功能迁移到Aries项目，Induy专注于区块链功能。</p><h2 id="五落地案例">五、落地案例</h2><p>主要落地应用是在加拿大British Columbia省的 <a href="https://vonx.io/" target="_blank" rel="noopener">Verfiable Organizations Network(VON)</a>，该项目已开源(<a href="https://github.com/bcgov/von" target="_blank" rel="noopener">链接</a>)，目的在于帮助商人建立可信的持续的电子身份验证，从而加速申请政府机构的许可证和执照。</p><p>该项目已经在2019年1月推出上线，减少了新供应商或客户进行尽职调查的时间。下一步目标是扩展应用程序，鼓励更多的司法管辖区域使用。</p><h2 id="六推广模式">六、推广模式</h2><p>目前Indy的推广模式相关文章/报道较少(可能也是我菜，找不到/不会找 _(:3」∠)_ )</p><ul><li>以投资者的角度分析了Sovrin项目 (<a href="https://news.huoxing24.com/20181112141034187154.html" target="_blank" rel="noopener">链接</a>)</li><li>采访Sovrin主创报道文章，主要讲述了Sovrin是什么，要解决什么问题，怎么解决的，展望未来(<a href="https://sovrin.org/use-case-spotlight-the-government-of-british-columbia-uses-the-sovrin-network-to-take-strides-towards-a-fully-digital-economy/" target="_blank" rel="noopener">链接</a>)</li></ul><h2 id="七qa">七、Q&amp;A</h2><p>Q：Hyperledger Indy是否支持智能合约？</p><p>A：Indy专注于数字身份管理，Indy不是为了支持任何资产交换而开发的，而是为了解决与我们当前数字环境的问题。该项目旨在取代我们用来通过分散机制验证用户数字身份的主流机制，例如用户名 - 密码组合，这种机制更安全可靠。由于其独特的使用案例，<strong>Indy无法支持任何智能合约。</strong></p><p>Q：Authentication是如何进行的？授权的粒度？</p><p>Indy对DID、Credential以及节点的授权都有不同，详情可见<a href="https://hyperledger-indy.readthedocs.io/projects/node/en/latest/auth_rules.html" target="_blank" rel="noopener">链接</a>。</p><p>Q：是否支持多个区块链平台？</p><p>A：目前Indy项目的底层是Plenum BFT，共识并没有模块化，底层耦合度较高，所以<strong>不支持</strong>。</p><p>Q：用户和机构如何介入？</p><p>A：详情可见<a href="https://hyperledger-indy.readthedocs.io/projects/node/en/latest/add-node.html" target="_blank" rel="noopener">链接1</a>、<a href="https://hyperledger-indy.readthedocs.io/projects/node/en/latest/start-nodes.html" target="_blank" rel="noopener">链接2</a></p><p>Q：区块节点部署方式？</p><p>A：目前Indy节点支持本地部署(macOS，Ubuntu)，容器部署(docker)以及云端部署，都有一键部署工具可用。</p><h2 id="参考链接文献">参考链接/文献</h2><blockquote><ol type="1"><li><a href="https://mwherman2000.github.io/indy-arm/" target="_blank" rel="noopener">Hyperledger Indy/Sovrin/DID Comprehensive Architecture Reference Model (INDY ARM)</a></li><li><a href="https://github.com/hyperledger/indy-agent" target="_blank" rel="noopener">hyperledger/<strong>indy-agent</strong></a></li><li><a href="https://github.com/hyperledger/indy-sdk" target="_blank" rel="noopener">hyperledger/<strong>indy-sdk</strong></a></li><li><a href="https://github.com/decentralized-identity/universal-resolver" target="_blank" rel="noopener">decentralized-identity/universal-resolver</a></li><li><a href="https://github.com/hyperledger/indy-node" target="_blank" rel="noopener">hyperledger/<strong>indy-node</strong></a></li><li><a href="https://github.com/hyperledger/indy-plenum" target="_blank" rel="noopener">hyperledger/<strong>indy-plenum</strong></a></li><li><a href="https://w3c-ccg.github.io/did-spec/" target="_blank" rel="noopener">Decentralized Identifiers (DIDs) v0.13</a></li><li><a href="https://github.com/hyperledger/indy-crypto" target="_blank" rel="noopener">hyperledger/<strong>indy-crypto</strong></a></li><li><a href="https://github.com/hyperledger/indy-crypto" target="_blank" rel="noopener">hyperledger/<strong>indy-hipe</strong></a></li><li><a href="http://lig-membres.imag.fr/aublin/rbft/report.pdf" target="_blank" rel="noopener">Aublin, P.-L &amp; Mokhtar, Sonia &amp; Quéma, Vivien. (2013). RBFT: Redundant byzantine fault tolerance. Proceedings - International Conference on Distributed Computing Systems. 297-306. 10.1109/ICDCS.2013.53.</a></li><li><a href="https://hyperledger-indy.readthedocs.io/projects/plenum/en/latest/diagrams/index.html" target="_blank" rel="noopener">Plenum Diagrams</a></li><li><a href="https://download.libsodium.org/doc/" target="_blank" rel="noopener">Libsodium document</a></li><li><a href="https://github.com/jsonpickle/jsonpickle" target="_blank" rel="noopener">jsonpickle: Python library for serializing any arbitrary object graph into JSON.</a></li><li><a href="https://blog.ethereum.org/2015/11/15/merkling-in-ethereum/" target="_blank" rel="noopener">Merkling in Ethereum</a></li><li><a href="https://hyperledger-indy.readthedocs.io/projects/node/en/latest/auth_rules.html" target="_blank" rel="noopener">Current implemented rules in auth_map</a></li><li><a href="https://eprint.iacr.org/2018/483" target="_blank" rel="noopener">Dan Boneh, Manu Drijvers, and Gregory Neven. Compact multi-signatures for 62 smaller blockchains. Cryptology ePrint Archive, 2018.</a></li><li><a href="https://link.springer.com/chapter/10.1007%2F3-540-36413-7_20" target="_blank" rel="noopener">Camenisch J., Lysyanskaya A. (2003) A Signature Scheme with Efficient Protocols. In: Cimato S., Persiano G., Galdi C. (eds) Security in Communication Networks. SCN 2002. Lecture Notes in Computer Science, vol 2576. Springer, Berlin, Heidelberg</a></li><li><a href="https://github.com/hyperledger/aries" target="_blank" rel="noopener">Hyperledger Aries is infrastructure for blockchain-rooted, peer-to-peer interactions</a></li><li><a href="https://medium.com/@kctheservant/exploring-hyperledger-indy-through-indy-dev-example-10075d2547ae" target="_blank" rel="noopener">Exploring Hyperledger Indy through indy-dev Example</a></li><li><a href="https://vonx.io/" target="_blank" rel="noopener">Verifiable Organizations Network: Global digital trust for organizations</a></li><li><a href="https://github.com/bcgov/von" target="_blank" rel="noopener">Verifiable Organizations Network</a></li><li><a href="https://cn.hyperledger.org/hyperledger-indy/2019/03/11/reducing-government-red-tape-british-columbia-creates-new-business-identity-model-with-hyperledger-indy" target="_blank" rel="noopener">Reducing Government Red Tape: British Columbia Creates New Business Identity Model with Hyperledger Indy</a></li><li><a href="https://www.quora.com/Does-Hyperledger-Indy-support-any-kind-of-smart-contracts" target="_blank" rel="noopener">Does Hyperledger Indy support any kind of smart contracts?</a></li><li><a href="https://hyperledger-indy.readthedocs.io/projects/node/en/latest/add-node.html" target="_blank" rel="noopener">Add Node to Existing Pool</a></li><li><a href="https://hyperledger-indy.readthedocs.io/projects/node/en/latest/start-nodes.html" target="_blank" rel="noopener">Create a Network and Start Nodes</a></li><li><a href="https://eprint.iacr.org/2008/539.pdf" target="_blank" rel="noopener">Camenisch, J., Kohlweiss, M., Soriente, C.: An Accumulator Based on Bilinear Maps and Efficient Revocation for Anonymous Credentials. In Jarecki, S., Tsudik, G., eds.: Public Key Cryptography. Volume 5443 of Lecture Notes in Computer Science., Springer (2009) 481–500</a></li><li><a href="https://github.com/hyperledger/indy-crypto/blob/master/libindy-crypto/docs/AnonCred.pdf" target="_blank" rel="noopener">Anonymous credentials with type-3 revocation. Dmitry Khovratovich, Michael Lodder. 9 February 2018, version 0.4</a></li><li><a href="https://news.huoxing24.com/20181112141034187154.html" target="_blank" rel="noopener">TokenGazer深度研究：Sovrin，技术落地可期，但推广难度较高</a></li><li><a href="https://sovrin.org/use-case-spotlight-the-government-of-british-columbia-uses-the-sovrin-network-to-take-strides-towards-a-fully-digital-economy/" target="_blank" rel="noopener">Use case spotlight: The Government of British Columbia uses the Sovrin Network to take strides towards a fully digital economy</a></li></ol></blockquote>]]>
    </content>


    <categories>

      <category> 区块链项目 </category>

      <category> Research </category>

    </categories>


    <tags>

      <tag> blockchain </tag>

      <tag> Identity </tag>

      <tag> Hyperledger </tag>

    </tags>

  </entry>


  <entry>
    <title>Sovrin White Paper Reading</title>
    <link href="/2019/07/12/Sovrin-White-Paper-Reading/" />
    <url>/2019/07/12/Sovrin-White-Paper-Reading/</url>

    <content type="html">
      <![CDATA[<h2 id="问题描述">问题描述</h2><p>在物质世界，我们使用物理凭证来证明我们的身份（identity）我们可以有驾照来证明我们的驾驶许可、可以有学位证书来证明我们的学历、可以有技能证书来证明我们的能力；但是在互联网上，却没有等同的解决方案来向互联网端的验证者证明自己的能力、资质、拥有权。</p><p>这些问题的本质是因为，在整个互联网中没有凭证以及凭证发行验证的标准。The World Wide Web Consortium(W3C)在2017年4月对凭证进行了标准化。但如何对凭证发行方的电子签名的验证进行标准化，还存在着疑问。现有解决方案是采用PKI证书密钥体系，但是这种方案需要多次证书交互，每次进行验证都需要与证书颁发中心进行交互验证证书，且存在中心作恶的风险。</p><a id="more"></a><h2 id="sovrin给出的解决方案">Sovrin给出的解决方案</h2><p>在区块链上部署<a href="http://www.weboftrust.info/downloads/dpki.pdf" target="_blank" rel="noopener">decentralized PKI(DPKI)</a>体系结构，每个实体可以进行ID标识，生成<a href="https://w3c-ccg.github.io/did-spec/" target="_blank" rel="noopener">Decentralized Identifier(DID)</a>，这样每个实体都以同一标准生成一个身份标识，所有人都可以发行电子签名的凭证，所有人都可以验证这些凭证。</p><figure><img src="./image-20190703144357168.png" alt="image-20190703144357168"><figcaption>image-20190703144357168</figcaption></figure><h2 id="sovrin愿景">Sovrin愿景</h2><p>全球化的分布式身份识别与可验证凭证方案。这种方案可以用在所有类型的区块链，并且广泛使用程度能超过DNS。</p><h2 id="sovrin隐私保护方案">Sovrin隐私保护方案</h2><ol type="1"><li><p><strong>Pseudonymity by default</strong> 成对且唯一的DID和公钥；</p></li><li><p><strong>Private agents by default</strong> 任何隐私数据都不会上链；</p><figure><img src="./image-20190703161333818.png" alt="image-20190703161333818"><figcaption>image-20190703161333818</figcaption></figure></li><li><p><strong>Selective disclosure by default</strong> 使用零知识证明的方法，对有选择地披露声明信息，保证隐私安全。</p><figure><img src="./image-20190703161524192.png" alt="image-20190703161524192"><figcaption>image-20190703161524192</figcaption></figure></li></ol><h2 id="参考文献">参考文献</h2><blockquote><ol type="1"><li><a href="https://sovrin.org/wp-content/uploads/Sovrin-Protocol-and-Token-White-Paper.pdf" target="_blank" rel="noopener">Sovrin-Protocol-and-Token-White-Paper1</a></li><li><a href="http://www.weboftrust.info/downloads/dpki.pdf" target="_blank" rel="noopener">Decentralized Public Key Infrastructure: A White Paper from Rebooting the Web of Trust</a></li><li><a href="https://w3c-ccg.github.io/did-spec/" target="_blank" rel="noopener">W3C: Decentralized Identifiers (DIDs) v0.13</a></li></ol></blockquote>]]>
    </content>


    <categories>

      <category> 区块链项目 </category>

    </categories>


    <tags>

      <tag> blockchain </tag>

      <tag> Identity </tag>

    </tags>

  </entry>


  <entry>
    <title>Facebook Libra区块链白皮书研读</title>
    <link href="/2019/06/24/Libra-whitepaper-study/" />
    <url>/2019/06/24/Libra-whitepaper-study/</url>

    <content type="html">
      <![CDATA[<h2 id="简述">简述</h2><p>Facebook这次发起的新区块链虚拟货币在技术层面上并未看到有大的革新，与现有的虚拟货币区别不大。从现在的白皮书以及技术文档上所指，最大的特点是<strong>币的价值和真实资产储备相挂钩</strong>，相对于比特币，波动性较小，价值更平稳，这更像是一种有政府背书的数字货币。</p><p>Libra使用了新的编程语言来编写智能合约，设计了基于拜占庭容错的共识算法LibraBFT，如何能承受住全球这么打的用户量，如何，这些问题在技术论文上也没有披露太多信息。</p><a id="more"></a><h2 id="应用背景">应用背景</h2><ol type="1"><li>现有区块链缺乏可扩展性，加密货币具有波动性，到目前为止，这些因素导致现有的加密货币在保值和交换媒介方面均表现欠佳，因而阻碍了它们在市场上的广泛使用。</li><li>一些项目还试图破坏现有体系并绕过监管，而不是在合规和监管方面进行创新，以提高反洗钱举措的效力。</li><li>携手金融部门(包括各个行业的监管机构和专家)进行合作和创新，是确保为这一新体系建立可持续、安全和可信的支撑框架的唯一途径。</li></ol><h2 id="应用愿景">应用愿景</h2><ol type="1"><li>Libra 的使命是<strong>建立一套简单的、无国界的货币和为数十亿人服务的金融基础设施</strong>。</li><li>Libra 完全由<strong>真实资产储备提供支持</strong>。对于每个新创建的Libra 加密货币，在 Libra 储备中都有相对应价值的银行存款和短期政府债券，以此建立人们对其<strong>内在价值的信任</strong>，并以此维持<strong>加密货币的价值稳定</strong>。</li><li>Libra协会成员包括分布在不同地理区域的各种企业、非营利组织、多边组织和学术机构。包含PayPal、Visa等支付业巨头，eBay、Uber、Booking等交易平台。</li><li>任何消费者、开发者或公司都可以使用 Libra 网络、在这个网络上构建产品，并通过他们的服务实现增值作用。</li></ol><h2 id="技术特色">技术特色</h2><ol type="1"><li>目标是扩展到数十亿账户，要求具有极高的交易吞吐量和低延迟；</li><li>设计和使用全新的Move编程语言，用于智能合约编程；</li><li>采用拜占庭容错共识机制，设计使用LibraBFT；</li></ol><h2 id="参考链接">参考链接</h2><p>[1]. <a href="https://libra.org/zh-CN/white-paper/" target="_blank" rel="noopener">Libra中文白皮书</a> [2]. <a href="https://developers.libra.org/docs/assets/papers/the-libra-blockchain.pdf" target="_blank" rel="noopener">Libra技术论文</a> [3]. <a href="https://developers.libra.org" target="_blank" rel="noopener">Libra开发文档</a></p>]]>
    </content>


    <categories>

      <category> 区块链项目 </category>

    </categories>


    <tags>

      <tag> blockchain </tag>

    </tags>

  </entry>


  <entry>
    <title>区块链实验课简易教程</title>
    <link href="/2019/05/29/blockchain-easy-test/" />
    <url>/2019/05/29/blockchain-easy-test/</url>

    <content type="html">
      <![CDATA[<p>这是一个使用 Python3 + flask 写的简单平台，主要目的是体验区块链的场景。</p><p>项目库：https://github.com/dvf/blockchain</p><h2 id="一实验目标">一、实验目标</h2><ol type="1"><li>熟悉区块数据结构，了解哈希算法；</li><li>简单了解哈希碰撞(挖矿)的流程，并对发起新交易流程有所了解；</li><li>熟悉区块链的不可篡改性、顺序性，以及区块链分叉时的场景。</li></ol><h2 id="二实验基础">二、实验基础</h2><p>本实验涉及到以下必要知识点：</p><ol type="1"><li>掌握Python语言知识点，熟悉Python程序构建方法，了解flask web框架；</li><li>熟练使用 *nix系统，熟悉命令行操作（Windows也可）；</li><li>掌握HTTP协议，熟悉状态返回值的含义；</li><li>会使用普通IDE，会使用Postman等工具测试API。</li></ol><a id="more"></a><h2 id="三实验步骤">三、实验步骤</h2><h3 id="实验环境依赖">1. 实验环境依赖</h3><blockquote><p>Git</p><p>python version &gt;= 3.6</p><p>flask == 0.12.2</p><p>requests == 2.18.4</p></blockquote><p><a href="https://www.python.org/downloads/" target="_blank" rel="noopener">Python下载</a></p><p><a href="https://git-scm.com/downloads" target="_blank" rel="noopener">Git下载</a></p><h3 id="实验环境搭建">2. 实验环境搭建</h3><p>PS：在这里的命令行操作主要面向 *nix 系统。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 在适当的目录下拉取库</span><br><span class="line"><span class="meta">$</span> git clone https://github.com/dvf/blockchain.git</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 检查python版本号 &gt;= 3.6</span><br><span class="line">python --version</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 下载pipenv</span><br><span class="line"><span class="meta">$</span> pip install pipenv</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 在当前代码根目录下</span><br><span class="line"><span class="meta">$</span> pipenv install</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 启动服务器 (默认端口是5000) -p 设定端口号</span><br><span class="line"><span class="meta">$</span> pipenv run python blockchain.py</span><br><span class="line"><span class="meta">#</span> 起多个服务 PS：注意端口冲突</span><br><span class="line"><span class="meta">$</span> pipenv run python blockchain.py -p 5001</span><br></pre></td></tr></table></figure><p>另：可使用Docker标准环境搭建，可供不希望更改python环境的用户使用。</p><p>(<strong>注意</strong> 这是另外一种实验环境搭建方法，上面做完可不做这一步)</p><p>Docker桌面工具下载地址：<a href="https://www.docker.com/products/docker-desktop" target="_blank" rel="noopener">Docker Desktop for Mac and Windows</a></p><p>命令行下载(面向Ubuntu) ：<a href="https://docs.docker.com/install/linux/docker-ce/ubuntu/" target="_blank" rel="noopener">Get Docker CE for Ubuntu</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 在适当的目录下拉取库</span><br><span class="line"><span class="meta">$</span> git clone https://github.com/dvf/blockchain.git</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 确保docker服务已经在运行，构建镜像</span><br><span class="line"><span class="meta">$</span> docker build -t blockchain .</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 起容器，-p 端口映射，外部通过端口80，访问容器内5000端口的服务</span><br><span class="line"><span class="meta">$</span> docker run --rm -p 80:5000 blockchain</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 起多个容器服务 注意端口</span><br><span class="line"><span class="meta">$</span> docker run --rm -p 81:5000 blockchain</span><br></pre></td></tr></table></figure><h3 id="与区块链进行交互">3. 与区块链进行交互</h3><p>实验很简单，使用API工具对服务器发起HTTP请求，也可以使用古老的<code>cURL</code>来替代Postman工具访问API。</p><p><a href="https://www.getpostman.com/downloads/" target="_blank" rel="noopener">Postman Download</a></p><p>API总共5中方法：</p><ol type="1"><li><code>/chain</code>：返回当前区块链表</li><li><code>/mine</code>：进行挖矿，生产一个区块</li><li><code>/transactions/new</code>：产生一笔新交易</li><li><code>/nodes/register</code>：节点注册，将多个节点绑定到一起</li><li><code>/nodes/resolve</code>：区块链同步</li></ol><h4 id="chain-方法测试">1). /chain 方法测试</h4><p>使用Postman 发送GET方法HTTP请求</p><figure><img src="./shotcut1.png" alt="shotcut1"><figcaption>shotcut1</figcaption></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> cURL方式访问</span><br><span class="line"><span class="meta">$</span> curl -X GET "http://localhost:5000/chain"</span><br></pre></td></tr></table></figure><p>可以看到区块链的结构如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"chain"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"index"</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="attr">"previous_hash"</span>: <span class="string">"1"</span>,</span><br><span class="line">      <span class="attr">"proof"</span>: <span class="number">100</span>,</span><br><span class="line">      <span class="attr">"timestamp"</span>: <span class="number">1558874710.4303942</span>,</span><br><span class="line">      <span class="attr">"transactions"</span>: []</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"length"</span>: <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创世块的<code>index</code>为1，<code>transactions</code>内不包含交易。</p><h4 id="mine-方法测试">2). /mine 方法测试</h4><p>使用Postman 发送GET方法HTTP请求</p><figure><img src="./shotcut2.png" alt="image-20190526204644640"><figcaption>image-20190526204644640</figcaption></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> cURL方式访问</span><br><span class="line"><span class="meta">$</span> curl -X GET "http://localhost:5000/mine"</span><br></pre></td></tr></table></figure><p>可以看到服务器将交易池的所有交易打包产生了一个新的区块<code>index2</code>，并计算了前一块的哈希值。</p><p>若交易池内没有交易，系统默认产生<code>sender</code>为0的交易，方便演示 :)</p><p>这时，再调用<code>/chain</code>方法，查看返回的记录，有什么变化？测试<code>previous_has</code>是否就是前一块的哈希。</p><h4 id="transactionsnew方法测试">3). /transactions/new方法测试</h4><p>使用Postman 发送POST方法HTTP请求，这里需要使用JSON格式写入body。</p><figure><img src="./shotcut3.png" alt="image-20190526204808458"><figcaption>image-20190526204808458</figcaption></figure><p>如上图所示，alice向bob发出数量为1的交易。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> cURL方式访问</span><br><span class="line"><span class="meta">$</span> curl -X POST -H "Content-Type: application/json" -d '&#123;</span><br><span class="line"> "sender": "alice",</span><br><span class="line"> "recipient": "bob",</span><br><span class="line"> "amount": 1</span><br><span class="line">&#125;' "http://localhost:5000/transactions/new"</span><br></pre></td></tr></table></figure><p>这笔交易将会发到交易池，等待矿工将它打包到区块里。</p><p>这时，再调用<code>/mine</code>方法，查看返回的记录，有什么变化？</p><h4 id="nodesregister方法测试">4). /nodes/register方法测试</h4><p>在这里，需要两个以上服务端，即两个以上终端进行操作。</p><p><strong>注意</strong>：这里分为两种情况，<strong>使用pipenv配置的环境</strong>，<strong>使用Docker</strong>配置的环境，请按已有的环境登记节点。</p><h5 id="使用pipenv配置的环境">使用pipenv配置的环境</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 在代码根目录内，重新起一个服务，注意端口要设置成不一样</span><br><span class="line"><span class="meta">$</span> pipenv run python blockchain.py -p 5001</span><br></pre></td></tr></table></figure><p>使用Postman 发送POST方法的HTTP请求，这里需要填入JSON格式写入body。</p><p><strong>注意</strong>：这里填入的node是你新起的服务端口，可以有一个，可以有多个</p><figure><img src="./shocut4.png" alt="image-20190526204930747"><figcaption>image-20190526204930747</figcaption></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> cURL方式访问</span><br><span class="line"><span class="meta">$</span> curl -X POST -H "Content-Type: application/json" -d '&#123;</span><br><span class="line">    "nodes": ["http://0.0.0.0:5001"]</span><br><span class="line">&#125;' "http://localhost:5000/nodes/register"</span><br></pre></td></tr></table></figure><p>在 http://0.0.0.0:5001 的服务节点也要用<code>/nodes/register</code>方法把端口<code>5000</code>的服务节点加进去，数据就可以互通。</p><h5 id="使用docker配置的环境">使用Docker配置的环境</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 重起一个新的节点</span><br><span class="line"><span class="meta">$</span> docker run --rm -p 81:5000 blockchain</span><br></pre></td></tr></table></figure><p>在登记节点时，需要知道本机的本地ip(local IP)，在这里假设本地IP是<code>196.128.0.1</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> cURL方式访问</span><br><span class="line"><span class="meta">#</span> 在80端口登记81端口的服务</span><br><span class="line"><span class="meta">$</span> curl -X POST -H "Content-Type: application/json" -d '&#123;</span><br><span class="line">    "nodes": ["http://196.128.0.1:81"]</span><br><span class="line">&#125;' "http://localhost:80/nodes/register"</span><br></pre></td></tr></table></figure><p><strong>同样的</strong>，在81端口也需要登记80端口的服务。</p><h4 id="nodesresolve方法测试">5). /nodes/resolve方法测试</h4><p>在刚才起的新服务节点<code>5001</code>端口(端口号因人而异)，调用<code>/chain</code>方法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> curl -X GET "http://localhost:5001/chain"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>返回</span><br><span class="line">&#123;</span><br><span class="line">  "chain": [</span><br><span class="line">    &#123;</span><br><span class="line">      "index": 1,</span><br><span class="line">      "previous_hash": "1",</span><br><span class="line">      "proof": 100,</span><br><span class="line">      "timestamp": 1558874708.5040278,</span><br><span class="line">      "transactions": []</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  "length": 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，还是空的，只有1个区块。</p><p>这时调用<code>/nodes/resolve</code>方法与登记好节点的区块链进行同步拉取。</p><p>例如，<code>5000</code>端口现在的区块链如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> curl -X GET "http://localhost:5000/chain"</span><br><span class="line">&#123;</span><br><span class="line">  "chain": [</span><br><span class="line">    &#123;</span><br><span class="line">      "index": 1,</span><br><span class="line">      "previous_hash": "1",</span><br><span class="line">      "proof": 100,</span><br><span class="line">      "timestamp": 1558874710.4303942,</span><br><span class="line">      "transactions": []</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      "index": 2,</span><br><span class="line">      "previous_hash": "43417cdaeda03ca51a0959828b681e52a95c0ea77f8544114b1b9f4358dd3bbc",</span><br><span class="line">      "proof": 5363,</span><br><span class="line">      "timestamp": 1558874791.834334,</span><br><span class="line">      "transactions": [</span><br><span class="line">        &#123;</span><br><span class="line">          "amount": 1,</span><br><span class="line">          "recipient": "2adafd5dd2184a989289f38a02d35a9e",</span><br><span class="line">          "sender": "0"</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      "index": 3,</span><br><span class="line">      "previous_hash": "c22e009dd1d09a08b681013b5c0bd8c9f7e798483186562c9ab7f98370c035f2",</span><br><span class="line">      "proof": 31893,</span><br><span class="line">      "timestamp": 1558875113.180196,</span><br><span class="line">      "transactions": [</span><br><span class="line">        &#123;</span><br><span class="line">          "amount": 1,</span><br><span class="line">          "recipient": "bob",</span><br><span class="line">          "sender": "alice"</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          "amount": 1,</span><br><span class="line">          "recipient": "2adafd5dd2184a989289f38a02d35a9e",</span><br><span class="line">          "sender": "0"</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  "length": 3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在调用5001端口的<code>/nodes/resolve</code>方法进行同步：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> curl -X GET "http://0.0.0.0:5001/nodes/resolve"</span><br><span class="line">&#123;</span><br><span class="line">  "message": "Our chain was replaced",</span><br><span class="line">  "new_chain": [</span><br><span class="line">    &#123;</span><br><span class="line">      "index": 1,</span><br><span class="line">      "previous_hash": "1",</span><br><span class="line">      "proof": 100,</span><br><span class="line">      "timestamp": 1558874710.4303942,</span><br><span class="line">      "transactions": []</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      "index": 2,</span><br><span class="line">      "previous_hash": "43417cdaeda03ca51a0959828b681e52a95c0ea77f8544114b1b9f4358dd3bbc",</span><br><span class="line">      "proof": 5363,</span><br><span class="line">      "timestamp": 1558874791.834334,</span><br><span class="line">      "transactions": [</span><br><span class="line">        &#123;</span><br><span class="line">          "amount": 1,</span><br><span class="line">          "recipient": "2adafd5dd2184a989289f38a02d35a9e",</span><br><span class="line">          "sender": "0"</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      "index": 3,</span><br><span class="line">      "previous_hash": "c22e009dd1d09a08b681013b5c0bd8c9f7e798483186562c9ab7f98370c035f2",</span><br><span class="line">      "proof": 31893,</span><br><span class="line">      "timestamp": 1558875113.180196,</span><br><span class="line">      "transactions": [</span><br><span class="line">        &#123;</span><br><span class="line">          "amount": 1,</span><br><span class="line">          "recipient": "bob",</span><br><span class="line">          "sender": "alice"</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          "amount": 1,</span><br><span class="line">          "recipient": "2adafd5dd2184a989289f38a02d35a9e",</span><br><span class="line">          "sender": "0"</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，5001端的区块链已经完全和5000端的同步了。</p><h3 id="处理区块链分叉">4. 处理区块链分叉</h3><p>此时，<code>5000</code>和<code>5001</code>两个节点的区块链都是完全一致的。若在5000端和5001端同时进行一次交易，那么会出现什么结果呢？两个节点的链长是一样的，最后是谁同步谁的？</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 在5000端，alice给bob发10块</span><br><span class="line"><span class="meta">$</span> curl -X POST -H "Content-Type: application/json" -d '&#123;</span><br><span class="line"> "sender": "alice",</span><br><span class="line"> "recipient": "bob",</span><br><span class="line"> "amount": 10</span><br><span class="line">&#125;' "http://localhost:5000/transactions/new"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 在5001端，bob给alice发10块</span><br><span class="line"><span class="meta">$</span> curl -X POST -H "Content-Type: application/json" -d '&#123;</span><br><span class="line"> "sender": "bob",</span><br><span class="line"> "recipient": "alice",</span><br><span class="line"> "amount": 10</span><br><span class="line">&#125;' "http://localhost:5001/transactions/new"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 在两个节点，都生成一个区块</span><br><span class="line"><span class="meta">$</span> curl -X GET "http://0.0.0.0:5000/mine"</span><br><span class="line"><span class="meta">$</span> curl -X GET "http://0.0.0.0:5001/mine"</span><br></pre></td></tr></table></figure><p>此时，在5000端调用<code>/nodes/resolve</code>方法将不会和5001端的同步，反之也是。</p><p>当两个节点之中，有一个节点先于另一个节点出块，那么另一个节点将会遵从先出快节点的区块链。Have a try :)</p><h3 id="修改哈希碰撞难度">5. 修改哈希碰撞难度</h3><p>修改哈希碰撞难度，可有效降低出块的时间。</p><p>在<code>blockchain.py</code>文件 178行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">valid_proof</span><span class="params">(last_proof, proof, last_hash)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Validates the Proof</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :param last_proof: &lt;int&gt; Previous Proof</span></span><br><span class="line"><span class="string">        :param proof: &lt;int&gt; Current Proof</span></span><br><span class="line"><span class="string">        :param last_hash: &lt;str&gt; The hash of the Previous Block</span></span><br><span class="line"><span class="string">        :return: &lt;bool&gt; True if correct, False if not.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        guess = <span class="string">f'<span class="subst">&#123;last_proof&#125;</span><span class="subst">&#123;proof&#125;</span><span class="subst">&#123;last_hash&#125;</span>'</span>.encode()</span><br><span class="line">        guess_hash = hashlib.sha256(guess).hexdigest()</span><br><span class="line">        <span class="comment"># 在这里修改，0的个数要与数字一致</span></span><br><span class="line">        <span class="comment"># 数字越大，0越多，哈希碰撞难度越大</span></span><br><span class="line">        <span class="keyword">return</span> guess_hash[:<span class="number">4</span>] == <span class="string">"0000"</span></span><br></pre></td></tr></table></figure>]]>
    </content>


    <categories>

      <category> 记录 </category>

    </categories>


    <tags>

      <tag> blockchain </tag>

      <tag> Python </tag>

    </tags>

  </entry>


  <entry>
    <title>Hexo+GoDaddy+GitHub Pages 构建一个属于自己的博客平台</title>
    <link href="/2019/05/20/how-i-build-this-website/" />
    <url>/2019/05/20/how-i-build-this-website/</url>

    <content type="html">
      <![CDATA[<h2 id="关于博客">关于博客</h2><p>学习技术总是无底洞，越往深处挖掘，越有挑战也越有乐趣。之前就很想要有个属于自己域名，自己的博客，可以在自己的博客里分享自己学到的、感受的，这也是在这世上孤独的自己的一种乐趣。如今将想法做成现实，希望能多多commit :)</p><a id="more"></a><h2 id="github-pages">GitHub Pages</h2><p>首先当然是要在Github创建一个repository, 用于存放自己的blog文件.</p><p>申请好之后在仓库<code>Settings</code>处往下拉, 到<code>GitHub Pages栏中</code> <img src="./snapshot6.png" alt="snapshot6"></p><figure><img src="./snapshot7.png" alt="snapshot7"><figcaption>snapshot7</figcaption></figure><p>选择<code>master branch</code>刷新后, 就会在<code>username.github.io</code>自动生成一个网站, GitHub Pages就已经生成了, 之后我们在GoDaddy里申请好了域名, 再把新域名填入<code>Custom domain</code>就好了.</p><h2 id="godaddy域名申请">GoDaddy域名申请</h2><p>在网上的一些<a href="https://www.godaddy.com/" target="_blank" rel="noopener">GoDaddy</a>申请配置教程稍微有点过时了, 所以在这也说说如何配置.</p><h3 id="选择godaddy的原因">选择GoDaddy的原因</h3><p>其实狗爹这里的域名价格并不是最实惠的, 国内的万网之类的也是可以, 但是使用国内域名可能存在备案之类的,感觉麻烦的, 于是.. (申请的时候搜索一下GoDaddy优惠券会有不小的优惠)</p><h3 id="申请">申请</h3><figure><img src="./snapshot1.png" alt="snapshot1"><figcaption>snapshot1</figcaption></figure><p>查询自己喜欢的域名是否已经被占用, 选好之后添加到购物车. 进入购物车前会推荐你使用它们的隐私服务, <strong>No Thanks</strong> 就好了.</p><p>可使用支付宝, 但不知为啥我这一直用不了支付宝支付, 自动被拒绝了, 所以使用了银联. 第一年只需要14块钱, 也算是很优惠了:) 一般来说 <em>.com </em>.live之类的域名还算便宜, *.cn的比较贵. <img src="./snapshot2.png" alt="snapshot2"></p><h3 id="dns更换">DNS更换</h3><p>狗爹这里的DNS不太稳定, 所以建议使用<a href="https://www.dnspod.cn" target="_blank" rel="noopener">DNSPod</a>进行域名解析.</p><p>首先在刚刚购买的域名这进行DNS更换 <img src="./snapshot3.png" alt="snapshot3"> 选择自定义的dns服务器, 填入以下地址:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f1g1ns1.dnspod.net</span><br><span class="line">f1g1ns2.dnspod.net</span><br></pre></td></tr></table></figure><p>在DNSPod注册完成后, 在控制台域名解析中添加域名 <img src="./snapshot4.png" alt="snapshot4"></p><p>添加主机记录, 用于解析. 其中ip地址是你申请的GitHub Pages的ip地址, 如果不知道ip的话就ping一下就行了. <img src="./snapshot5.png" alt="snapshot5"></p><p>完成了之后, 需要一些时间来让DNS迭代, 一般一两个小时以内就行了.</p><h3 id="在github-pages使用自己的域名">在GitHub Pages使用自己的域名</h3><p>在Github中创建的仓库设置中<code>Custom domain</code>填入新域名就好了, <strong>建议强制使用HTTPS</strong>. 有可能存在一时半会无法解析新域名的情况, 这是DNS还没迭代好, 等一会就好了.</p><h2 id="hexo使用">Hexo使用</h2><p>Hexo是一种简单快捷又强大的博客构建工具，可参照<a href="http://hexo.io/docs/" target="_blank" rel="noopener">Hexo官方文档</a>进行搭建。</p><h3 id="依赖">依赖</h3><ol type="1"><li><a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js</a>，version &gt;= 6.9</li><li>Git</li></ol><h3 id="安装与使用hexo">安装与使用Hexo</h3><p>在全局安装hexo-cli</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>安装成功之后在合适的位置创建Blog文件夹, 用于存放Bolg资源.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir myBlog &amp;&amp; cd myBlog #名字自拟</span><br><span class="line">hexo init # hexo 初始化</span><br></pre></td></tr></table></figure><p>初始化完成, 自动构建了一个简易Hexo包, 结构如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> tree -L 1</span><br><span class="line">.</span><br><span class="line">├── _config.yml  #配置文件</span><br><span class="line">├── node_modules #模块文件夹</span><br><span class="line">├── package-lock.json</span><br><span class="line">├── package.json #所需模块配置信息</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source       #源码, 资源所在包</span><br><span class="line">└── themes       #使用的主题包</span><br></pre></td></tr></table></figure><p>运行以下命令, 根据你的<code>_config.yml</code>配置, 以及<code>source</code>中的资源自动生成静态文件.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br><span class="line"># 以下缩减方式也可</span><br><span class="line">hexo g</span><br></pre></td></tr></table></figure><p>该命令在文件夹下自动生成了<code>public</code>文件夹, 之后是该文件夹deploy到远程网站(Github)中.</p><p>可在本地调试, 查看效果, 默认使用端口4000:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br><span class="line"><span class="meta">#</span> 以下缩减方式也可</span><br><span class="line">hexo s</span><br><span class="line"><span class="meta">#</span> 终端输出</span><br><span class="line">INFO  Start processing</span><br><span class="line">INFO  Hexo is running at http://localhost:4000 . Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure><p>在Blog发布一篇新文章"My First Post":</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new "My First Post"</span><br></pre></td></tr></table></figure><p>随即在 <code>source/_post</code> 文件夹创建一个<code>My-First-Post.md</code>的Markdown文件, 在上面自由创作就猴啦.</p><h3 id="config.yml配置">_config.yml配置</h3><p>在这个yml文件中可以配置大部分Blog应有的设置信息, 看懂英文就行, 这里不多赘述. 但是有几个需要提及的.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim _config.yml</span><br></pre></td></tr></table></figure><p>在最底下的一部分来配置远端Deploy, 在这里建议使用新的分支, 最后再merge到master分支.</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">git</span></span><br><span class="line"><span class="attr">  repository:</span> <span class="attr">https://github.com/username/repo</span></span><br><span class="line"><span class="attr">  branch:</span> <span class="string">hexo-dev</span></span><br></pre></td></tr></table></figure><p>完成之后在本地调试<code>hexo g &amp;&amp; hexo s</code>后, 即可deploy到Github pages了:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy</span><br><span class="line"><span class="meta">#</span> 以下缩减也可以</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>其余配置详情可以看官方文档的配置(<a href="https://hexo.io/docs/configuration" target="_blank" rel="noopener">链接</a>)</p><h3 id="使用theme">使用Theme</h3><p>Hexo默认使用的主题是landscape, 还有许多有趣的主题可以使用.</p><p>本博客使用的主题是<a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">NexT</a>, 如何配置详情就请查看链接内写的吧.</p><p>有其他功能部件使用, 就放以后再更吧 &lt;_&lt;</p><h2 id="参考链接">参考链接</h2><blockquote><ol type="1"><li><a href="http://hexo.io/docs/" target="_blank" rel="noopener">Documentation | Hexo</a></li><li><a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js</a></li><li><a href="https://www.godaddy.com/" target="_blank" rel="noopener">GoDaddy</a></li><li><a href="https://www.dnspod.cn" target="_blank" rel="noopener">DNSPod</a></li><li><a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">NexT</a></li></ol></blockquote>]]>
    </content>


    <categories>

      <category> 博客搭建 </category>

      <category> 工具使用 </category>

    </categories>


    <tags>

      <tag> Hexo </tag>

      <tag> GitHub </tag>

    </tags>

  </entry>


  <entry>
    <title>A lightweight attribute-based encryption scheme for the Internet of Things</title>
    <link href="/2019/05/16/A-lightweight-attribute-based-encryption-scheme-for-the-Internet-of-Things/" />
    <url>/2019/05/16/A-lightweight-attribute-based-encryption-scheme-for-the-Internet-of-Things/</url>

    <content type="html">
      <![CDATA[<h2 id="论文阅读a-lightweight-attribute-based-encryption-scheme-for-the-internet-of-things">论文阅读：A lightweight attribute-based encryption scheme for the Internet of Things</h2><p>文如其名, 比较lightweight, 才9页(笑. 由北京科技大学的博士与中科院博士联手出品.</p><h3 id="abstract">ABSTRACT</h3><blockquote><p>In this paper, a lightweight no-pairing ABE scheme based on elliptic curve cryptography (ECC) is proposed to address the security and privacy issues in IoT. The security of the proposed scheme is based on the ECDH assumption instead of bilinear Diffie–Hellman assumption, and is proved in the attribute based selective-set model. By uniformly determining the criteria and defining the metrics for measuring the communication overhead and computational overhead, the cMomparison analyses with the existing ABE schemes are made in detail. The results show that the proposed scheme has improved execution efficiency and low communication costs. In addition, the limitations and the improving directions of it are also discussed in detail.</p><p>We propose a no-pairing ECC-Based ABE scheme to deal with the data security and privacy issues in IoT. Since it replaces the expensive bilinear pairing operation with <strong>point scalar multiplication on elliptic curve</strong>, it can meet the lightweight requirement and is suitable for IoT.</p></blockquote><p>本文提出了个适用于IoT的ABE解决方案, 因为双线性配对型的ABE很复杂,代价很高,所以采用基于ECC的方法. 同时, 在安全方面采用基于ECDH假设来取代二线Diffie-Hellman假设.</p><p>用在椭圆曲线上的点标量乘法代替代价高的双线性配对,可以减少计算开销和通信开销,更适用于IoT设备.</p><p>ps:Diffie-Hellman密钥交换(<a href="https://blog.csdn.net/lee244868149/article/details/51790397" target="_blank" rel="noopener">csdn</a>和<a href="https://www.zhihu.com/question/29383090" target="_blank" rel="noopener">知乎</a>)</p><a id="more"></a><h3 id="预备知识">预备知识</h3><h4 id="ecc基础">1.ECC基础</h4><p>ECC首先是个公钥加密的算法,生成一对公私钥,私钥用来加密,公钥进行解密与验证.</p><p>私钥是一个数字(非常大),通常是随机选出来的. 通过椭圆曲线乘法生成一个公钥. 比特币是在公钥的基础上继续进行哈希函数生成比特币地址.</p><h5 id="私钥">私钥</h5><p>为了生成私钥,需要挑选一个足够安全的熵源以保证随机性.从编程的角度来看,一般是通过在一个密码学安全的随机源中 去除一长串随机字节,对其进行SHA256哈希算法进行运算,就可以产生一个256位二进制数,一般是以16进制表示.</p><p>有如下随机生成的秘药,以十六进制格式表示:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD</span><br></pre></td></tr></table></figure><p>比特币私钥空间大小是2<sup>256,用十进制表示的话,大约是10</sup>77. 目前可见宇宙被估计只含有10^80个原子.</p><h5 id="公钥">公钥</h5><p>公钥K是通过使用私钥k进行椭圆曲线乘法运算得到公钥,这个过程不可逆: K=k*G,其中G是生成点的常数点. 逆向求私钥及其困难,只能暴力破解.</p><h5 id="椭圆曲线密码学解释">椭圆曲线密码学解释</h5><p>比特币使用的是secp256k1标准的特殊椭圆曲线. 由下述函数定义:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y^2=(x^3 + 7) over (Fp)  or  y^2 mod p=(x^3 + 7) mod p</span><br></pre></td></tr></table></figure><p>上述mod p(素数p取模)表明该曲线实在素数阶p的有限域内, 也写作Fp, 其中: &gt;p = 2^256 – 2^32 – 2^9 – 2^8 – 2^7 – 2^6 – 2^4 – 1, 这是⼀个⾮常⼤的素数.</p><p>上面的素数阶和有限域让我看得头疼,是啥? 带着问题,来到这个<a href="https://blog.csdn.net/qmickecs/article/details/77281602" target="_blank" rel="noopener">博客</a>认真补习了一下离散数学的知识. 这个<a href="https://zhuanlan.zhihu.com/p/33751859" target="_blank" rel="noopener">博客</a>学习ECC的原理.</p><p><strong>椭圆曲线普通方程</strong> :</p><blockquote><p><span class="math inline">\(\large y^2+a_1xy+a_3y=x^3+a_2x^2+a_4x+a_6\)</span> <br> 无穷远点(0,Y,0)</p></blockquote><p>平常点(x,y)斜率k: &gt;<span class="math inline">\(\Large k=-\frac{F_x(x,y)}{F_y(x,y)}=\frac{3x^2+2a_2x+a_4-a_1y}{2y+a_1x+a_3}\)</span></p><p><strong>椭圆曲线Abel群</strong> :</p><p>在椭圆曲线定义了交换群(Abel群) &gt;任意取椭圆曲线上两点P、Q（若P、Q两点重合，则作P点的切线），作直线交于椭圆曲线的另一点R'，过R'做y轴的平行线交于R，定义P+Q=R。这样，加法的和也在椭圆曲线上，并同样具备加法的交换律、结合律.</p><p><img src="https://img-blog.csdn.net/2018040420440653?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0t5b25fUmF5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p><p><strong>有限域椭圆曲线</strong> :</p><p>因为椭圆曲线是连续的,需要将曲线上的点变成离散的点.把椭圆曲线定义在有限域上. 所以椭圆曲线是模p的有限域,记作GF(p)或Fp.</p><p>可表示为(P,+,*),其中p是一个质数,P集合表示{0,1,..,p-1}.其中加运算和乘运算都是模运算. 详情可以看这个<a href="https://www.jianshu.com/p/a754ad2dfe14" target="_blank" rel="noopener">博客</a>,在这不展开.</p><p>椭圆曲线在有限域就表示为 <strong>Ep(a,b)</strong> ,p是质数, x,y∈[0,p-1] &gt;<span class="math inline">\(\large y^2=x^3+ax+b\pmod p\)</span></p><p>选择两个满足下列条件的小于p的非负整数a,b &gt;<span class="math inline">\(\large 4a^3+27b^2\ne0\pmod p\)</span></p><p>Fp上的椭圆曲线同样有加法</p><ul><li>无穷远点O∞是零元, 有O∞+ O∞= O∞，O∞+P=P</li><li>P(x,y)的逆元是 (x,-y mod p)= (x,p-y) ，有P+(-P)= O∞</li><li>P(x1,y1),Q(x2,y2)的和R(x3,y3) 有如下关系：<ol type="1"><li><span class="math inline">\(x_3\equiv k^2-x_1-x_2\pmod p\)</span></li><li><span class="math inline">\(y_3\equiv k(x_1-x_3)-y_1\pmod p\)</span></li><li>若P=Q, 则 <span class="math inline">\(k=(3x_2+a)/2y_1\pmod p\)</span></li><li>若P≠Q, 则 <span class="math inline">\(k=(y_2-y_1)/(x_2-y_1)\pmod p\)</span></li></ol></li></ul><p><strong>举例</strong> :椭圆曲线已知E_23(1,1)上两点P(3,10)，Q(9,7)，求(1)-P，(2)P+Q，(3) 2P</p><figure><img src="https://www.zhihu.com/equation?tex=%5Cbegin%7Barray%7D%7Bl%7D+%5Cleft%28+1+%5Cright%29+-+P+%3D+%5Cleft%28+%7B3%2C+-+10%5Cbmod+23%7D+%5Cright%29+%3D+%5Cleft%28+%7B3%2C13%7D+%5Cright%29+%5C%5C+%5C%5C+%5Cleft%28+2+%5Cright%29k+%3D+%5Cfrac%7B%7B7+-+10%7D%7D%7B%7B9+-+3%7D%7D+%3D+-+%7B2%5E%7B+-+1%7D%7D%5Cbmod+23+%5C%5C+2+%5Ccdot+%7B2%5E%7B+-+1%7D%7D+%3D+1%5Cbmod+23+%5CRightarrow+%7B2%5E%7B+-+1%7D%7D+%3D+12+%5C%5C+k+%3D+-+12%5Cbmod+23+%3D+11+%5C%5C+P+%2B+Q+%3D+%5Cleft%28+%7B%7B%7B11%7D%5E2%7D+-+3+-+9%5Cbmod+23%2C11+%5Ctimes+%5Cleft%28+%7B3+-+%5Cleft%28+%7B+-+6%7D+%5Cright%29%7D+%5Cright%29%5Cbmod+23%7D+%5Cright%29+%3D+%5Cleft%28+%7B17%2C20%7D+%5Cright%29+%5C%5C+%5C%5C+%5Cleft%28+3+%5Cright%29k+%3D+%5Cfrac%7B%7B3+%5Ctimes+%7B3%5E2%7D+%2B+1%7D%7D%7B%7B2+%5Ctimes+10%7D%7D%5Cbmod+23+%3D+7+%5Ccdot+%7B5%5E%7B+-+1%7D%7D%5Cbmod+23+%5C%5C+5+%5Ccdot+%7B5%5E%7B+-+1%7D%7D+%3D+1%5Cbmod+23+%5CRightarrow+%7B5%5E%7B+-+1%7D%7D+%3D+14+%5C%5C+k+%3D+7+%5Ccdot+14%5Cbmod+23+%3D+6+%5C%5C+2P+%3D+%5Cleft%28+%7B%7B6%5E2%7D+-+3+-+3%5Cbmod+23%2C6+%5Ctimes+%5Cleft%28+%7B3+-+7%7D+%5Cright%29%5Cbmod+23%7D+%5Cright%29+%3D+%5Cleft%28+%7B7%2C12%7D+%5Cright%29+%5C%5C+%5Cend%7Barray%7D+" alt="公式"><figcaption>公式</figcaption></figure><p><strong>椭圆曲线加密</strong> : &gt;考虑K=kG ，其中K、G为椭圆曲线Ep(a,b)上的点，n为G的阶（nG=O∞），k为小于n的整数。则给定k和G，根据加法法则，计算K很容易但反过来，给定K和G，求k就非常困难。因为实际使用中的ECC原则上把p取得相当大，n也相当大，要把n个解点逐一算出来列成上表是不可能的。这就是椭圆曲线加密算法的数学依据. &gt; &gt;点G称为基点（base point） &gt; &gt;k（kn）为私有密钥（privte key） &gt; &gt;K为公开密钥（public key)</p><p><strong>ECC保密通信算法</strong> :</p><ol type="1"><li>Alice选定一条椭圆曲线E，并取椭圆曲线上一点作为基点G 假设选定E29(4,20)，基点G(13,23) , 基点G的阶数n=37</li><li>Alice选择一个私有密钥k，并生成公开密钥K=kG 比如25, K= kG = 25G = (14,6）</li><li>Alice将E和点K、G传给Bob</li><li>Bob收到信息后，将待传输的明文编码到上的一点M（编码方法略），并产生一个随机整数r（r小于n,n为G的阶数） 假设r=6 要加密的信息为3,因为M也要在E29(4,20) 所以M=(3,28)</li><li>Bob计算点C1=M+rK和C2=rG C1= M+6K= M+6<em>25</em>G=M+2G=(3,28)+(27,27)=(6,12) C2=6G=(5,7)</li><li>Bob将C1、C2传给Alice</li><li>Alice收到信息后，计算C1-kC2，结果就应该是点M C1-kC2 =(6,12)-25C2 =(6,12)-25*6G =(6,12)-2G =(6,12)-(27,27) =(6,12)+(27,2) =(3,28)</li></ol><p>数学原来上能解密是因为:C1-kC2=M+rK-krG=M+rkG-krG=M</p><p>论文对ECC进行了剖析. &gt;ECC can provide security based on the known public key cryp-tography primitives, which are Elliptic Curve Digital Signature Al-gorithm (ECDSA), key exchange/agreement (ECDH, Elliptic Curve Diffie–Hellman) and Elliptic Curve Integrated Encryption Standard (ECIES). Compared with other public key cryptography schemes, ECC has 3 distinguished features, which make it very fit for resources-constrained environments [22]. &gt; - It only requires significantly smaller key size than RSA and the modular exponent based public key schemes on the same level of security. &gt; - Its point scalar multiplication operation is much faster than modular exponent operation and bilinear mapping operation. &gt; - It is easy to be implemented in hardware. &gt; &gt; In this paper, we take these advantages of ECC and the features of ABE to construct an ABE scheme for IoT, where Elliptic Curve Decisional Diffie–Hellman Problem (ECDDHP) serves as the complexity assumption, and the Elliptic Curve Integrated Encryption Standard (ECIES) is adopted to encrypt the data.</p><p>ECC提供的安全性基于ECDSA,ECDH,ECIES.与其他的公钥加密算法,ECC有如下几个非常适用于资源节约型的环境的特性.</p><ol type="1"><li>相对于RSA,可以用较小量级的密钥大小提供与RSA相同等级的安全性.</li><li>标量乘法运算比模指数运算和双线性映射快得多.</li><li>在硬件上更容易实现.</li></ol><p>本文基于这些ECC的功能,来构建在IoT上的ABE方案. <strong>ECDDH</strong> 来作复杂度假设, <strong>ECIES</strong> 对数据加密.</p><h3 id="ecddh">ECDDH</h3><p><em>ECDH</em> 是一种在椭圆曲线上的Diffie-Hellman的密钥交换协议. 可以帮助具有椭圆曲线公私钥对的双方通过不安全的通道生成 <strong>共享密钥</strong>. 这个共享密钥可以直接当成密钥或者派生出新的密钥来加密接下来通讯内容. &gt;例如, Alice与Bob使用同一套ECC系统(q,a,b,G,p) &gt; &gt; Alice的密钥对是<code>(S_A , P_A=S_A*G)</code>. Bob的密钥对<code>(S_B , P_B=S_B*G)</code> &gt; &gt;那么他们的共享密码K_{A,B}就是: <code>K_{A,B}=S_A* P_B=S_B* P_A=S_A* S_B* G</code></p><p><strong>ECDDH(elliptic curve decisional Diffie–Hellman problem)</strong> 是ECDH的重要变体. &gt;对于具有生成元G的q阶椭圆曲线群G_E, DHH表明, 给定c*G和d*G的条件下,c*d*G是G_E中的随机元素. &gt; (其中,c,d都是在q阶整数上随机取的.) &gt; &gt;也就是说，对于给定的三元组（c·G，d·G，c·d·G）和（c·G，d·G，Z），无法判断Z = c·d·G</p><h3 id="ecies">ECIES</h3><p>ECIES椭圆曲线集成加密方案,包含有密钥交换和公钥加密的部分.</p><p>使用ECDH生成共享密钥,数据的机密性由对称加密算法保证,密钥和数据完整性由MAC密钥的功能保证.</p><p>以下是ECIES的加密与解密步骤: <img src="https://img-blog.csdn.net/20180404205856773?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0t5b25fUmF5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="加解密步骤"></p><h3 id="access-structure">Access structure</h3><p>访问结构用于描述访问策略,可用访问树表示,由如下定义: &gt;(Access Structure [11]). Let <span class="math inline">\(\{A_1, A_2,..., A_n\}\)</span> be a set of attributes. A collection <span class="math inline">\(\mathbb{A}\)</span> = <span class="math inline">\(2^\{A_1,A_2,...,A_n\}\)</span> is monotone, for <span class="math inline">\(\forall B,C\)</span>: if <span class="math inline">\(B\in \mathbb{A}\)</span> and <span class="math inline">\(B\subseteq C\)</span>, then <span class="math inline">\(C ∈ \mathbb{A}\)</span>. An access structure (respectively, monotone) is a collection (respectively, monotone) <span class="math inline">\(\mathbb{A}\)</span> of non-empty subsets of <span class="math inline">\(\{A_1,A_2,..,A_n\}\)</span>, i.e.,<span class="math inline">\(\mathbb{A}⊆\)</span><span class="math inline">\(2^{A_1,A_2,..,A_n}\setminus \emptyset\)</span>. The sets in A are called the authorized attributes sets, and the sets not in A are called the unauthorized attributes sets.</p><p>有那么一组属性组 <span class="math inline">\(\{A_1, A_2,..., A_n\}\)</span>, 设有一二元集合 <span class="math inline">\(\mathbb{A}\)</span> = <span class="math inline">\(2^\{A_1,A_2,...,A_n\}\)</span>, 如果对与任意的B与C,有B属于A,且B是C的子集,得到 C也属于A.那么二元集合A是单调的.</p><p>所以访问结构是属性集合 <span class="math inline">\(\{A_1, A_2,..., A_n\}\)</span> 的非空子集 <span class="math inline">\(\mathbb{A}\)</span> ,集合 <span class="math inline">\(\mathbb{A}\)</span> 称为授权集.</p><p><strong>访问树</strong> 的具体定义与原理 在这篇<a href="https://zhuanlan.zhihu.com/p/21664741" target="_blank" rel="noopener">文章</a>有详细提及, 在这不详细说.</p><h2 id="算法实现细节">算法实现细节</h2><p>该算法是用KP-ABE的结构, 涵括了AA(attribute authority). 由四个算法步骤组成:</p><ol type="1"><li>Setup: 在中心节点生成public key parameters,PK和master key,MK. master key作为私钥在中心节点所用, public key parameters向外公开.</li><li>Encrypt: 由发送者执行,将消息M输入,中心节点的PK加密输入(确定中心节点),设定属性集r,输出密文CM.</li><li>key-Generation:由中心节点执行,将访问结构R和中心节点MK输入,根据R输出解密钥匙D.</li><li>Decrypt: 由接收者执行,输入发送者发送的密文CM,中心节点给的解密钥匙D,中心节点的PK,当R(r)=1时, 可以得出解密后的消息M.</li></ol><h3 id="本文的给出的kp-abe算法">本文的给出的KP-ABE算法</h3><p>本文所给出的轻量级的ABE是基于ECC的,假定ECC的参数是(q,a,b,G,p).</p><p>对于属性集w, 密钥是由基于拉格朗日插值法的secret sharing构建的. 且该方法有一个ECC-based的密钥生成中心. （拉格朗日插值法学习<a href="https://www.zhihu.com/question/58333118/answer/262507694" target="_blank" rel="noopener">链接</a>）</p><ol type="1"><li><p><strong>Setup</strong>:首先是定义中心节点的属性集U,对U中每个属性<span class="math inline">\(i\)</span>, 在ECC的q阶正整数群内随机找一个对应的数字 <span class="math inline">\(s_i\)</span>,每个属性<span class="math inline">\(i\)</span>的公钥就是<span class="math inline">\(P_i=s_i\cdot G\)</span>. 同样地,在q阶正整数群内随机找一个数字<span class="math inline">\(s\)</span>作为中心节点的MK,中心节点的PK就等于 <span class="math inline">\(PK=s \cdot G\)</span>, 所以中心节点的公开参数可以表示为: <span class="math inline">\(Params=\{ PK,P_1,..,P_\left | U \right|\}\)</span></p></li><li><p><strong>Encryption(M,w,Params)</strong>: 与现存的ABE不同的是, 消息M是由ECIES加密的,而不是模指数运算或者双线性配对加密的.</p><ul><li>随机从ECC的q阶正整数群选择k来计算C',<span class="math inline">\(C&#39;=k \cdot PK=(K_x,K_y)\)</span>,若C'为0则重选k.</li><li>分别对Params中<span class="math inline">\(P_i\)</span>计算<span class="math inline">\(C_i\)</span>, <span class="math inline">\(C_i=k \cdot P_i, i \in w\)</span>.</li><li><span class="math inline">\(K_x\)</span>为加密密钥,<span class="math inline">\(K_y\)</span>则是整合的密钥. <span class="math inline">\(C=ENC(M,K_x)\)</span>, <span class="math inline">\(MAC_M=HMAC(M,K_y)\)</span></li><li>密文cipher-text就可以表示为<span class="math inline">\(CM=(w,C,MAC_M,C_i,i\in w)\)</span>.</li></ul></li><li><p><strong>KeyGeneration(<span class="math inline">\(\Gamma,MK\)</span>)</strong>: 当且仅当 <span class="math inline">\(\Gamma (w)=1\)</span>时,通过算法生成解密的密钥.</p><ul><li>对访问控制树 <span class="math inline">\(\Gamma\)</span>上的每个节点u都自上而下进行定义,这些节点的门限都是<span class="math inline">\(d_u\)</span>. 多项式<span class="math inline">\(q_u(x)\)</span>由此定义</li><li>对于访问树 <span class="math inline">\(\Gamma\)</span>的根R,设<span class="math inline">\(q_R(0)=s\)</span> (ps: s就是setup步骤的MK) 并随机选择<span class="math inline">\(d_R-1\)</span>个其他点做多项式<span class="math inline">\(q_R(x)\)</span></li><li>对于其他节点u, <span class="math inline">\(q_u(0)=q_{parent(u)}(index(u))\)</span>,也要随机选择<span class="math inline">\(d_u-1\)</span>个其他点来定义<span class="math inline">\(q_u(x)\)</span></li><li>当访问树的叶子节点都被定义了之后,叶子节点u的secret share解密密钥就可以表示为: <span class="math inline">\(\large D_u=q_u(0)/s_i\)</span>,其中<span class="math inline">\(i\)</span>是一个属性,<span class="math inline">\(s_i\)</span>在setup步骤上就已经定义,<span class="math inline">\(s_i^-1\)</span>是<span class="math inline">\(s_i\)</span>在ECC群中的逆元.根据这样的访问树结构就能逐步还原.</li><li>最终解密密钥可以表示为: <span class="math inline">\(D=(D_u=q_u(0)/s_i, i=attr(u)\ and\ \ i\in w)\)</span>.</li></ul></li><li><p><strong>Decryption(CM,D,Params)</strong>:与其他算法相似,在访问树里的节点的解密算法用递归的方法实现.</p><ul><li><p>对每个叶子节点u, 令 <span class="math inline">\(i=attr(u)\)</span> 有: $ DecryptNode(CM,D,u)=$ \begin{cases} D_u C_i=q_u(0) s_i^-1kP_i\ =q_u(0) s_i^-1ks_iG\ =q_u(0) kG , &amp;(iw)\ , &amp;Otherwise. \end{cases}</p></li><li><p>对非叶子节点,可以对每个子节点v调用<span class="math inline">\(DecryptNode(CM,D,v)\)</span>.</p></li></ul></li></ol><ul><li><p>令<span class="math inline">\(w_u\)</span>为u的<span class="math inline">\(d_u\)</span>个子节点的集合, 对每一个<span class="math inline">\(w_u\)</span>的元素v进行<span class="math inline">\(DecryptNode(CM,D,v)\)</span>.</p></li><li><p>若存在<span class="math inline">\(w_u\)</span>,那么有: &gt;<embed src="http://latex.codecogs.com/gif.latex?%5Clarge%20DecryptNode%28CM%2CD%2Cu%29%5C%5C%20%3D%5Clarge%5Csum_%7Bv%5Cin%20w_u%7D%5CDelta_%7Bi%2Cw%27_u%7D%280%29%5Ccdot%20DecryptNode%28CM%2CD%2Cv%29%5C%5C%20%5Clarge%5Cmbox%7Bwhere%20%7D%20i%3D%5Cmbox%7Bindex%7D%28v%29%2C%20w%27_u%3D%5C%7B%5Cmbox%7Bindex%7D%28v%29%2Cv%5Cin%20w_u%5C%7D%5C%5C%20%3D%5Clarge%5Csum_%7Bv%5Cin%20w_u%7D%5CDelta_%7Bi%2Cw%27_u%7D%280%29%5Ccdot%20q_v%280%29%5Ccdot%20k%5Ccdot%20G%5C%5C%20%3D%5Clarge%5Csum_%7Bv%5Cin%20w_u%7D%5CDelta_%7Bi%2Cw%27_u%7D%280%29%5Ccdot%20q_%7Bparent%28v%29%7D%28index%28v%29%29%5Ccdot%20k%5Ccdot%20G%5C%5C%20%3D%5Clarge%5Csum_%7Bv%5Cin%20w_u%7D%5CDelta_%7Bi%2Cw%27_u%7D%280%29%5Ccdot%20q_u%28i%29%5Ccdot%20k%5Ccdot%20G%5C%5C%20%3D%5Clarge%20q_u%280%29%5Ccdot%20k%5Ccdot%20G."></p></li><li><p>对根节点有: <span class="math inline">\(DecryptNode(CM, D, R) = q_R(0)·k·G = s·k·G = (K′_x, K′_y)\)</span>. 其中<span class="math inline">\(K&#39;_x\)</span>就是消息M的解密密钥,<span class="math inline">\(K&#39;_y\)</span>是消息M的集合密钥.<span class="math inline">\(M&#39;=DEC(C,K&#39;_X)\)</span>.</p></li><li><p>如果<span class="math inline">\(HMAC(M&#39;,K&#39;_y)=MAC_M\)</span>,那么就表示消息M已经被正确解密. 所以说所有的正确性,完整性都由<span class="math inline">\(MAC_M\)</span>验证.</p></li></ul><hr><h2 id="算法表现与分析">算法表现与分析</h2><p>本文为了评估所提出的ABE方案的轻量级的特点,在 <em>通信开销</em> 和 KP-ABE和CP-ABE的 <em>加算开销</em> 上分析. 并给出该算法的限制.</p><h3 id="通信开销指标">通信开销指标</h3><p>通信开销取决于所传输的消息的长度. 传输的消息包括了 <strong>密文cipher-text</strong> ,<strong>公钥</strong> 和 <strong>私钥</strong>.</p><p>现有大多数ABE方案都是基于双线性配对的RSA-based方案. 有两个群<span class="math inline">\(G_1,G_2\)</span>, <span class="math inline">\(G_1\)</span>是一个大素数阶的双线性群, 双线性映射可以表示为 <span class="math inline">\(G_1 \times G_1 \rightarrow G_2\)</span>. 且<span class="math inline">\(G_1,G_2\)</span> 的基本运算都是模指数运算. 在相同安全级别上,RSA的密钥对比ECC的密钥对长得多.RSA的密钥对长度在 <span class="math inline">\(G_1\)</span> 是ECC的3.2倍,<span class="math inline">\(G_2\)</span> 是6.4倍.</p><p>在ABE方案中,密文需要包含属性集, 密文的长度与属性集成线性增长.</p><p>密文 <span class="math inline">\(CM=(w,C,MAC_M,C_i,i\in w)\)</span> ,<span class="math inline">\(C_i\)</span>是椭圆曲线的一点,且长度为<span class="math inline">\(2l\)</span>,由于先前的假设,消息M和MAC的长度都为安全级别<span class="math inline">\(l\)</span>,所以<span class="math inline">\(C\)</span>和<span class="math inline">\(MAC_M\)</span>也是<span class="math inline">\(l\)</span>位长. 所以给出的方案的密文长度是 <span class="math inline">\((l+l+k*2l)=(2k+2)l\)</span>.</p><p>另外,公钥是 <span class="math inline">\(\{PK,P_i,i\in U\}\)</span>,每一个元素都是椭圆曲线上的一点,所以公钥长度为 <span class="math inline">\((2l+n*2l)=(2n+2)l\)</span>. 私钥是 <span class="math inline">\(\{D_u=q_u(0)/s_i,\ i=attr(u)\mbox{ and }i\in w\}\)</span>, 长度是<span class="math inline">\(k\cdot l\)</span>.</p><h3 id="计算开销指标">计算开销指标</h3><p>本文对比了现有的CP-ABE和KP-ABE. 计算开销一般是由双线性映射(公钥的加密解密操作)的成本衡量的.本方案中没涉及,所以不计算.本文的加密算法包括了(1+k)点标量乘法,且解密的递归过程不超过(2k-1)点标量乘法,所以总的最多有3k个点标量乘法.</p><p>与其他的方案的比较如下图:</p><p><img src="https://img-blog.csdn.net/2018040419231284?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0t5b25fUmF5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p><p>可以看出在 <strong>公私钥长度</strong> 都远比其他方案要短, <strong>密文长度</strong> 在属性大于10个时大于常数级的方案. <strong>计算开销</strong> 也明显小于一般方案. 所以说在 <strong>轻量级</strong> 的属性加密方案上,该文的方案是很优秀的.</p><h3 id="提出的abe方案的限制">提出的ABE方案的限制</h3><ol type="1"><li><p>撤销属性灵活性较差: 使用的是单调访问结构和秘密共享机制,都是在"AND"和"OR"门上进行的,不支持"NOT"门, 难以表达复杂的访问策略,属性撤销也很麻烦.通常操作都是重新加密来实现属性撤销. 本文并没有讨论属性撤销属性.</p></li><li><p>可扩展性差: 通信开销和计算开销都与加密属性数量成线性关系.</p></li><li><p>通用性较差: 本方案是单一权限上的应用,不适用于多权限结构.</p></li></ol><h2 id="参考文章">参考文章</h2><blockquote><ol type="1"><li>Yao X, Tian Y, Tian Y. A lightweight attribute-based encryption scheme for the Internet of Things[J]. Future Generation Computer Systems, 2015, 49(C):104-112.</li><li><a href="http://pangjiuzala.github.io/2016/03/03/Bitcoin%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E5%AF%86%E7%A0%81%E5%AD%A6/" target="_blank" rel="noopener">Bitcoin加密技术之椭圆曲线密码学</a></li><li><a href="https://blog.csdn.net/qmickecs/article/details/77281602" target="_blank" rel="noopener">谈谈有限域那些事儿</a></li><li><a href="https://blog.csdn.net/qmickecs/article/details/76585303" target="_blank" rel="noopener">离散对数和椭圆曲线加密原理</a></li><li><a href="https://zhuanlan.zhihu.com/p/33751859" target="_blank" rel="noopener">ECC入门+实例 (身份证比特币加密算法)</a></li><li><a href="https://zhuanlan.zhihu.com/p/21664741" target="_blank" rel="noopener">数学、英语对程序员来说重要吗？记线性秘密分享方案（Linear Secret Sharing Scheme，LSSS）的实现</a></li><li><span class="citation" data-cites="马同学的回答">[如何直观地理解拉格朗日插值法？ @马同学的回答]</span><a href="https://www.zhihu.com/question/58333118/answer/262507694" target="_blank" rel="noopener">6</a></li><li><a href="https://www.jianshu.com/p/a754ad2dfe14" target="_blank" rel="noopener">密码学中的离散数学知识学习</a></li></ol></blockquote>]]>
    </content>


    <categories>

      <category> 论文研究 </category>

      <category> 密码学 </category>

    </categories>


    <tags>

      <tag> ECC </tag>

      <tag> 属性加密 </tag>

    </tags>

  </entry>


</search>